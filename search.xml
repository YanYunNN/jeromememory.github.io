<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[十大内部排序]]></title>
    <url>%2F2019%2F10%2F26%2F%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[十大内部排序回顾前言最近一直比较忙，马上就要考试了，所以LeetCode稍微暂时放了放，集中精力回顾了下内部排序算法，本篇文章会对常见的十大内部排序算法进行系统的回顾。 概述算法分类常见排序算法可以分为两大类： 比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法复杂度 部分补充 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 不稳定排序算法：谐音记忆法：快（快排） 些（希尔）选（选择）对（堆）。 总共4个不稳定，6个稳定。 冒泡排序基本思想冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 一次比较两个数字，两两比较，如果前者比后者大，则交换，以此类推，一轮下来，就会产生一个最大的数； 当某一轮没有产生任何一次交换，则说明冒泡完成。 动图演示 代码实现 测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package 排序;import JAVA_I_O.Buffer.BufferedInputStream;import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;public class SortTest &#123; public static void main(String[] args) throws Exception &#123; System.out.println("请输入一个数组，用逗号分隔："); Scanner sc = new Scanner(System.in); String next = sc.nextLine(); String[] net = next.split(",");// String[] arr = Arrays.copyOf(net,net.length);// int[] arr = new int[0]; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int i = 0 ; i &lt; net.length ; i++) &#123; arrayList.add(Integer.parseInt(net[i]));// System.out.println(arr[i]); &#125; int size = arrayList.size(); Integer[] arrInt = arrayList.toArray(new Integer[size]); int[] arr = new int[size]; for(int i = 0 ; i &lt; arrInt.length;i++)&#123; arr[i] = arrInt[i]; &#125;// System.out.println(arr[i]);// int[] InsertSortArray = Sort.InsertSort(arr);// int[] SelectSortArray = Sort.SelectSort(arr); Sort.BubbleSort(arr);// int[] ShellSortArray = Sort.ShellSort2(arr);// Sort.quickSort(arr,0,arr.length-1);// Sort.heapSort(arr,arr.length-1);// Sort.courtSort(arr);// Sort.BucketSort(arr);// Sort.radixSort(arr);// for (int i = 0 ; i &lt; ShellSortArray.length ; i++) &#123;// System.out.print(ShellSortArray[i] + " ");// &#125; &#125;&#125; 冒泡算法 1234567891011121314151617181920212223242526272829/** * 冒泡 * * @param sortArray 原始数组 * @return 排序数组 */public static void BubbleSort(int[] sortArray) &#123; //复制一份原始数组，用于排序操作 int[] arr = Arrays.copyOf(sortArray, sortArray.length); //循环n-1轮，剩最后一个就不需要交换了 for (int i = 1; i &lt; arr.length; i++) &#123; //标志位，当一轮下来没有任何变化时，说明冒泡结束，需要结束循环 boolean flag = true; //每一轮都要两两比较，注意每一轮结束都会确认一个值在正确的位置上，所以j的遍历次数得稍加注意 for (int j = 0; j &lt; arr.length - i; j++) &#123; //位置变化的同时说明冒泡没有结束 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 算法效率 时间复杂度：很明显，看代码就知道，冒泡有两个for循环，所以一般情况下和最坏情况下的复杂度都为O(n²)，最好的时间复杂度就是一次冒泡就完成了，即为O(n); 空间复杂度：在冒泡中，只用了temp来存储中间变量交换，没有用到其他空间(我的代码中的复制初始数组的容量其实可以省去)，所以空间复杂度是O(1); 稳定性： tips]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现单链表]]></title>
    <url>%2F2019%2F10%2F16%2Fjava%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[Java实现单向链表基本功能先说一下，参考借鉴的博客有： Java实现单向链表基本功能 Java单链表反转 详细过程 从链表中删除重复数据（三种方法) 补充写的没人家好，这部分主要是对第一个博客的补充，其单向链表中的链表反转和从链表中删除重复数据解释的不够清晰，后面两个博客是扩展这两个知识点的，在看这个知识点的同时，发现用到了部分HashTable的知识，过段时间需要把这个知识点也完善一下。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transient关键字]]></title>
    <url>%2F2019%2F10%2F12%2Ftransient%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[transient关键字作用(转载)作用及使用方法​ 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 ​ 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 ​ 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: Alexiapassword: null 密码字段为null，说明反序列化时根本没有从文件中获取到信息。 transient使用小结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; // 在反序列化之前改变username的值 User.username = "jmwang"; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; public static String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: jmwangpassword: null 这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。 3. transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;/** * @descripiton Externalizable接口的使用 * * @author Alexia * @date 2013-10-15 * */public class ExternalizableTest implements Externalizable &#123; private transient String content = "是的，我将会被序列化，不管我是否被transient关键字修饰"; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(content); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; content = (String) in.readObject(); &#125; public static void main(String[] args) throws Exception &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream( new File("test"))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File( "test"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125; content变量会被序列化吗？ 好吧，我把答案都输出来了，是的，运行结果就是：是的，我将会被序列化，不管我是否被transient关键字修饰 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ ​ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。 转载于：Java transient关键字使用小记]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode学习]]></title>
    <url>%2F2019%2F10%2F12%2Fleetcode%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[第1题：两数之和题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的思路 先排序 排除比target大的数 从最靠近target的数开始遍历 记录找到的数的下标输出即可 我的代码（未AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Arrays;public class twoNumbersSum &#123; public int[] twoSum(int[] nums, int target) &#123; //先排序 int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.sort(nums_copy); int i; //排除比target大的数 //从最靠近target的数开始遍历 //记录找到的数的下标，输出即可 int t; int k; for(i = nums_copy.length-1; i &gt; 0 ;i--)&#123; if(nums_copy[i] &lt;= target)&#123; if(Arrays.binarySearch(nums_copy,0,i,target-nums_copy[i]) &gt;= 0)&#123; if(nums_copy[i] * 2 == target) &#123; int[] twobro = new int[2]; int d=0; for(int h=0;h&lt;nums.length;h++)&#123; if(nums[h] == nums_copy[i])&#123; twobro[d] = h; d++; &#125; &#125; return twobro; &#125; else&#123; for(int m=0;m &lt; nums.length;m++)&#123; if(nums[m] == nums_copy[i])&#123; t = m; &#125; if(nums[m] == (target-nums_copy[i]))&#123; k = m; &#125; &#125; k = Arrays.binarySearch(nums,target-nums_copy[i]); t = Arrays.binarySearch(nums,nums_copy[i]); &#125; return new int[]&#123;k,t&#125;; &#125; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; twoNumbersSum tws = new twoNumbersSum(); int[] receive = new int[20]; receive = tws.twoSum(new int[]&#123;0,4,3,0&#125;,0); if(receive == null) &#123; System.out.println("不存在"); &#125; else&#123; System.out.println(receive[0] + "\n" + receive[1]); &#125; &#125;&#125; 正确思路利用 HashMap 记录数组元素值和对应的下标，对于一个数 nums[i]，判断 target - nums[i] 是否存在 HashMap 中，存在的话，返回两个下标组成的数组。注意，已存在的元素下标在前，当前元素下标在后。 正确代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) &#123; return new int[] &#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125;&#125; 涉及的知识点数组内容 一维和二维数组一维数组：int[] a = new int[4];二维数组： 1234//第一行4个元素，第二行5个元素int[][] a = new int[2][];a[0] = new int[4];a[1] = new int[5]; Arrays类java.util.Arrays类能够方便的操作数组，提供的所有方法都是静态的： 12345678910import java.util.Arrays;public int[] twoSum(int[] nums, int target) &#123; int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.fill(nums,2); Integer index = Arrays.binarySearch(nums,target); Arrays.equals(nums,nums_copy); Arrays.sort(nums); return new int[]&#123;0,0,0&#125;;&#125; 总共5个方法，分别是copyOf,fill,binarySearch,equals,sort。第一个用来复制原始数组，方便后续排序的操作，fill是用来初始化数组比较方便，可以将所有数组中的值全部初始化为同一个值，binarySearch是二分查找，返回的是该数的索引值，sort是用来排序的。 binarySearch()自己写代码的时候用到了这个方法，首先该方法需要数组排好序才能调用，其次很特别的是，如果要找的值在数组中，则会返回搜索键的索引，但是，注意：值不存在于数组的话会返回-1或者是目标值需要插入的位置，从1开始数起，不是0哦！！！这个写的贼好哈哈哈哈：数组查询Arrays类的binarySearch()方法详解 map.containsKey和map.get()区别hashmap判断是否存在key时，使用get(key)==null判断还是containsKey？key值可能为null，若此时Map集合值对象为null，并且没有个数限制，所以当get()方法的返回值为null时，可能有两种情况，一种是在集合中没有该键对象，另一种是该键对象没有映射任何值对象，即值对象为null。因此，在Map集合中不应该利用get(Object key)方法来判断是否存在某个键，而应该利用containsKey()方法来判断,containsKey方法用来判断Map集合对象中是否包含指定的键名。一句话概括:get()如果得到null，可能这是键对应的值对象为null也可能是不存在该键，而containsKey则是false或true，不存在这种疑问。 扩充:map.containsKey()、map.containsValue()、map.get() get的过程是先计算hash，然后通过hash与table.length取摸计算index值，然后遍历table[index]上的链表，直到找到key，然后返回； 1234567891011121314public V get(Object key) &#123; if (key == null) return getForNullKey();//处理null值 int hash = hash(key.hashCode());//计算hash //在table[index]遍历查找key，若找到则返回value，找不到返回null for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; containsKey方法也是先计算hash，然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值； 123456789101112131415public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 看代码能看到区别，一个是返回key对应的value值，一个是返回是否有该key的boolean变量。 containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效。 1234567891011public boolean containsValue(Object value) &#123; if (value == null) return containsNullValue(); Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; 知识缺陷 压根没想到用Map去做 自己只考虑到了全是正数的情况，所以用了排序和跟0判断，如果含有负数的话就做不了了…… 收获在遇到数组问题时，可以考虑用map，因为索引和数值就是一个天生的map集合，如果我知道数值，我就可以通过map找到其索引，本题思路就是这样，当已知一个值是我所需要的，直接从map中拿出就行。 插入知识点既然复习到了map，那就给list、set和map来一个全部的复习吧！！！嘿嘿开始吧！！！先来上个链接，主要是看的这个写的：Java集合中List,Set以及Map等集合体系详解(史上最全) collection先上个图：这个图画的好啊哈哈哈哈哈哈哈不瞎的都看得到，Collection这个接口下有三个接口继承，分别是Set、List、Queue(我他妈好像没怎么用过Queue啊，以后要多用点了)，Set有三个实现类，分别是HashSet、LinkedHashSet、TreeSet，List有三个实现类，分别是ArrayList、Vector(感觉现在是不是用的比较少啊…)、LinkedList，咦这个LinkedList牛逼啊，竟然还是Queue的实现类，不过看别人博客好像是说继承Queue部分的LinkedList是被阉割了的实现类，也就是Queue不能访问到LinkedList的所有方法(管它呢我都没用过…)，还有一个PriorityQueue,看名字就知道是优先级队列啦！(妈呀看的资料太多，想单独开一篇来总结集合源码和Map源码了…算了先这样写着吧) ####先列个提纲： 1.先综述一下collection中三个儿子接口得各个实现类的特点，比如底层实现，优缺点等等； 2.分别阐述，分述时记得贴上源码分析 3.面试常问到的点 综述— List 有序,可重复 ArrayList优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高特点: 允许null，不同步Vector优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低tips:所谓的线程安全，是相对的，在vector内部内部内部，其所有方法不会被多线程所访问，单个方法的原子性（注：原子性，程序的原子性即不会被线程调度机制打断），并不能保证复合操作也具有原子性，所以如果是复合操作，同样线程不安全！！如果要保证真正的线程安全，还需要以vector对象为锁，来进行操作，但这样就跟ArrayList没啥区别了…———–&gt; Vector是线程安全吗特点：允许null，不同步LinkedList优点: 底层数据结构是双向链表，查询慢，增删快。缺点: 线程不安全，效率高特点：允许null，不同步 —Set 无序,唯一 HashSet（不同步，允许null）底层数据结构是哈希表(无序,唯一)，其实就是HashMap的实例，只不过值是key，value是一个固定的对象。如何来保证元素唯一性?1.依赖两个方法：hashCode()和equals() LinkedHashSet（不同步，允许null）底层数据结构是双向链表和哈希表。(FIFO插入有序,唯一)，实际上依旧是LinkedHashMap的实例，待会源码分析看看1.由链表保证元素有序2.由哈希表保证元素唯一 TreeSet（允许null，不同步）底层数据结构是红黑树。(唯一，有序，这里的有序指的是排序好的，不是说FIFO之类的)，实际上依旧是TreeMap的实例 如何保证元素排序的呢?自然排序(重写):1.Student类中实现 Comparable接口 2.重写Comparable接口中的Compareto方法比较器排序:1.单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口 2.重写Comparator接口中的Compare方法2.如何保证元素唯一性的呢?根据比较的返回值是否是0来决定 -Queue PriorityQueue：优先级队列，按照大小排序好了的队列，并不遵循先进先出，不允许null元素，头部是最小元素，底层采用的数组和堆。 * PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。 * 不允许插入 null 元素。 * PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。 * 方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。 剩余有关Queue队列看—–&gt; Java集合（七） Queue详解 分别阐述这个还是另开一篇吧…内容太多了…够写两星期了！！还是不放在这喧宾夺主了!! map 具体展开见另一篇博客：map源码分析 第2题：两数相加题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路 先讲输入输出。要输入两个链表，首先就要构造Node实体类，注意构造函数有多个，根据参数的不同进行选择，输出同输入，将组合好的链表的头结点(有数据的)返回后，就可以循环将整个链表打印出来了； 再讲实现。见代码注释。 我的代码（AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package 链表实现_java.leecode第二题;public class leecode_second_Link &#123; public static void main(String[] args) &#123; Node head = new Node(2); Node node1 = new Node(5); Node node2 = new Node(8); Node node3 = new Node(7); head.setNext(node1); node1.setNext(node2); node2.setNext(node3); // 打印链表1 Node temp = head; while (temp != null) &#123; if(temp.next == null) &#123; System.out.println(temp.getData()); &#125; else &#123; System.out.print(temp.getData() + "--&gt;"); &#125; temp = temp.getNext(); &#125; System.out.println("+"); Node head_sec = new Node(2); Node node1_sec = new Node(4); Node node2_sec = new Node(6); Node node3_sec = new Node(7); head_sec.setNext(node1_sec); node1_sec.setNext(node2_sec); node2_sec.setNext(node3_sec); // 打印链表2 Node temp1 = head_sec; while (temp1 != null) &#123; if(temp1.next == null) &#123; System.out.println(temp1.getData()); &#125; else &#123; System.out.print(temp1.getData() + "--&gt;"); &#125; temp1 = temp1.getNext(); &#125; System.out.println("="); Node head3 = new leecode_second_Link().addTwoNums(head,head_sec); //打印总和链表 Node temp3 = head3; while(temp3 != null)&#123; if(temp3.next == null) &#123; System.out.println(temp3.getData()); &#125; else &#123; System.out.print(temp3.getData() + "--&gt;"); &#125; temp3 = temp3.getNext(); &#125; &#125; public Node addTwoNums(Node head1,Node head2)&#123; //没啥用，初始化头结点(可以不带数据) Node res = new Node(0); //temp是后面用来遍历链表的 Node temp = res; //这个是商，用来进位给下一位的 int quo = 0; //循环，只有当第一个链表中的值为空且第二个链表中的值为空且没有了进位，计算才算结束 while(head1 != null || head2 != null || quo != 0)&#123; //t为两链表相同位置的和加上前面一位的进位 int t = (head1 == null ? 0 : head1.data ) + (head2 == null ? 0 : head2.data) + quo; //商 quo = t/10; //新链表在该位的值 Node head3 = new Node(t % 10); //新链表的第一个值 temp.next = head3; //只有这样，才能让链表next下去，这两步要学会，以后链表经常要用 temp = head3; //分别看两个链表是否为空，如果为空说明该位已经没了，否则就next下去 head1 = (head1 == null ? head1 : head1.next); head2 = (head2 == null ? head2 : head2.next); &#125; //返回链表第一个有值的节点，相当于有值的头结点 return res.next; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package 链表实现_java.leecode第二题;public class Node &#123; //数据域 public Integer data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; public void setData(int Data) &#123; this.data = Data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node Next) &#123; this.next = Next; &#125;&#125; 正确思路同时遍历两个链表，对应值相加(还有 quotient)求余数得到值并赋给新创建的结点。而商则用quotient存储，供下次相加。 正确代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//复杂版/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(-1); ListNode cur = res; int quotient = 0; int t = 0; while (l1 != null &amp;&amp; l2 != null) &#123; t = l1.val + l2.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l1 = l1.next; l2 = l2.next; cur = node; &#125; while (l1 != null) &#123; t = l1.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l1 = l1.next; cur = node; &#125; while (l2 != null) &#123; t = l2.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l2 = l2.next; cur = node; &#125; if (quotient != 0) &#123; cur.next = new ListNode(quotient); cur = cur.next; &#125; return res.next; &#125;&#125; 1234567891011121314151617181920212223242526//简化版/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(-1); ListNode cur = res; int quotient = 0; while (l1 != null || l2 != null || quotient != 0) &#123; int t = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; cur = node; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return res.next; &#125;&#125; 涉及的知识点java中的单链表见我写的另外一篇博文 ——&gt; Java实现单向链表 第3题：无重复字符的最长子串题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 我的思路要找到一个最长子串，就必须有一头一尾，所以就必须有两个指针，然后又是字符串对应索引值，所以肯定是需要用map来操作的，key为索引值，value为索引所在位置的值。于是设定两个指针p、q，最开始同时指定在最开始的位置，然后q向后移动，每移动一次，只要q对应的值没有在map中，就将其值放入map，并且记录下串的大小，当碰到了map中相同的值时，就将p向后移到map中出现该值的索引后一位，同时注意！！！此时p可能会回溯，所以此时要用max函数判断一下，然后继续判断串的大小和继续遍历的最长子串的长度，最后返回最长子串长度即可。 我的代码（AC）1234567891011121314151617181920212223242526272829303132package 第三题;import java.util.HashMap;import java.util.Scanner;public class lengthOfLongestSubstring &#123; public static void main(String[] args) &#123; Scanner a = new Scanner(System.in); System.out.println("请输入串: "); String string = a.nextLine(); int num = new lengthOfLongestSubstring().lengthofSubstring(string); System.out.println("最长子串的长度为：" + num); &#125; private int lengthofSubstring(String string) &#123; int max = 0; char[] chars = string.toCharArray(); int p=0,q=0; int len = chars.length; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while(q &lt; len)&#123; if(map.containsKey(chars[q]))&#123; p = Math.max(p,map.get(chars[q])+1); &#125; map.put(chars[q],q); max = Math.max(max,q-p+1); q++; &#125; return max; &#125;&#125; 正确思路利用指针 p, q，初始指向字符串开头。遍历字符串，q 向右移动，若指向的字符在 map 中，说明出现了重复字符，此时，p 要在出现重复字符的下一个位置 map.get(chars[q]) + 1 和当前位置 p 之间取较大值，防止 p 指针回溯。循环的过程中，要将 chars[q] 及对应位置放入 map 中，也需要不断计算出max 与 q - p + 1 的较大值，赋给 max。最后输出 max 即可。 正确代码123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; char[] chars = s.toCharArray(); int len = chars.length; int p = 0, q = 0; int max = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (q &lt; len) &#123; if (map.containsKey(chars[q])) &#123; // 防止p指针回溯，导致计算到重复字符的长度 // eg. abba,当q指向最右的a时，若简单把p赋为map.get(chars[q] + 1)，则出现指针回溯 p = Math.max(p, map.get(chars[q]) + 1); &#125; map.put(chars[q], q); max = Math.max(max, q - p + 1); ++q; &#125; return max; &#125;&#125; 涉及的知识点好像并没有啥新知识点，其实就是用map代替指针的作用。 第237题： 删除链表中的节点题目请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 示例示例 1 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 我的思路本题题干个人觉得没有交代的很清楚，让人感觉有点摸不着头脑，正常来说应该是给定两个参数，但是要写的函数只有一个参数，所以最开始会让人感觉很突兀，但是实际上这道题设计的很巧妙，不需要给定头结点，可以采用替身攻击，给定的node其实就可以当做头结点来处理，因为不可能是最后一个节点，所以后面一定有节点，故可以将node后节点牺牲掉，这样就相当于将node本身干掉了。 个人遇到的困难主要是在输入输出，尤其是构造单链表的过程花费了比较长的时间，总而言之还是对单链表的操作不够熟练，接下来会重点攻克单链表这一块的知识点！ ##我的代码（AC） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package 第237题_删除链表中的节点;import java.util.ArrayList;import java.util.Scanner;public class deleteNode &#123; public static void main(String[] args) &#123; System.out.println("请输入一串数字代表链表："); Scanner sc = new Scanner(System.in); String head = sc.nextLine(); char[] chars = head.toCharArray();// System.out.println(chars); ArrayList list = new ArrayList(); Node head_first = new Node(-1); Node temp = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp.next = new Node(Integer.parseInt(String.valueOf(chars[i]))); temp = temp.next; list.add(chars[i]); &#125; System.out.println("您输入的链表为： "+ list); System.out.println("请您输入要删除的数字："); String data = sc.nextLine(); int data_int = Integer.parseInt(data); Node temp1 = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp1 = temp1.next; if(data_int == temp1.data)&#123; deleteNode(temp1); break; &#125; &#125; System.out.println("删除后的链表为："); Node temp3 = head_first.next; for(int i = 0 ; i &lt; chars.length-1 ; i++) &#123; System.out.print(temp3.data + " "); temp3 = temp3.next; &#125; System.out.println("\n"); &#125; public static void deleteNode(Node node) &#123; Node tmp = node.next; node.data = node.next.data; node.next = node.next.next; tmp = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package 第237题_删除链表中的节点;public class Node &#123; //数据域 public Integer data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; public void setData(int Data) &#123; this.data = Data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node Next) &#123; this.next = Next; &#125;&#125; 正确思路只提供 node 依然可以解决此题。只要把下个结点的 值 &amp; next 赋给当前 node，然后删除下个结点，就可以搞定。 正确代码12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; // 保存下一个结点 ListNode tmp = node.next; // 将下个结点的值赋给当前要删除的结点 node.val = node.next.val; node.next = node.next.next; // tmp 置为空，让 jvm 进行垃圾回收 tmp = null; &#125;&#125; 涉及的知识点 链表的构建 链表删除 不足对链表操作还不是很驾轻就熟，接下来会重点训练链表操作。 第19题：删除链表的倒数第N个节点题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 我的思路删除倒数第n个节点，这个思路比较简单，就是运用两个指针 fast 和 slow ，一个指针比另外一个多n-1步，这样的话当fast指针到最后一个节点的时候，slow指针刚好到达要删除的节点的位置，此时就可以用上题用过的替身牺牲法，牺牲掉要删除节点的下一个节点，只需要将下一个节点的值赋值给当前节点并且将slow.next = slow.next.next即可。但是，有特殊情况 ： 当要删除的节点是最后一个时，无法做到用下一个节点替换，这个时候就要提前预判，不能等到slow到了最后一个节点才考虑删除，要在slow.next.next == null时就考虑！！！ 我的代码（AC）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package 第19题;//import 第237题_删除链表中的节点.Node;import java.util.ArrayList;import java.util.Scanner;public class removeNthFromEnd &#123; public static void main(String[] args) &#123; System.out.println("请输入一串数字代表链表："); Scanner sc = new Scanner(System.in); String head = sc.nextLine(); char[] chars = head.toCharArray();// System.out.println(chars); ArrayList list = new ArrayList(); ListNode head_first = new ListNode(-1); ListNode temp = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp.next = new ListNode(Integer.parseInt(String.valueOf(chars[i]))); temp = temp.next; list.add(chars[i]); &#125; System.out.println("您输入的链表为： "+ list); System.out.print("请您输入要删除的倒数第n个数的节点，n = "); String number = sc.nextLine(); int num = Integer.parseInt(number); ListNode result_node = removeNthFromEnd(head_first.next,num); ListNode temp1 = result_node; while(temp1 != null)&#123;// int data = Integer.parseInt(String.valueOf(temp1.val)); System.out.print(temp1.val); temp1 = temp1.next; &#125; &#125; public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(-1); pre.next = head; ListNode fast = pre; ListNode slow = pre; // 快指针先走 n-1 步 for (int i = 0; i &lt; n-1; ++i) &#123; fast = fast.next; &#125; while (fast.next != null &amp;&amp; slow.next.next != null) &#123; fast = fast.next; slow = slow.next; &#125;// ListNode tmp = slow.next; if(slow.next.next == null &amp;&amp; (n == 1)) &#123; slow.next = null; &#125; else &#123; slow.val = slow.next.val; slow.next = slow.next.next;// tmp = null; &#125; return pre.next; &#125;&#125; 12345678910package 第19题;public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; 正确思路快指针 fast 先走 n 步，接着快指针 fast 与慢指针 slow 同时前进，等到快指针指向链表最后一个结点时，停止前进。然后将 slow 的 next 指向 slow.next.next，即删除了第 n 个结点。最后返回头指针。 这里设置了 pre 虚拟结点(指向 head )是为了方便处理只有一个结点的情况。 正确代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(-1); pre.next = head; ListNode fast = pre; ListNode slow = pre; // 快指针先走 n 步 for (int i = 0; i &lt; n; ++i) &#123; fast = fast.next; &#125; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return pre.next; &#125;&#125; 涉及的知识点单链表的删除…比较简单啦 不足个人感觉其实答案的解法还是要比我的好一些，它是通过直接找到删除节点的前一个，这样就非常好处理了，而且还没有特殊情况…我就很笨了，还自以为是的用了一个替身攻击的方法…学到了！！！要记得用到删除节点的前一个节点，这才是单链表的关键。 第21题：合并两个有序链表题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 我的思路创建一个新链表，然后比较两个链表，哪个小就让新链表的next指向他，如果有一个提前结束了，剩下的链表接上新链表的后半部分。 我的代码（AC）123456789101112131415161718192021public static ListNode merge(ListNode l1, ListNode l2)&#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; // exactly one of l1 and l2 can be non-null at this point, so connect // the non-null list to the end of the merged list. prev.next = l1 == null ? l2 : l1; return prehead.next; &#125; 1234567package 第21题;public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 正确思路利用链表天然的递归性。如果 l1 为空，返回 l2；如果 l2 为空，返回 l1。如果 l1.val &lt; l2.val，返回 l1-&gt;mergeTwoLists(l1.next, l2)；否则返回 l2-&gt;mergeTwoLists(l1, l2.next)。 正确代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 涉及的知识点链表算法题面试必看必看必看！！！！！！！ 第23题：合并K个排序链表题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 我的思路我没做出来，然后看了下讨论区，大概总结出三种思路： * 运用优先级队列，将整个链表扔到优先级队列中，然后一个个取出来就可以了，这种思路代码实现比较简单，但是用了人家封装好的东西，总感觉有点投机取巧的感觉... * 运用分治归并的思想，K个链表两两进行归并。 * 强行归并，两个归并完直接放到后者，然后后者再跟后面的排序，这样复杂度很高。 我的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; int len = lists.length; if (len == 1) &#123; return lists[0]; &#125; // 合并前后两个链表，结果放在后一个链表位置上，依次循环下去 for (int i = 0; i &lt; len - 1; ++i) &#123; lists[i + 1] = mergeTwoLists(lists[i], lists[i + 1]); &#125; return lists[len - 1]; &#125; /** * 合并两个有序链表 * @param l1 * @param l2 * @return listNode */ private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 正确思路 第一种，优先级队列，20ms, 复杂度 时间复杂度： O(N\log k)O(Nlogk) ，其中 \text{k}k 是链表的数目。弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。最后的链表中总共有 N 个节点。 空间复杂度：O(n) 。创造一个新的链表需要 O(n) 的开销。O(k) 。以上代码采用了重复利用原有节点，所以只要 O(1) 的空间。同时优先队列（通常用堆实现）需要 O(k) 的空间（远比大多数情况的 N要小）。 过程： 1.因为链表有序，所以用每个链表的首元素构建初试堆(小顶堆) – 的队列 2.首元素出队，该元素next指向元素入队 第二种，归并分治，典型的归并分治思想，自底向上，依次合并(可结合归并排序理解，将每个链表理解成排序的值)。 复杂度分析 时间复杂度： O(N\log k)O(Nlogk) ，其中 \text{k}k 是链表的数目。 空间复杂度：O(1)O(1) 我们可以用 O(1) 的空间实现两个有序链表的合并。 第三种，强行做。见我的代码，170ms 用第一个链依次和后面的所有链进行双链合并，利用021的双顺序链合并，秒杀！但是效率极低， 时间复杂度是O(x(a+b) + (x-1)(a+b+c) + … + 1 * (a+b+…+z);[a-z]是各链表长度，x表示链表个数-1，可见时间复杂度是极大的。 正确代码 优先级队列 12345678910111213141516171819202122public ListNode mergeKLists(ListNode[] lists) &#123; int len = 0; if((len=lists.length)==0 || lists == null) return null; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(len, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val - o2.val; &#125; &#125;); for (ListNode node : lists) &#123; if(node!=null) queue.add(node); &#125; while(!queue.isEmpty())&#123; ListNode small = queue.poll(); preNode.next = small; if(small.next!=null) queue.add(small.next); //将最小值节点后面的节点添加到队里中 preNode = preNode.next; &#125; return preHead.next; &#125; 归并分治 1234567891011121314151617181920212223242526272829303132333435363738394041/* * @lc app=leetcode.cn id=23 lang=java * * [23] 合并K个排序链表 */// @lc code=start/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return merge(lists, 0, lists.length - 1); &#125; private ListNode merge(ListNode[] lists, int left, int right) &#123; if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l1 = merge(lists, left, mid); ListNode l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125; &#125; 涉及的知识点包括了优先级队列、最小堆、归并以及 分治的思想 优先级队列。java中的优先级队列是PriorityQueue，是通过最小堆实现的 最小堆 归并 分治]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo提交文章出现问题]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95git%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题记录hexo发布文章报错记录：Unhandled rejection TypeError: Cannot set property ‘lastIndex’ of undefined发布文章时出现问题，同时报的错还有：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决措施发现是git出现问题！！！ 控制端输入： 1brew install git 1xcode-select --install 在xcode-select指令安装好之后，再命令检查一下git指令的帮助信息： 1git -h 可以正确输出相应的帮助信息，意味着git已经被修复好了。 原因更新了Catalina导致的，新系统辣鸡哈哈哈哈哈哈]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜大普奔]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%96%9C%E5%A4%A7%E6%99%AE%E5%A5%94.html</url>
    <content type="text"><![CDATA[开心哇！！！终于写到10w字了！！！继续加油！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>happy </tag>
        <tag>happy day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2019%2F10%2F07%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[ArrayList 源码分析（转载）不知道各位朋友，还记得开工前制定的学习目标么？ 有没有一直为了那个目标废寝忘食呢？继 搞懂 Java 内部类 后开始探索总结 Java 集合框架源码的知识，希望能给自己夯实基础，也希望能为自己实现目标更近一步。 ArrayList 源码分析思路ArrayList 是我们 App 开发中常用的 Java 集合类，从学习 Java 开始我们基本上就对它天天相见了，但是通过探索ArrayList 源码，我们将会把它从普通朋友变成知根知底的老朋友,本文将从以下几部分开始分析 ArrayList： ArrayList 概述 ArrayList 的构造函数，也就是我们创建一个 ArrayList 的方法 ArrayList 的添加元素的方法， 以及 ArrayList 的扩容机制 ArrayList 的删除元素的常用方法 ArrayList 的 改查常用方法 ArrayList 的 toArray 方法 ArrayList 的遍历方法，以及常见的错误操作即产生错误操作的原因 ArrayList 概述ArrayList的基本特点 ArrayList 底层是一个动态扩容的数组结构 允许存放（不止一个） null 元素 允许存放重复数据，存储顺序按照元素的添加顺序 ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使用 collections.synchronizedList(List l) 函数返回一个线程安全的ArrayList类. ArrayList 的继承关系12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从 ArrayList 的继承关系来看， ArrayList 继承自 AbstractList ，实现了List\, RandomAccess, Cloneable, java.io.Serializable 接口。 其中 AbstractList和 List 是规定了 ArrayList 作为一个集合框架必须具备的一些属性和方法，ArrayList 本身覆写了基类和接口的大部分方法，这就包含我们要分析的增删改查操作。 ArrayList 实现 RandomAccess 接口标识着其支持随机快速访问，查看源码可以知道 RandomAccess 其实只是一个标识，标识某个类拥有随机快速访问的能力，针对 ArrayList 而言通过 get(index) 去访问元素可以达到 O(1) 的时间复杂度。有些集合类不拥有这种随机快速访问的能力，比如 LinkedList 就没有实现这个接口。 ArrayList 实现 Cloneable 接口标识着他可以被克隆/复制，其内部实现了 clone 方法供使用者调用来对 ArrayList 进行克隆，但其实现只通过 Arrays.copyOf 完成了对 ArrayList 进行「浅拷贝」，也就是你改变 ArrayList clone后的集合中的元素，源集合中的元素也会改变，对于深浅拷贝我已经单独整理一篇文章来讲述这里不再过多的说。 对于 java.io.Serializable 标识着集合可被被序列化。 我们发现了一些有趣的事情，除了 List\ 以外，ArrayList 实现的接口都是标识接口，标识着这个类具有怎样的特点，看起来更像是一个属性。 ArrayList 的构造方法在说构造方法之前我们要先看下与构造参数有关的几个全局变量： 12345678910111213141516171819202122/*** ArrayList 默认的数组容量*/ private static final int DEFAULT_CAPACITY = 10;/*** 这是一个共享的空的数组实例，当使用 ArrayList(0) 或者 ArrayList(Collection&lt;? extends E&gt; c) * 并且 c.size() = 0 的时候讲 elementData 数组讲指向这个实例对象。*/ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/*** 另一个共享空数组实例，再第一次 add 元素的时候将使用它来判断数组大小是否设置为 DEFAULT_CAPACITY*/ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/*** 真正装载集合元素的底层数组 * 至于 transient 关键字这里简单说一句，被它修饰的成员变量无法被 Serializable 序列化 * 有兴趣的可以去网上查相关资料*/ transient Object[] elementData; // non-private to simplify nested class access 对于上述几个成员变量，我们只是在注释中简单的说明，对于他们具体有什么作用，在下边分析构造方法和扩容机制的时候将会更详细的讲解。 ArrayList 一共三种构造方式，我们先从无参的构造方法来开始： 无参构造方法123456/*** 构造一个初始容量为10的空列表。*/ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 这是我们经常使用的一个构造方法，其内部实现只是将 elementData 指向了我们刚才讲得 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个空数组，这个空数组的容量是 0， 但是源码注释却说这是构造一个初始容量为10的空列表。这是为什么？其实在集合调用 add 方法添加元素的时候将会调用 ensureCapacityInternal 方法，在这个方法内部判断了： 123if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125; 可见，如果采用无参数构造方法的时候第一次添加元素肯定走进 if 判断中 minCapacity 将被赋值为 10，所以构造一个初始容量为10的空列表 也就是这个意思。 指定初始容量的构造方法12345678910111213141516/*** 构造一个具有指定初始容量的空列表。* @param 初始容量 * @throws 如果参数小于 0 将会抛出 IllegalArgumentException 参数不合法异常 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 如果我们预先知道一个集合元素的容纳的个数的时候推荐使用这个构造方法，比如我们有个FragmentPagerAdapter 一共需要装 15 个 Fragment ，那么我们就可以在构造集合的时候生成一个初始容量为 15 的一个集合。有人会认为 ArrayList 自身具有动态扩容的机制，无需这么麻烦，下面我们讲解扩容机制的时候我们就会发现，每次扩容是需要有一定的内存开销的，而这个开销在预先知道容量的时候是可以避免的。 源代码中指定初始容量的构造方法实现，判断了如果 我们指定容量大于 0 ，将会直接 new 一个数组，赋值给 elementData 引用作为集合真正的存储数组，而指定容量等于 0 的时候讲使用成员变量 EMPTY_ELEMENTDATA 作为暂时的存储数组，这是 EMPTY_ELEMENTDATA 这个空数组的一个用处（不必太过于纠EMPTY_ELEMENTDATA 的作用，其实它的在源码中出现的频率并不高）。 使用另个一个集合 Collection 的构造方法12345678910111213141516/*** 构造一个包含指定集合元素的列表，元素的顺序由集合的迭代器返回。* @param 源集合，其元素将被放置到这个集合中。 * @如果参数为 null，将会抛出 NullPointerException 空指针异常*/public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray 可能(错误地)不返回 Object[]类型的数组 参见 jdk 的 bug 列表(6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 如果集合大小为空将赋值为 EMPTY_ELEMENTDATA 等同于 new ArrayList(0); this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 看完这个代码我最疑惑的地方是 Collection.toArray() 和 Arrays.copyOf() 这两个方法的使用，看来想明白这个构造参数具体做了什么必须理解这两个方法了。 Object[] Collection.toArray() 方法我们都知道 Collection 是集合框架的超类，其实 Collection.toArray 是交给具体的集合子类去实现的，这就说明不同的集合可能有不同的实现。他用来将一个集合转化为一个 Object[] 数组，事实上的真的是这样的么？参见 jdk 的 bug 列表(6260652)又是什么意思呢 ？我们来看下下边的这个例子： 12345678910111213List&lt;String&gt; subClasses = Arrays.asList("abc","def");// class java.util.Arrays$ArrayList System.out.println(list.getClass()); Object[] objects = subClasses.toArray();// class java.lang.String; Object[] objArray = list.toArray(); //这里返回的是 String[]System.out.println(objects.getClass().getSimpleName()); objArray[0] = new Object(); // cause ArrayStoreException 咦？为啥这里并不是一个 Object 数组呢？其实我们注意到，list.getClass 得到的并不是我们使用的 ArrayList 而是 Arrays 的内部类 Arrays$ArrayList。 123456789ArrayList(E[] array) &#123; //这里只是检查了数组是否为空，不为空直接将原数组赋值给这个 ArrayList 的存储数组。 a = Objects.requireNonNull(array);&#125;@Overridepublic Object[] toArray()&#123; return a.clone();&#125; 而我们调用的 toArray 方法就是这个内部对于 Collection.toArray 的实现， a.clone() ,这里 clone 并不会改变一个数组的类型，所以当原始数组中放的 String 类型的时候就会出现上边的这种情况了。 其实我们可以认为这是 jdk 的一个 bug，早在 05年的时候被人提出来了，但是一直没修复，但是在新的 「jdk 1.9」 种这个 bug 被修复了。 有兴趣的可以追踪 bug 6260652 看下。 Arrays.copyOf 方法这个方法是在集合源码中常见的一个方法，他有很多重载方式,我们来看下最根本的方法： 1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 上边的注释也看出来了，Arrays.copyOf 方法复制数组的时候先判断了指定的数组类型是否为 Object[] 类型，否则使用反射去构造一个指定类型的数组。最后使用 System.arraycopy 这个 native 方法，去实现最终的数组赋值，newLength 如果比 original.length 大的时候会将多余的空间赋值为 null 由下边的例子可见: 12345String[] arrString = &#123;"abc","def"&#125;;Object[] copyOf = Arrays.copyOf(arrString, 5, Object[].class);//[abc, def, null, null, null]System.out.println(Arrays.toString(copyOf)); 当然 ArrayList(Collection&lt;? extends E&gt; c) 复制的时候传递的是 c.size() 所以不会出现 null。 ex: 对于 System.arraycopy 该方法，本文不再展开讨论，有一篇对于其分析很好的文章大家可以去参考System：System.arraycopy方法详解 ok，绕了这么大的圈子终于明白了，ArrayList(Collection&lt;? extends E&gt; c)干了啥了，其实就是将一个集合中的元素塞到 ArrayList 底层的数组中。至此我们也将 ArrayList 的构造研究完了。 ArrayList的添加元素 &amp; 扩容机制敲黑板了！这块是面试的常客了，所以必须仔细研究下了。我们先看下如何给一个 ArrayList 添加一个元素: 在集合末尾添加一个元素的方法123456789101112131415//成员变量 size 标识集合当前元素个数初始为 0int size；/*** 将指定元素添加到集合（底层数组）末尾* @param 将要添加的元素* @return 返回 true 表示添加成功*/public boolean add(E e) &#123; //检查当前底层数组容量，如果容量不够则进行扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //将数组添加一个元素，size 加 1 elementData[size++] = e; return true;&#125; 调用 add 方法的时候总会调用 ensureCapacityInternal 来判断是否需要进行数组扩容， ensureCapacityInternal 参数为当前集合长度 size + 1，这很好理解，是否需要扩充长度，需要看当前底层数组是否够放 size + 1个元素的。 扩容机制1234567891011121314151617//扩容检查private void ensureCapacityInternal(int minCapacity) &#123; //如果是无参构造方法构造的的集合，第一次添加元素的时候会满足这个条件 minCapacity 将会被赋值为 10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; // 将 size + 1 或 10 传入 ensureExplicitCapacity 进行扩容判断 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //操作数加 1 用于保证并发访问 modCount++; // 如果 当前数组的长度比添加元素后的长度要小则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 上边的源码主要做了扩容前的判断操作，注意参数为当前集合元素个数+1，第一次添加元素的时候 size + 1 = 1 ,而 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 长度为 0 ，1 - 0 &gt; 0, 所以需要进行 grow 操作也就是扩容。 1234567891011121314151617181920212223242526272829303132333435/*** 集合的最大长度 Integer.MAX_VALUE - 8 是为了减少出错的几率 Integer 最大值已经很大了*/private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/*** 增加容量，以确保它至少能容纳最小容量参数指定的元素个数。* @param 满足条件的最小容量*/private void grow(int minCapacity) &#123; //获取当前 elementData 的大小，也就是 List 中当前的容量 int oldCapacity = elementData.length; //oldCapacity &gt;&gt; 1 等价于 oldCapacity / 2 所以新容量为当前容量的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果扩大1.5倍后仍旧比 minCapacity 小那么直接等于 minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新数组大小比 MAX_ARRAY_SIZE 就需要进一步比较 minCapacity 和 MAX_ARRAY_SIZE 的大小 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity通常接近 size 大小 //使用 Arrays.copyOf 构建一个长度为 newCapacity 新数组 并将 elementData 指向新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/*** 比较 minCapacity 与 Integer.MAX_VALUE - 8 的大小如果大则放弃-8的设定，设置为 Integer.MAX_VALUE */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 由此看来 ArrayList 的扩容机制的知识点一共又两个 每次扩容的大小为原来大小的 1.5倍 （当然这里没有包含 1.5倍后大于 MAX_ARRAY_SIZE 的情况）扩容的过程其实是一个将原来元素拷贝到一个扩容后数组大小的长度新数组中。所以 ArrayList 的扩容其实是相对来说比较消耗性能的。 在指定角标位置添加元素的方法123456789101112131415161718/*** 将指定的元素插入该列表中的指定位置。将当前位置的元素(如果有)和任何后续元素移到右边(将一个元素添加到它们的索引中)。* @param 要插入的索引位置* @param 要添加的元素* @throws 如果 index 大于集合长度 小于 0 则抛出角标越界 IndexOutOfBoundsException 异常*/public void add(int index, E element) &#123; // 检查角标是否越界 rangeCheckForAdd(index); // 扩容检查 ensureCapacityInternal(size + 1); //调用 native 方法新型数组拷贝 System.arraycopy(elementData, index, elementData, index + 1,size - index); // 添加新元素 elementData[index] = element; size++;&#125; 我们知道一个数组是不能在角标位置直接插入元素的，ArrayList 通过数组拷贝的方法将指定角标位置以及其后续元素整体向后移动一个位置，空出 index 角标的位置，来赋值新的元素。 将一个数组 src 起始 srcPos 角标之后 length 长度间的元素，赋值到 dest 数组中 destPos 到 destPos + length -1长度角标位置上。只是在 add 方法中 src 和 dest 为同一个数组而已。 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 批量添加元素由于批量添加和添加一个元素逻辑大概相同则这里不详细说了，代码注释可以了解整个添加流程。 在数组末尾添加 12345678910111213public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 调用 c.toArray 将集合转化数组 Object[] a = c.toArray(); // 要添加的元素的个数 int numNew = a.length; //扩容检查以及扩容 ensureCapacityInternal(size + numNew); // Increments modCount //将参数集合中的元素添加到原来数组 [size，size + numNew -1] 的角标位置上。 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; //与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false return numNew != 0;&#125; 在数组指定角标位置添加1234567891011121314151617181920public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //同样检查要插入的位置是否会导致角标越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); //这里做了判断，如果要numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0最后位置 则表示要在数组末尾添加 如果 &lt; 0 rangeCheckForAdd 就跑出了角标越界 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 两个方法不同的地方在于如果移动角标即之后的元素，addAll(int index, Collection&lt;? extends E&gt; c)里做了判断，如果要 numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0 最后位置 则表示要在数组末尾添加 如果 numMoved &lt; 0 ，rangeCheckForAdd 就抛出了角标越界异常了。 与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false。 ArrayList 删除元素根据角标移除元素1234567891011121314151617181920212223242526/*** 将任何后续元素移到左边(从它们的索引中减去一个)。*/public E remove(int index) &#123; //检查 index 是否 &gt;= size rangeCheck(index); modCount++; //index 位置的元素 E oldValue = elementData(index); // 需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //采用拷贝赋值的方法将 index 之后所有的元素 向前移动一个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将 element 末尾的元素位置设为 null elementData[--size] = null; // clear to let GC do its work // 返回 index 位置的元素 return oldValue;&#125;// 比较要移除的角标位置和当前 elementData 中元素的个数private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 根据角标移除元素的方法源码如上所示，值得注意的地方是： rangeCheck 和 rangeCheckForAdd 方法不同 ，rangeCheck 只检查了 index是否大于等于 size，因为我们知道 size 为 elementData 已存储数据的个数，我们只能移除 elementData 数组中 [0 , size -1] 的元素，否则应该抛出角标越界。 但是为什么没有和 rangeCheckForAdd 一样检查小于0的角标呢，是不是remove(-1) 不会抛异常呢？ 其实不是的，因为 rangeCheck(index); 后我们去调用 elementData(index) 的时候也会抛出 IndexOutOfBoundsException 的异常，这是数组本身抛出的，不是 ArrayList 抛出的。那为什么要检查&gt;= size 呢？ 数组本身不也会检查么？ 哈哈.. 细心的同学肯定知道 elementData.length 并不一定等于 size，比如： 123456ArrayList&lt;String&gt; testRemove = new ArrayList&lt;&gt;(10); testRemove.add("1"); testRemove.add("2"); // java.lang.IndexOutOfBoundsException: Index: 2, Size: 2 String remove = testRemove.remove(2); System.out.println("remove = " + remove + ""); new ArrayList&lt;&gt;(10) 表示 elementData 初始容量为10，所以 elementData.length = 10 而我们只给集合添加了两个元素所以 size = 2 这也就是为啥要 rangeCheck 的原因了。 移除指定元素1234567891011121314151617181920212223242526272829303132333435/*** 删除指定元素，如果它存在则反会 true，如果不存在返回 false。* 更准确地说是删除集合中第一出现 o 元素位置的元素 ，* 也就是说只会删除一个，并且如果有重复的话，只会删除第一个次出现的位置。*/public boolean remove(Object o) &#123; // 如果元素为空则只需判断 == 也就是内存地址 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //得到第一个等于 null 的元素角标并移除该元素 返回 ture fastRemove(index); return true; &#125; &#125; else &#123; // 如果元素不为空则需要用 equals 判断。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; //得到第一个等于 o 的元素角标并移除该元素 返回 ture fastRemove(index); return true; &#125; &#125; return false;&#125;//移除元素的逻辑和 remve(Index)一样 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 由上边代码可以看出来，移除元素和移除指定角标元素一样最终都是通过 System.arraycopy 将 index 之后的元素前移一位，并释放原来位于 size 位置的元素。 还可以看出，如果数组中有指定多个与 o 相同的元素只会移除角标最小的那个，并且 null 和 非null 的时候判断方法不一样。至于 equals 和 == 的区别，还有 hashCode 方法，我会之后在总结一篇单独的文章。等不急的可以先去网上找找喽。 批量移除/保留 removeAll/retainAllArrayList 提供了 removeAll/retainAll 操作，这两个操作分别是 批量删除与参数集合中共同享有的元素 和 批量删除与参数集合中不共同享有的元素，保留共同享有的元素，两个方法只有一个参数不同!!! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 批量删除与参数集合中共同享有的元素*/public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 如果为空则抛出 NullPointerException 异常 Objects 的方法 Objects.requireNonNull(c); return batchRemove(c, false);&#125; /** 只保留与 c 中元素相同的元素相同的元素*/public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125; /** 批量删除的指定方法 */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // r w 两个角标 r 为 elementData 中元素的索引 // w 为删除元素后集合的长度 int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) // 如果 c 当前集合中不包含当前元素，那么则保留 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // 如果c.contains（o）可能会抛出异常，如果抛出异常后 r!=size 则将 r 之后的元素不在比较直接放入数组 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); // w 加上剩余元素的长度 w += size - r; &#125; // 如果集合移除过元素，则需要将 w 之后的元素设置为 null 释放内存 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; //返回是否成功移除过元素，哪怕一个 return modified;&#125; 可以看到移除指定集合中包含的元素的方法代码量是目前分析代码中最长的了，但是逻辑也很清晰： 从 0 开始遍历 elementData 如果 r 位置的元素不存在于指定集合 c 中，那么我们就将他复制给数组 w 位置， 整个遍历过程中 w &lt;= r。 由于 c.contains(o)可能会抛出异常ClassCastException/NullPointerException，如果因为异常而终止（这两个异常是可选操作，集合源码中并没有显示生命该方法一定会抛异常），那么我们将会产生一次错误操作，所以 finally 中执行了判断操作，如果 r!= size 那么肯定是发生了异常，那么则将 r 之后的元素不在比较直接放入数组。最终得到的结果并不一定正确是删除了所有与 c 中的元素。 批量删除和保存中，涉及高效的保存/删除两个集合公有元素的算法，是值得我们学习的地方,写的真好哈哈哈哈哈！！！ ArrayList 的改查对于一个ArrayList 的改查方法就很简单了，set 和 get 方法。下面我们看下源码吧： 修改指定角标位置的元素1234567891011121314public E set(int index, E element) &#123; //角标越界检查 rangeCheck(index); //下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法 E oldValue = elementData(index); //将 index 位置设置为新的元素 elementData[index] = element; // 返回之前在 index 位置的元素 return oldValue;&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 查询指定角标的元素123456public E get(int index) &#123; //越界检查 rangeCheck(index); //下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法 return elementData(index); &#125; 查询指定元素的角标或者集合是否包含某个元素12345678910111213141516171819202122232425262728293031323334353637//集合中是否包含元素 indexOf 返回 -1 表示不包含 return false 否则返回 truepublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/*** 返回集合中第一个与 o 元素相等的元素角标，返回 -1 表示集合中不存在这个元素* 这里还做了空元素直接判断 == 的操作*/public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 从 elementData 末尾开始遍历遍历数组，所以返回的是集合中最后一个与 o 相等的元素的角标*/public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; ArrayList 集合的 toArry 方法其实 Object[] toArray(); 方法，以及其重载函数 \ T[] toArray(T[] a); 是接口 Collection 的方法，ArrayList 实现了这两个方法，很少见ArrayList 源码分析的文章分析这两个方法，顾名思义这两个方法的是用来，将一个集合转为数组的方法，那么两者的不同之处是，后者可以指定数组的类型，前者返回为一个 Object[] 超类数组。那么我们具体下源码实现： 1234567891011121314public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 可以看到 Object[] toArray() 只是调用了一次 Arrays.copyOf() 将集合中元素拷贝到一个新的 Object[] 数组并返回。这个 Arrays.copyOf() 方法前边已经讲了。所以 toArray() 方法并没有什么疑问，有疑问的地方在于toArray(T[] a) 。 我们可以传入一个指定类型的标志数组作为参数，toArray(T[] a) 方法最终会返回这个类型的包含集合元素的新数组。但是源码判断了 ： 如果 a.length &lt; size 即当前集合元素的个数与参数 a 数组元素的大小的时候将和 toArray() 一样返回一个新的数组。 如果 a.length == size 将不会产生新的数组直接将集合中的元素调用 System.arraycopy() 方法将元素复制到参数数组中，返回 a。 a.length &gt; size 也不会产生新的数组,但是值得注意的是 a[size] = null; 这一句改变了原数组中 index = size 位置的元素，被重新设置为 null 了。 下面我们来看下第三种情况的例子： 12345678910111213141516171819202122232425SubClass[] sourceMore = new SubClass[4]; for (int i = 0; i &lt; sourceMore.length; i++) &#123; sourceMore[i] = new SubClass(i);&#125; //当 List.toArray(T[] a) 中 a.length == list.size 的时候使用 Array.copyOf 会将 list 中的内容赋值给 sourceMore 并将其返回//sourceMore[0,size-1] = list&#123;0, size-1&#125; 而 sourceMore[size] = nullSubClass[] sourceMore = new SubClass[4];for (int i = 0; i &lt; sourceMore.length; i++) &#123; sourceMore[i] = new SubClass(i);&#125;//list to Array 之前 sourceMore [SubClass&#123;test=0&#125;, SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;] sourceEqual.length:: 4System.out.println("list to Array 之前 sourceMore " + Arrays.toString(sourceMore) + " sourceEqual.length:: " + sourceMore.length);SubClass[] desSourceMore = tLists.toArray(sourceMore);//list to Array 之后 desSourceMore [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, null, SubClass&#123;test=3&#125;]desSourceMore.length:: 4System.out.println("list to Array 之后 desSourceMore " + Arrays.toString(desSourceMore) + "desSourceMore.length:: " + desSourceMore.length);//list to Array 之后 source [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, null, SubClass&#123;test=3&#125;]sourceEqual.length:: 4System.out.println("list to Array 之后 source " + Arrays.toString(sourceMore) + "sourceEqual.length:: " + sourceMore.length);//source == desSource trueSystem.out.println("source == desSource " + (sourceMore == desSourceMore)); ArrayList 的遍历ArrayList 的遍历方式 jdk 1.8 之前有三种 ：for 循环遍历， foreach 遍历，迭代器遍历,jdk 1.8 之后又引入了forEach 操作，我们先来看看迭代器的源码实现： 迭代器迭代器 Iterator 模式是用于遍历各种集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 ArrayList 作为集合类也不例外，迭代器本身只提供三个接口方法： 12345public interface Iterator &#123; boolean hasNext();//是否还有下一个元素 Object next();// 返回当前元素 可以理解为他相当于 fori 中 i 索引 void remove();// 移除一个当前的元素 也就是 next 元素。 &#125; ArrayList 中调用 iterator() 将会返回一个内部类对象 Itr 其实现了 Iterator 接口。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 下面让我们看下其实现的源码： 正如我们的 for 循环遍历一样，数组角标总是从 0 开始的，所以 cursor 初始值为 0 ， hasNext 表示是否遍历到数组末尾，即 i &lt; size 。对于 modCount 变量之所以一直没有介绍是因为他集合并发访问有关系，用于标记当前集合被修改（增删）的次数，如果并发访问了集合那么将会导致这个 modCount 的变化，在遍历过程中不正确的操作集合将会抛出 ConcurrentModificationException ，这是 Java 「fast-fail 的机制」，对于如果正确的在遍历过程中操作集合稍后会有说明。 12345678private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 对照 hasNext 方法 cursor 应理解为下个调用 next 返回的元素 初始为 0 int lastRet = -1; // 上一个返回的角标 int expectedModCount = modCount;//初始化的时候将其赋值为当前集合中的操作数， // 是否还有下一个元素 cursor == size 表示当前集合已经遍历完了 所以只有当 cursor 不等于 size 的时候 才会有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; next 方法是我们获取集合中元素的方法，next 返回当前遍历位置的元素，如果在调用 next 之前集合被修改，并且迭代器中的期望操作数并没有改变，将会引发ConcurrentModificationException。next 方法多次调用 checkForComodification 来检验这个条件是否成立。 1234567891011121314151617@SuppressWarnings("unchecked") public E next() &#123; // 验证期望的操作数与当前集合中的操作数是否相同 如果不同将会抛出异常 checkForComodification(); // 如果迭代器的索引已经大于集合中元素的个数则抛出异常，这里不抛出角标越界 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 由于多线程的问题这里再次判断是否越界，如果有异步线程修改了List（增删）这里就可能产生异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // cursor 移动 cursor = i + 1; //最终返回 集合中对应位置的元素，并将 lastRet 赋值为已经访问的元素的下标 return (E) elementData[lastRet = i]; &#125; 只有 Iterator 的 remove 方法会在调用集合的 remove 之后让 期望 操作数改变使expectedModCount与 modCount 再相等，所以是安全的。 12345678910111213141516171819202122// 实质调用了集合的 remove 方法移除元素public void remove() &#123; // 比如操作者没有调用 next 方法就调用了 remove 操作，lastRet 等于 -1的时候抛异常 if (lastRet &lt; 0) throw new IllegalStateException(); //检查操作数 checkForComodification(); try &#123; //移除上次调用 next 访问的元素 ArrayList.this.remove(lastRet); // 集合中少了一个元素，所以 cursor 向前移动一个位置（调用 next 时候 cursor = lastRet + 1） cursor = lastRet; //删除元素后赋值-1，确保先前 remove 时候的判断 lastRet = -1; //修改操作数期望值， modCount 在调用集合的 remove 的时候被修改过了。 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; // 集合的 remove 会有可能抛出 rangeCheck 异常，catch 掉统一抛出 ConcurrentModificationException throw new ConcurrentModificationException(); &#125; &#125; 检查期望的操作数与当前集合的操作数是否相同。Java8 发布了很多函数式编程的特性包括 lamada 和Stream 操作。迭代器也因此添加了 forEachRemaining 方法，这个方法可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。 1234567891011 @Override @SuppressWarnings("unchecked")public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; //... Java8 的新特性，可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。 &#125; // 检查期望的操作数与当前集合的操作数是否相同 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; ListIterator 迭代器ArrayList 可以通过以下两种方式获取 ListIterator 迭代器，区别在于初始角标的位置。不带参数的迭代器默认的cursor = 0 123456789public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index);&#125; public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; ListItr对象继承自前边分析的 Itr，也就是说他拥有 Itr 的所有方法，并在此基础上进行扩展，其扩展了访问当前角标前一个元素的方法。以及在遍历过程中添加元素和修改元素的方法。 ListItr 的构造方法如下： 12345private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index;&#125; ListItr 的 previous 方法： 123456789101112131415161718192021222324252627282930public boolean hasPrevious() &#123; // cursor = 0 表示游标在数组第一个元素的左边，此时 `hasPrevious` 返回false return cursor != 0;&#125;public int nextIndex() &#123; return cursor;//调用返回当前角标位置&#125;public int previousIndex() &#123; return cursor - 1;//调用返回上一个角标&#125;//返回当前角标的上一个元素，并前移移动角标@SuppressWarnings("unchecked")public E previous() &#123; // fast-fail 检查 checkForComodification(); int i = cursor - 1; // 如果前移角标 &lt;0 代表遍历到数组遍历完成，一般在调用 previous 要调用 hasPrevious 判断 if (i &lt; 0) throw new NoSuchElementException(); //获取元素 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //获取成功后修改角标位置和 lastRet 位置 cursor = i; return (E) elementData[lastRet = i];&#125; ListItr 的 add 方法 1234567891011121314151617public void add(E e) &#123; // fast-fail 检查 checkForComodification(); try &#123; // 获取当前角标位置，一般的是调用 previous 后，角标改变后后去 cursor int i = cursor; //添加元素在角标位置 ArrayList.this.add(i, e); //集合修改完成后要改变当前角标位置 cursor = i + 1; //重新置位 -1 如果使用迭代器修改了角标位置元素后不允许立刻使用 set 方法修改修改后角标未知的额元素 参考 set 的源代码 lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 可能对比两个迭代器后，会对 curor 指向的位置有所疑惑，现在我们来看下一段示例代码对应的图： 1234567891011121314151617181920private void testListItr()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); ListIterator&lt;Integer&gt; listIterator = list.listIterator(list.size()); while (listIterator.hasPrevious())&#123; if (listIterator.previous() == 2)&#123; listIterator.add(0); // listIterator.set(10); //Exception in thread "main" java.lang.IllegalStateException &#125; &#125; System.out.println("list " + list.toString());&#125; 由此可以看 cursor 于 数组角标不同，它可以处的位置总比角标多一个，因为在我们使用 Iterator 操作集合的时候，总是要先操作 cursor 移动， listIterator.previous 也好 iterator.next() 也好，都是一样的道理，如果不按照规定去进行操作，带给使用者的只有异常。 java8 新增加的遍历方法 forEachjava8增加很多好用的 API，工作和学习中也在慢慢接触这些 API，forEach 操作可能是我继 lambda 后，第一个使用的 API 了（囧），jdk doc 对这个方法的解释是： 对此集合的每个条目执行给定操作，直到处理完所有条目或操作抛出异常为止。 除非实现类另有规定，否则按照条目集迭代的顺序执行操作（如果指定了迭代顺序）。操作抛出的异常需要调用者自己处理。 其实其内部实现也很简单，只是一个判断了操作数的 for 循环，所以在效率上不会有提升，但是在安全性上的确有提升，也少些很多代码不是么？ 1234567891011121314151617@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; //检查调用者传进来的操作函数是否为空 Objects.requireNonNull(action); //与迭代不同期望操作被赋值为 final 也就是 forEach 过程中不允许并发修改集合否则会抛出异常 final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; //每次取元素之前判断操作数，确保操作正常 for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 对于高级 for 循环以及最普通的 fori 方法这里不再赘述。下面我们看下面试会问到一个问题，也是我们在单线程操作集合的时候需要注意的一个问题，如果正确的在遍历过程中修改集合。 错误操作 1 在 for循环修改集合后继续遍历第一个例子： 1234567891011121314List&lt;SubClass&gt; list2 = new ArrayList&lt;&gt;();list2.add(new SubClass(1));list2.add(new SubClass(2));list2.add(new SubClass(3));list2.add(new SubClass(3));for (int i = 0; i &lt; list2.size(); i++) &#123; if (list2.get(i).test == 3) &#123; list2.remove(i); &#125;&#125;System.out.println(list2);//[SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;] 这个例子我们会发现，程序并没有抛出异常，但是从运行经过上来看并不是我们想要的，因为还有 SubClass.test = 3的数据在，这是因为 remove 操作改变了list.size(),而 fori 中每次执行都会重新调用一次lists2.size()，当我们删除了倒数第二个元素后，list2.size() = 3,i = 3 &lt; 3 不成立则没有在进行 remove 操作，知道了为什么以后我们试着这样改变了循环方式： 123456789int size = list2.size();for (int i = 0; i &lt; size; i++) &#123; if (list2.get(i).test == 3) &#123; list2.remove(i);//remove 以后 list 内部将 size 重新改变了 for 循环下次调用的时候可能就不进去了 &#125;&#125;System.out.println(list2);//Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 果真程序抛出了角标越界的异常，因为这样每次 fori 的时候我们不去拿更新后的 list 元素的 size 大小，所以当我们删除一个元素后，size = 3 当我们 for 循环去list2.get(3)的时候就会被 rangeCheck方法抛出异常。 错误操作导致 ConcurrentModificationException 异常我们分析迭代器的时候，知道 ConcurrentModificationException是指因为迭代器调用 checkForComodification 方法比较 modCount 和 expectedModCount 方法大小的时候抛出异常。我们在分析 ArrayList 的时候在每次对集合进行修改， 即有 add 和 remove 操作的时候每次都会对 modCount ++。 modCount 这个变量主要用来记录 ArrayList 被修改的次数，那么为什么要记录这个次数呢？是为了防止多线程对同一集合进行修改产生错误，记录了这个变量，在对 ArrayList 进行迭代的过程中我们能很快的发现这个变量是否被修改过，如果被修改了 ConcurrentModificationException 将会产生。下面我们来看下例子，这个例子并不是在多线程下的，而是因为我们在同一线程中对 list 进行了错误操作导致的： 12345678910111213Iterator&lt;SubClass&gt; iterator = lists.iterator();while (iterator.hasNext()) &#123; SubClass next = iterator.next(); int index = next.test; if (index == 3) &#123; list2.remove(index);//操作1： 注意是 list2.remove 操作 //iterator.remove()；/操作2 注意是 iterator.remove 操作 &#125;&#125;//操作1： Exception in thread "main" java.util.ConcurrentModificationException//操作2： [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;]System.out.println(list2); 我们对操作1，2分别运行程序，可以看到，操作1很快就抛出了 java.util.ConcurrentModificationException 异常，操作2 则顺利运行出正常结果，如果对 modCount 注意了的话，我们很容易理解，list.remove(index) 操作会修改List 的 modCount，而 iterator.next() 内部每次会检验 expectedModCount != modCount，所以当我们使用 list.remove 下一次再调用 iterator.next() 就会报错了，而iterator.remove为什么是安全的呢？因为其操作内部会在调用 list.remove 后重新将新的 modCount 赋值给 expectedModCount。所以我们直接调用 list.remove 操作是错误的。对于多线程的影响这里不在展开这里推荐有兴趣的朋友看下这个文章 Java ConcurrentModificationException异常原因和解决方法; 经过了一轮分析我们我们知道了错误产生原因了，但是大家是否能真的分辨出什么操作是错误的呢？我们来看下边这个面试题，这是我在网上无意中看到的一道大众点评的面试题： 123456789ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add("sh" + i);&#125;for (int i = 0; list.iterator().hasNext(); i++) &#123; list.remove(i); System.out.println("秘密" + list.get(i));&#125; 一道面试题相信大家肯定知道这样操作是会产生错误的，但是最终会抛出角标越界还是ConcurrentModificationException呢？ 其实这里会抛出角标越界异常，为什么呢，因为 for 循环的条件 list.iterator().hasNext()，我们知道 list.iterator() 将会new 一个新的 iterator 对象，而在 new 的过程中我们将 每次 list.remove 后的 modCount 赋值给了新的 iterator 的 expectedModCount，所以不会抛出 ConcurrentModificationException 异常，而 hasNext 内部只判断了 size 是否等于 cursor != size 当我们删除了一半元素以后，size 变成了 5 而新的 list.iterator() 的 cursor 等于 0 ，0!=5 for 循环继续，那么当执行到 list.remove（5）的时候就会抛出角标越界了。 总结 ArrayList 底层是一个动态扩容的数组结构,每次扩容需要增加1.5倍的容量 ArrayList 扩容底层是通过 Arrays.CopyOf 和 System.arraycopy 来实现的。每次都会产生新的数组，和数组中内容的拷贝，所以会耗费性能，所以在多增删的操作的情况可优先考虑 LinkList 而不是 ArrayList。 ArrayList 的 toArray 方法重载方法的使用。 允许存放（不止一个） null 元素， 允许存放重复数据，存储顺序按照元素的添加顺序 ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类. 不正确访问集合元素的时候 ConcurrentModificationException和 java.lang.IndexOutOfBoundsException 异常产生的时机和原理。本文又长篇大论的分析了一波 ArrayList 的源码，对我个人而言这很有意义，在查看源码的过程中，注意到了平时很少有机会接触的知识点。当然这只是集合源码分析的开端，以后还会更细，其他常用集合源码的分析。如果大家感觉我写的还可以， 请留言 + 点赞 + 关注。 ** 转载：搞懂 Java ArrayList 源码]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA对数组的四种拷贝方式]]></title>
    <url>%2F2019%2F10%2F07%2FJAVA%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[数组拷贝的四种方式 for clone System.arraycopy arrays.copyof 赋值、浅拷贝、深拷贝在谈及四种数组拷贝方式之前，先来缕缕赋值、浅拷贝、深拷贝三者的关系和区别。 数据类型谈及深拷贝和浅拷贝，首先要弄清数据类型有哪些,数据分为基本数据类型(元数据)和引用数据类型(对象引用)。 基本数据类型的特点：直接存储在栈(stack)中的数据 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝和浅拷贝 深拷贝和浅拷贝是只针对引用类型的数据而言的，对于基本数据类型来说，深拷贝和浅拷贝都是直接进行值传递的，与赋值的方式是一样的，三者没有任何区别，区别就在于对于引用数据类型来说，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存,所以如果修改对象的话会互相影响。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 总而言之，在数组内都是基本数据类型时，是不会有深拷贝和浅拷贝这样的概念出现的，只有出现了引用类型的数据，才能谈深拷贝和浅拷贝。Tips: String不是基本数据类型，但是在深复制的时候并没有进行单独的复制，也就是说违反了深复制，仅仅复制了引用，而String没有实现cloneable接口，也就是说只能复制引用。 那么在修改克隆之后的对象之后，会不会将原来的值也改变了? 答案肯定是不会改变，因为String是在内存中不可以被改变的对象，就比如说在for大量循环中不推荐使用+的方式来拼凑字符串一样，每次使用都会新分配一块内存，不在原来上修改，原来的没有指向它的引用，会被回收。所以克隆相当于1个String内存空间有两个引用，当修改其中的一个值的时候，会新分配一块内存用来保存新的值，这个引用指向新的内存空间，原来的String因为还存在指向他的引用，所以不会被回收，这样，虽然是复制的引用，但是修改值的时候，并没有改变被复制对象的值。 数组拷贝方式之一——for()就是for循环咯！！！ 12345/** 1 for 循环拷贝*/int[] arr1 = new int[len];for (int i = 0; i &lt; len; i++) &#123; arr1[i] = arr0[i];&#125; 也是浅拷贝咯！ 数组拷贝方式之二——clone()（主要参考）细说 Java 的深拷贝和浅拷贝 在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。 首先需要说明的是，clone()是浅拷贝的方式！！！其次，我们应该如何实现深拷贝呢，有两种方法： 用多层浅拷贝达到深拷贝的目的，要知道，浅拷贝和深拷贝的区别就是在处理对象引用时，浅拷贝不会创造新的对象，而深拷贝会，但是如果一个对象的属性变成了基本类型数据，那么浅拷贝同样会创造新的对象，所以说，多层浅拷贝就能达到深拷贝的目的，例如：在对fatherClass和childClass进行两级浅拷贝之后，fatherB就有浅拷贝变成了深拷贝，因为此时基本数据类型和Child对象都是指向不同的地址的，也就是二者都是不同的对象，所以就是达到了深拷贝的目的了。 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。总结下来就是做了5件事： 确保对象图中的所有类都是可序列化的 创建输入输出流 使用这个输入输出流来创建对象输入和对象输出流 将你想要拷贝的对象传递给对象输出流 从对象输入流中读取新的对象并且转换回你所发送的对象的类 最后，推一个序列化实现深拷贝的例子：序列化的方式使得其变为深拷贝 数组拷贝方式之三——System.arraycopy()native方法，依旧是一个浅拷贝——–&gt; 详细传送门 数组拷贝方式之四——arrays.copyof()1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 你看看，底层也在用System.arraycopy()这个native方法，所以就不再赘述了，这个在ArrayList源码分析中也有涉及哦！！！！]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Array</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.2----10.7收获]]></title>
    <url>%2F2019%2F10%2F02%2F10-2-10-7.html</url>
    <content type="text"><![CDATA[10.2 学习完ajax异步调用； 完成添加然后数据库里有数据并且能正常跳转； b站上再看看springboot+mybatis的结合； 总结博客，分别总结分页排序还要mongodb在springboot中的相关操作； 收获 springboot启动很慢的原因：未修改host目录的文件，导致每次启动都很慢。步骤 在terminal终端输入: 1$ hostname 复制下来，然后修改host文件中的localhost： 1$ sudo vim /etc/hosts 然后将自己hostname替换掉localhost 123127.0.0.1&lt;两个tab&gt;localhost 替换为$hostname255.255.255.255&lt;两个tab&gt;broadcasthost::1&lt;两个tab&gt;localhost 替换为$hostname 在js传值给controller时，一直不能将json数据传过去，原因是没有给data的值加上JSON.stringify()处理，具体错误：springboot 接收参数，解析json出现错误：was expecting ‘null’, ‘true’, ‘false’ or NaN解决方案：见—-&gt;js与controller之间传值常见问题 JQuery.ajaxajax和springboot传值 jquery中字符串转日期，日期转字符串 MyBatis主键回填策略 表中部分属性自动生成，不需要额外传入参数 先是尝试了在bean中加@value，加载配置文件中的随机数，但是发现执行一次，随机数是唯一的，这样就不能做到插入一条数据，随机数就变化； 后面发现可以在mybatis直接配置结果集，好像也不行…因为如果你用结果集将id转换为taskId,那原本bean中的id属性就会取不到值… jQuery获取html中的值获取html中的值 10.3收获使用最大的id！！！mysql插入数据后返回自增ID的方法（AUTO_INCREMENT） 10.4收获 复杂json转成多层map 12345678910111213141516171819public Map&lt;String, Object&gt; parseJSON2Map(@RequestBody String jsonStr)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); JSONObject json = JSONObject.parseObject(jsonStr); for(Object k : json.keySet())&#123; Object v = json.get(k); if(v instanceof JSONArray)&#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Iterator it = ((JSONArray)v).iterator(); while(it.hasNext())&#123; Object json2 = it.next(); list.add(parseJSON2Map(json2.toString())); &#125; map.put(k.toString(), list); &#125; else &#123; map.put(k.toString(), v); &#125; &#125; return map; &#125; mac强制刷新缓存：command + shift + R普通刷新：command + R Springboot使用多线程 最近遇到一个需求，就是当服务器接到请求并不需要任务执行完成才返回结果，可以立即返回结果，让任务异步的去执行。开始考虑是直接启一个新的线程去执行任务或者把任务提交到一个线程池去执行，这两种方法都是可以的。但是 Spring 这么强大，肯定有什么更简单的方法，就 google 了一下，还真有呢。就是使用 @EnableAsync 和 @Async 这两个注解就 ok 了。传送门：SpringBoot非官方教程 | 第二十三篇： 异步方法 首先声明一下自己用了比较长的时间才弄出来的原因是，自己把异步方法写到了Controller层，导致在controller的另一个方法调用时无法开启异步功能，所以对此我有三点见解： 在@SpringBootApplication启动类 添加注解@EnableAsync 异步方法使用注解@Async ,返回值为void或者Future 切记一点，异步方法和调用方法一定要 写在不同的类中,如果写在一个类中，是没有效果的，至于为什么—-&gt;因为Spring像@Transaction @Async等这些都是使用了动态代理，Spring容器在初始化的时候就会将含有AOP注解的类对象替换为代理对象，再由Proxy对象去调用被增强方法，重点来了：方法里想用增强方法(第三点)则需要得到当前的Proxy对象，但如果是同一个类的话，是不会经过spring容器的，此时是真正的对象本身去调用方法，并不是代理对象，这样的话被增强方法就失效了，详情请看 -&gt;Spring的 AopContext.currentProxy()方法 解决方案 我采用的方案是，将异步方法写入service层，然后再controller层中调用，这样就经过了spring容器，调用方法时就是采用的代理对象。 第二种方法，我没有成功！！！！真的是气的不行，因为我看网上博客别人都成功了……就是用AopContext.currentProxy()这个方法,步骤为： 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类中添加注释 1@EnableAspectJAutoProxy(exposeProxy=true,proxyTargetClass=true) 然后在调用方法处写： 1((TaskController)AopContext.currentProxy()).testAsy("www.baidu.com"); 按理说应该可以了的，结果吧，我一跑程序就报错，说我的哦代理怎么没暴露啊，我真是卧槽了，那他妈不是已经配置了暴露了嘛！！！我服了！！！算了，懒得搭理了…甩个跟这个原理一样的链接，学习一下：JDK动态代理给Spring事务埋下的坑！再甩一个链接，三种方法配置这个exposeProxy(然而我一个都没成功…)—-&gt;springboot中如何配置aop动态代理模式 (原创)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-9-26]]></title>
    <url>%2F2019%2F09%2F26%2F2019-9-26.html</url>
    <content type="text"><![CDATA[今日任务 springboot + mongodb,完成mongo在springboot中的搭建，写一个小demo 最主要的是把repository这一层写完，业务逻辑可以放到明天来写 完成过程mongodb的安装macOS下mongodb的安装与启动 Springboot下的相关注解 @DataData注解使用 @Document标注在实体类上，类似于hibernate的entity注解，标明由mongo来维护该表，collection代表表的名称。SpringBoot中MongoDB中的相关注解 @Entity等一系列Spring Data JPA注解 @DynamicUpdate、@DynamicInsert 是hibernate里面的注解，这两个注解加上之后就不会为字段值不变的字段生成sql语句，这样sql的长度就减少了提高了传输效率和执行效率，在插入和修改数据的时候,语句中只包括要插入或者修改的字段。 @Entity 标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表~！ GeneratedValue、GenericGenerator是用于主键生成策略的，具体见JPA注解主键生成策略-UUID @Column（name = “自定义字段名”，length = “自定义长度”，nullable = “是否可以空”，unique = “是否唯一”，columnDefinition = “自定义该字段的类型和长度”）。表示对这个变量所对应的字段名进行一些个性化的设置，例如字段的名字，字段的长度，是否为空和是否唯一等等设置。 剩余注释：Spring Data JPA中常用的注解详解 @Controller（Spring Boot之 Controller 接收参数和返回数据总结(包括上传、下载文件)）Controller层的注解大概有以下一些：（主要参考：Controller层主要注解） @Controller:标注 Controller 类，处理 http 请求 @RestController:标注 Controller 类，spring 4 新加注解，相当于@Controller + @ResponseBody ，主要是为了使 http 请求返回数据格式为 json 格式，正常情况下都是使用这个注解 @RequestMapping:配置 url 映射，可以作用于类上，也可以在方法上 123456789@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.GET) public String say() &#123; return "我是张少林"; &#125;&#125; @RequestMapping 定义在类上，指定该类下的所有接口 url 映射在 /users 下，定义在方法上，指定 请求方法，可以指定GET，POST，DELETE，PUT四种标准的 Restfulapi请求方法。那么此时的接口 url 为：http://127.0.0.1:8080/users/myInfo 请求方法：GET，类上也可以不用配置 url 映射的。 @PathVariable获取 url 中的数据，我们在 url 中拼接一个字符串 {username}，类似于地址占位符，由用户请求时添加，请求获取。注意注解中的参数必须与占位符参数一致 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo/&#123;username&#125;", method = RequestMethod.GET) public String say(@PathVariable("username") String username) &#123; return username; &#125;&#125; @RequestParam获取请求参数值，方法随意可以设置，但是通常需求都是使用 POST 请求处理表单提交。 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username") String username, @RequestParam(value = "password") String password) &#123; return username + password; &#125;&#125; 假如用户输入的的uri是:http://127.0.0.1:8080/users/myInfo?username=yangweijie&amp;password=123456，那么最后返回的是yangweijie123456，如果参数不带值且添加属性required=true，则会报错，此时就建议添加一个defaultValue属性： 12345678910@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username",required = false,defaultValue = "张少林") String username, @RequestParam(value = "password",required = false,defaultValue = "123456") String password) &#123; return username + password; &#125;&#125; @GetMapping、@PostMapping、@DeleteMapping、@PutMapping等是RequestMapping的组合注解，根据method的不同。 @RequestHeader可以把Request请求header部分的值绑定到方法的参数上。 @CookieValue可以把Request header中关于cookie的值绑定到方法的参数上。 RequestBody该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; ModelAttribute(参考：Spring MVC @ModelAttribute详解)@ModelAttribute有三种用法： 可以标注在方法上； 可以标注在方法中的参数上； 还可以和@RequestMapping一起标注在方法上；目的都是在RequestMapping之前进行model属性的注入，对RestController好像没用，因为是返回json数据，并不能将model里面的数据直接返回给页面。如果没用@RestController，则@ModelAttribute方法通常被用来填充一些公共需要的属性或数据，比如一个下拉列表所预设的几种状态，或者宠物的几种类型，或者去取得一个HTML表单渲染所需要的命令对象，比如Account等。@ModelAttribute标注方法有两种风格： 12345678910111213141516// Add one attribute// The return value of the method is added to the model under the name "account"// You can customize the name via @ModelAttribute("myAccount")@ModelAttributepublic Account addAccount(@RequestParam String number) &#123; return accountManager.findAccount(number);&#125;// Add multiple attributes@ModelAttributepublic void populateModel(@RequestParam String number, Model model) &#123; model.addAttribute(accountManager.findAccount(number)); // add more ... &#125; 在第一种写法中，方法通过返回值的方式默认地将添加一个属性，在第二种写法中，方法接收一个Model对象，然后可以向其中添加任意数量的属性，可以在根据需要，在两种风格中选择合适的一种。model里的数据会被放入到request中,页面通过request域可以获取到。 @SessionAttributes和@SessionAttribute@SessionAttributes注解的使用就是将属性放入session域内，然后可以在session域内进行相关的操作。 SpringMVC中@ModelAttribute和@SessionAttributes注解的使用 @id（好像如果表中数据字段是id，会比较特殊一点，springboot会自动检索传过来的参数是否有id，如果没有会自动添加id） Repository相关注解 Springboot的分页和排序操作由于采用的是Mongo数据库，所以先后使用了MongoTemplate()和MongoRepository(),MongoTemplate在写法上比MongoRepository 更复杂一些，但是带来更多的灵活性。对于复杂的查询操作，我们一般使用MongoTemplate，对于一些简单的查询我们会使用MongoRepository 。可以这么理解，MongoRepository 只是作为一种对于简单查询的简便操作，而MongoTemplate才是我们在做一些复杂查询时的首选。 MongoRepository自己还借用了下@Query和@Modifying注解，方便自己摆脱关键字的查询，如果需要进行更新或者删除数据，则需要在@Query之上加上@Modifing。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度前端技术学院66天学习(争取一个月内完成！)]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A266%E5%A4%A9%E5%AD%A6%E4%B9%A0-%E4%BA%89%E5%8F%96%E4%B8%80%E4%B8%AA%E6%9C%88%E5%86%85%E5%AE%8C%E6%88%90%EF%BC%81.html</url>
    <content type="text"><![CDATA[day 1:日期，今天的学习总用时，今天学习的目标是什么，是否达成 今天是2019.9.20，距离春招还有将近6个月的时间，预计1个半月将ife学完并且将js看完，后期开始刷leetcode和vue框架的学习 今天的学习时长总用时为30min 今天的学习目标是搭建好前端环境，做好长期准备学习的过程 目标已达成，将以博客的形式每天更新自己所学内容 哪些东西今天了解得比较透彻，说说自己的理解今天最大的收获是看到了许多非常极具创意的web，也激励自己能够更好的学习前端知识，希望半年后的自己能有一个大大的成长吧！！！ 哪些东西今天了解到了一些，还有哪些点需要后续继续深入阅读今天的内容好像没有什么难的，项目也比较忙，最近在看js，大概看完了前面4章了，后续尽量加快一些进度 哪些东西今天学了之后还有很多疑问没有被解答，把问题记录下来，以待后续解决今天暂无 立Flag，写下大家参加今年前端学院的目标找到一份好实习，找到一份好工作，成为更好的自己 day 2：问题： 这里面的可枚举属性名不知道啥意思； 个人暂时理解：就是是否可遍历的意思 对这个Object.prototype不熟悉！！！ day 3：问题： 图中为什么用Object.defineProperty()就可以完成对writable:false的属性的修改，但是直接用obj.属性的形式就不行？图中所谓的原型链又是什么意思？ 图中的JSON.stringify方法没有接触]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>ife</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习]]></title>
    <url>%2F2019%2F09%2F21%2FJS%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[学习过程：promise—&gt;箭头函数—&gt;作用域—&gt;闭包 js基础入门篇基本语法变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。其中，函数名同样被视为变量名，所以一样会被提升到代码头部。 标识符 不能以数字开头，可以以 _ 和 $ 开头 JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 标签js允许语句前面可以带有标签，方便跳出块区域和多重循环，常与for循环、continue、break连用。 数据类型##null，布尔值 boolean如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN “”或’’（空字符串） 注意，{}和[]都是true。 数值 js中所有数都是小数，64位，其中符号位1位，表示指数的11位，剩余的52位表示精度，但是由于表示精度的最高位1.xxxx中的1被省略，所以可以表示53位精度； parseInt即将字符串转换为整数型，不管是不是字符串，都会先转换为字符串,再转为整数型，其中，parseInt可以传入两个参数，第二个参数可以是转换进制值； 字符串 想输出多行字符串，有一种利用多行注释的变通方法 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" Base64转码 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // "SGVsbG8gV29ybGQh"atob('SGVsbG8gV29ybGQh') // "Hello World!" * 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好" 对象 对象的引用两个变量同时指向同一个对象，其中任何一个变量添加属性，另一个变量都可以读写该属性，但是如果取消某个变量对于原对象的引用，并不会影响到另一个变量；注意:仅限于对象，如果两个变量同时指向同一个原始类型的值，那么变量此时都是值的拷贝而已； 如果行首是一个大括号，js引擎一律将其解释为代码块，如果想要表示为对象，则必须在大括号前加上一个圆括号，这种差异在eval语句（作用是对字符串求值）中体现的尤为明显； 12eval('&#123;foo: 123&#125;') // 123eval('(&#123;foo: 123&#125;)') // &#123;foo: 123&#125; 属性读取：一种使用点运算符，另外一种采用方括号运算符，注意若使用方括号运算符，键名必须放在引号里面，否则会被当做变量处理： 123456789var foo = 'bar';var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 查看一个对象本身所有属性，可以使用Object.keys方法 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// ['key1', 'key2'] 属性的遍历：for…in 循环: 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 with语句：作用是操作同一个对象的多个属性时，提供方便，但是不建议使用，因为在with语句里面没有改变作用域，导致绑定对象不明确，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 函数函数声明 function命令 123function print(s)&#123; console.log(s);&#125; 函数表达式(如果function后带函数名，函数名也只在函数体内部有效) 1var print = function()&#123;console.log(s)&#125;; Function构造函数 12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数ToString可以解析注释实现多行字符串： 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split('\n'); return arr.slice(1, arr.length - 1).join('\n');&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// " 这是一个// 多行注释" 函数作用域在ES6中，有三种作用域：全局作用域、块作用域、函数作用域。函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。所以说，如果函数A调用函数B,函数B不会引用函数A的内容。 参数传值 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递； 函数参数如果是复合类型的值（数组、对象、其他函数），传递方式是传址传递； 函数内部修改的如果是参数对象的某个属性，那么会影响到原始值，如果是替换掉整个参数，则不会影响到原始值： 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] arguments arguments对象包含了函数运行时的所有参数，但是它并不是一个数组，而是一个对象，所以它不能用数组中的slice和forEach方法； 在正常模式下，arguments对象可以在运行时修改，但是在严格模式下，修改arguments对象的值并不会改变真实参数的值； 如果要让arguments对象使用数组方法，真正的解决办法就是让arguments对象变为数组，常用的转换方法有两种，分别是slice方法和逐一填入新数组： 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 闭包闭包，简而言之就是函数中的函数，闭包最大的特点，就是它可以“记住”诞生的环境，用处有三个： 1. 可以读取函数内部的变量； 2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在; 3. 封装对象的私有属性和私有方法。 123456789101112131415161718192021222324252627282930313233function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7``` ```jsfunction Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 “立即调用的函数表达式”（Immediately-Invoked Function Expression）123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 eval 本质是在当前域中注入代码，可以接受一个字符串作为参数，并且将该字符串当做语句执行，如果识别不是字符串，则会原样返回。 同时，eval没有自己的作用域，会改变当前域原有变量的值，当然在严格模式下，eval内部自己声明的变量有自己的作用域，不会影响到外部作用域的值。 由于引擎无法分辨eval的别名调用，所以在eval使用别名时，一律都是全局作用域。 数组数组遍历 数组遍历可以考虑使用for循环、while循环、forEach循环，会返回键值（键名为整数），for…in…循环会同时遍历非整数键（返回的是键名）； 数组遍历空位时，需要格外注意，空位和undefined是不一样的，空位表示数组中没有这个元素，所以在for…in…和forEach循环中不会被遍历到，但是undefined代表数组有这个元素，是会遍历到的； 运算符算术运算符加法运算符 对象的相加如果运算子是对象，必须先转成原始类型的值，引擎会自动调用obj.valueof().toString(),所以我们可以重新valueOf()和toString()方法即可，其中有个特例，当运算子是一个Date对象的实例，那么会优先执行toString方法。 指数运算符** 为指数运算符，是右结合的，当然，三元条件运算符也是右结合的，当然还有赋值运算符（=）也是右结合的。 比较运算符 严格相等运算符JavaScript 提供两种相等运算符：== 和 === 。简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。tip: undefined和null与自身严格相等布尔运算符略二进制位运算符略 其他运算符，运算顺序void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined，主要用途是浏览器的书签工具，以及在超链接中插入代码防止网页跳转。 语法专题错误处理机制原生错误类型 SyntaxError ReferenceError RangeError TypeError URIError EvalError 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象 1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了 1new UserError('这是自定义的错误！'); 标准库Object四个用法： Object本身就是一个函数，可以将任意值转换为对象； 不仅可以当做工具函数使用，还可以当做构造函数使用，即前面可以加new命令； 1注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = &#123;&#125;是等价的。或者说，后者只是前者的一种简便写法。 Object的静态方法，例如Object.print,指部署在Object对象自身的方法； Object的实例方法，即定义在Object.prototype对象上的方法。 Object.prototype.valueof() Object.prototype.toString() Object.prototype.toLocaleString() Object.prototype.hasOwnProperty() Object.prototype.isPrototypeof() Object.prototype.propertyIsEnumerable() 属性描述对象js提供了一个内部数据结构，用来描述对象的属性，比如是否可写可读可遍历，这个内部数据结构就称之为“属性描述对象”。 tip:Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。而这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 123456789101112Object.keys([]) // []Object.getOwnPropertyNames([]) // [ 'length' ]Object.keys(Object.prototype) // []Object.getOwnPropertyNames(Object.prototype)// ['hasOwnProperty',// 'valueOf',// 'constructor',// 'toLocaleString',// 'isPrototypeOf',// 'propertyIsEnumerable',// 'toString'] 上面代码中，数组自身的length属性是不可遍历的，Object.keys不会返回该属性。第二个例子的Object.prototype也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。 Object.defineProperty(),Object.defineProperties()Object.defineProperty()方法接收三个参数，依次如下： Object：属性所在的对象 propertyName:字符串，表示属性名 attributesObject:属性描述对象 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 Object.defineProperties()接收两个参数，如下： 123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" Object.prototype.propertyIsEnumerable()返回一个布尔值，用来判断自身属性是否可以遍历。Object.keys是返回所有可以遍历的属性，不包括继承的属性，而Object.getOwnPropertyNames则是返回包括继承的属性在内的所有可以遍历的属性。 es6入门len和const命令lenlen没有变量提升必须先声明后才能使用，注意len变量只在块区域内有用，是块级作用域，而var不同，var具有全局作用域、函数作用域； 暂时性死区123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。非常隐蔽的“死区”： 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。但在ES6中，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined node js入门]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Microsoft Remote Desktop for mac 和 Spark邮箱]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BD%BF%E7%94%A8Microsoft-Remote-Desktop-for-mac-%E5%92%8C-Spark%E9%82%AE%E7%AE%B1.html</url>
    <content type="text"><![CDATA[前言由于近期需要远程控制windows服务器，所以需要选择一个远程操控的软件，由于mac端并没有嵌入相关的功能，只能选择Microsoft Remote Desktop，并且遗憾的是，在中国区的app store并没有允许其上线，所以要做的第一步就是申请一个美区账号。 步骤 chrome打开apple id注册 按步骤注册，国家填写美国，注册完成之后需要登录一下 登录的时候会要求填写地址，以下是可用的信息街道: 4114 Sepulveda Blvd，城市: Culver City，州: CA邮编: 90230电话: (626) 339-6***商家名称: Clippinger Chevrolet Oldsmobile注意电话号码后三位随便填写几个数字 登录App Store，然后下载即可使用 Spark写这个主要是想吐槽一下，看到网上b乎各种说spark可以接收推送，即使没有打开软件，我想说简直是放屁啊，导致我查了几个小时都没能成功，根本做不到好吗！！！不信？看官网怎么说的 ——–&gt;Spark帮助中心所以只能一直开着了…垃圾的一批！！！！！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近事宜]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%9C%80%E8%BF%91%E4%BA%8B%E5%AE%9C.html</url>
    <content type="text"><![CDATA[最近生病了…加上开学事情很多…停更了一个星期 接下来会慢慢跟上的加油🆙]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask + PyJWT 实现基于Json Web Token的用户认证授权]]></title>
    <url>%2F2019%2F08%2F23%2FFlask-PyJWT-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EJson-Web-Token%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83.html</url>
    <content type="text"><![CDATA[前言这注定又将是一篇长文，接触到的第一个关于python的框架flask，本文将从最开始的安装flask，到与mysql结合，最后到用pyjwt和flask-jwt和restful写一个带有token的接口。 技术栈简介Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI(PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标)工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术 SQLAlchemyFlask是一个微型框架，自身没有提供数据库管理，表单验证，cookie处理等功能，很多功能需要通过扩展才能实现，数据库管理就需要SQLAlchemy。SqlAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简而言之：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 The first demo123456789from flask import Flaskapp = Flask(__name__)@app.route("/")def index(): return "hello world"if __name__ == '__main__': app.run() 第一行 from…import…就是导入flask中的Flask模块，不同于直接import，from…import简单来说就是帮我从车里拿瓶水，而import则是把车拿过来，所以二者在使用的时候还是有些区别的，在导入某个.py文件时，使用from…import…可以直接在该文件夹下使用import后的函数名，而如果是import，如果要调用函数必须用类.模块。 第二行 这行代码里有一个参数name，这个参数用到告诉flask你的application的名字，官方有一句话： 12If you are using a single module,__name__ is always the correct value.If you however are using a package, it’s usually recommended to hardcode the name ofyour package there. 意思就是说，如果是单一的应用，用name就可以了，如果是一个应用程序包，就hardcode一个名字给这个参数。比如： 1app = Flask(“myApp”) 由于目前我们的应用都相对简单，所以统一使用name作为参数。 第三行 使用route()修饰器注明通过什么样的url可以访问我们的函数，同时在函数中返回要显示在浏览器中的信息。 最后 调用run()方法，运行flask web应用程序 12if __name__ == '__main__': app.run() 其中if __name__==&#39;__main__&#39;的意思是，如果此文件是直接运行的才会执行app.run()这个方法，如果是通过import在其它py文件中调用的话是不会执行的。 比如我们修改code.py中的hello_world方法，如下： 1234567@app.route('/index')def hello_world(): if __name__=='main': return 'Hello World!' else: return "hello my name is "+__name__ 即当name为main时还是执行原来的逻辑，返回hello world，如果不是则输出此时的名字。 然后我们新建一个sub.py文件然后导入code.py，并且执行hello_world方法: 1234567import codedef CallCodeFun(): result = code.hello_world() print(result)CallCodeFun()print(__name__) 此时的name是Code而不是main，而此时，在sub.py中加一句print(name)可以发现sub.py中的name变成了main 由此我们可以得出 name 如果是 main 那么代表他是一个入口文件，直接执行的。 tip:建文件时文件名最好不要叫code，因为python有模块名就叫code。 flask-sqlalchemy 数据库配置，上demo 12345678910111213141516171819202122from flask_sqlalchemy import SQLAlchemyfrom flask import Flaskimport configparser# 告诉flask app的名字app = Flask(__name__)//通过configparser获取读取配置文件的解释器my_config = configparser.ConfigParser()my_config.read('db.conf')# dialect+driver://username:password@host:port/database?charset=utf8# 配置 sqlalchemy 数据库驱动://数据库用户名:密码@主机地址:端口/数据库?编码# py3无法继续使用sqldb，所以采用pymysqlapp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://' + my_config.get('DB', 'DB_USER') + ':' + \ my_config.get('DB', 'DB_PASSWORD') + '@' + my_config.get('DB', 'DB_HOST') + '/' + \ my_config.get('DB', 'DB_DB') # 设为True 表示每次请求结束后都会自动提交数据库的变动，但像add delete insert等仍需要commit,建议不要设为trueapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Truemydb = SQLAlchemy()mydb.init_app(app)if __name__ == "__main__": app.run(debug=True) 为了使代码结构更清晰，这里使用另一种配置方式，即使用单独配置文件的文件来做全局Flask配置 管控所有的配置文件conf.py: 1234567DB_USER = 'root'DB_PASSWORD = 'jwyjwy9951206-=-'DB_HOST = 'localhost'DB_DB = 'flask_migrate_demo'DEBUG = True SQLALCHEMY_TRACK_MODIFICATIONS = FalseSQLALCHEMY_DATABASE_URI = 'mysql+pymysql://' + DB_USER + ':' + DB_PASSWORD + '@' + DB_HOST + '/' + DB_DB SQLAlchemy允许我们根据数据库的表结构来创建数据模型，反之亦可。 所以我们一般无须手动的登录到数据库中使用 SQL 语句来创建表, 我们只需把数据模型定义好了之后, 表结构也就有了 新建model.py，并定义一个用户表数据模型 12345678from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class User(db.Model):user_id = db.Column(db.Integer, primary_key=True)user_name = db.Column(db.String(60), nullable=False)user_password = db.Column(db.String(30), nullable=False)user_nickname = db.Column(db.String(50))user_email = db.Column(db.String(30), nullable=False) 新建db.py，利用Flask-Script和Flask-Migrate，搭建db和app之间的桥梁 1234567891011from flask import Flaskfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommandfrom model import dbapp = Flask(__name__)app.config.from_object('conf')migrate = Migrate(app, db)manager = Manager(app)manager.add_command('db', MigrateCommand)if __name__ == '__main__':manager.run() Flask-Script和Flask-Migrate使用 最后，在pycharm的控制台打下三行迁移代码，这样就能在数据库中看见跟model字段一样的表了 123python db.py db initpython db.py db migratepython db.py db upgrade 示例接口实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# 用到flask中的Flask框架，jsonify返回json数据，request将前端字段传入后端from flask import Flask, jsonify, request# 将model中的User，db对象传入from model import db, User# 告诉flask这个app要用它app = Flask(__name__)# 读取配置文件，主要是连接mysqlapp.config.from_object('conf')# 初始化db.init_app(app)# 开始路由@app.route('/')def index(): return '&lt;h1&gt;Hello Flask!&lt;/h1&gt;'# 增@app.route('/user', methods=['POST'])def addUser(): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') user = User(user_name=user_name, user_password=user_password, user_nickname=user_nickname, user_email=user_email) try: db.session.add(user) db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id if (user.user_id is None): result = &#123;'msg': '添加失败'&#125; return jsonify(data=result) data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查@app.route('/user/&lt;int:userId&gt;', methods=['GET'])def getUser(userId): user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到数据'&#125; else: result = &#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125; return jsonify(data=result)# 改@app.route('/user/&lt;int:userId&gt;', methods=['PATCH'])def updateUser(userId): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') try: user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到要修改的记录'&#125; return jsonify(data=result) else: user.user_name = user_name user.user_password = user_password user.user_nickname = user_nickname user.user_email = user_email db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_password': data.user_password, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查全部@app.route('/user', methods=['GET'])def getUsers(): data = User.query.all() data_all = [] for user in data: data_all.append(&#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125;) return jsonify(users=data_all)# 删@app.route('/user/&lt;int:userId&gt;', methods=['DELETE'])def deleteUser(userId): # 删除数据 User.query.filter_by(user_id=userId).delete() db.session.commit() return getUsers()if __name__ == '__main__': app.run(debug=app.config['DEBUG']) SQLAlchemy 几种查询方式总结 使用Flask-RESTful快速创建RESTful API接口先容我把项目做完…待续…….无聊看看文档：flask-restful中文官方文档 使用Flask + PyJWT 实现基于Json Web Token的用户认证授权待更…无聊看看文档：Flask + PyJWT 实现基于Json Web Token的用户认证授权 问题1.主要问题就是flask和mysql的连接问题，出现的最棘手的问题首先是mysqldb是py2的，py3没有，用pymysql代替，在SQLALCHEMY_DATABASE_URI注意修改driver驱动。2.最终修改方案是自己用一个demo建好了数据库和表(记得保存好demo)，demo如下，然后再运行就可以了。 12345678910111213141516from sqlalchemy import create_engine,Table,Column,Integer,String,MetaData,ForeignKeyengine=create_engine("mysql+pymysql://root:a5230411@localhost:3306/test",echo=True)metadata=MetaData(engine)user=Table('user',metadata, Column('id',Integer,primary_key=True), Column('name',String(20)), Column('fullname',String(40)), )address_table = Table('address', metadata, Column('id', Integer, primary_key=True), Column('user_id', None, ForeignKey('user.id')), Column('email', String(128), nullable=False) )metadata.create_all() 3.解决 sqlalchemy 报错:(1193, “Unknown system variable ‘tx_isolation’”): 传送门 参考网址 Flask + PyJWT 实现基于Json Web Token的用户认证授权 使用 Flask 设计 RESTful 的认证 使用Flask-RESTful快速创建RESTful API接口 Flask + flask-jwt 实现基于Json Web Token的用户认证授权 Flask程序目录结构——构建可扩展的Flask应用程序 Python的flask：models.py来创建mysql数据库 python使用sqlalchemy连接mysql数据库 深入浅出Flask(学习教程) 深入浅出理解Python装饰器 flask-restful中文官方文档]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>PyJWT</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术]]></title>
    <url>%2F2019%2F08%2F20%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html</url>
    <content type="text"><![CDATA[第一章Java的11个关键术语 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java applet在网页中运行的Java程序称为applet 第二章部分术语 JDK(java development kit):java开发工具包 JRE(Java Runtime Environment):运行java程序用户所使用的软件 SDK(Software Development Kit):软件开发包 安装过程MAC中JAVA环境变量配置以及Intellij IDEA如何配置JDKIDEA的校园邮箱激活方式IntelliJ IDEA 常用快捷键 之 Mac 版Intellij IDEA快捷生成常用代码 琐碎知识点 0x1.0p-3:0x表示16进制，使用p表示指数，所以就是1.0*2的-3次方 三个特殊的浮点数值：正无穷大(Double.POSITIVE_INFINITY)、负无穷大(Double.NEGATIVE_INFINITY)、NaN(Double.NaN) 浮点数值不适用于无法接受舍入误差的计算中，要想完全没有误差，需要使用BigDecimal类 部分特殊字符的转义序列：\b 退格 \t 制表 \n 换行 \r 回车 \“双引号 \反斜杠 强烈建议不要在程序中使用char类型，因为unicode早已经超过了65536个 第三章部分术语 类常量：static final,类常量的定义在main方法的外部 整数被0除将会产生异常，浮点数被0除将会得到无穷大或NaN结果 public static strictfp void main(String[] args)，在该main函数中所有指令都将使用严格的浮点计算 condition ? expression1 : expression2 eg: x&lt;y ? x : y 位运算符：&amp;、|、^、~拓展：奇数个数，两个两个成对最有一个单独，如何找出这个单独的数字是几，复杂度在O(n)以内：用异或的思想即可，全部异或 移位运算符: &lt;&lt;(算数移位)&gt;&gt; &gt;&gt;&gt;(逻辑右移),其中&gt;&gt;&gt;会用0填充高位，移位运算符的右操作数要满足模32的运算(如果左边操作数是long则要满足模64)，1&lt;&lt;35 == 1&lt;&lt;3 == 8 枚举类型：enum Size{SMALL,MEDIUM,LARGE } 字符串 子串: 12String greeting = "Hello";String s = greeting.substring(0,3); 拼接:直接用+连接、如果需要多个字符串放在一起，并且用一个定界符分割，可以采用静态join方法： 12String all = String.join("/","S","M","L","XL")// string: "S/M/L/XL" java中不允许修改字符，但是可以修改字符串变量*字符串比较用equals方法，例如：”Hello”.equals(greeting),”Hello”.equalsIgnoreCase(“hello”)「无视大小写的比较」 java.lang.string部分apiString类常用方法之charAt()、codePointAt()示例offsetByCodePoints()与codePointAt() 注意lastIndexOf(int cp,int fromindex)，是返回从index位置开始找到的第一个符合的字符串的位置 12345678910111213141516public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125; &#125; input Scanner在util包中，当使用的类不在java.lang中时，都需要导包 1234567Scanner sc = new Scanner(System.in); String nextLine = sc.nextLine(); System.out.println("please input your name:" + nextLine); int nextInt = sc.nextInt(); System.out.println("please input your age:" + nextInt);String next = sc.next();System.out.println("please input your name:" + next);]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活好难啊]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%94%9F%E6%B4%BB%E5%A5%BD%E9%9A%BE%E5%95%8A.html</url>
    <content type="text"><![CDATA[今天被打击了…卧槽这个大数据怎么这么枯燥…再次怀疑不适合学计算机…把我看睡着了可还行（吐血…算了还是接着干吧）]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>负情绪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka]]></title>
    <url>%2F2019%2F08%2F18%2Fkafka.html</url>
    <content type="text"><![CDATA[初识kafkakafka概念Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据,是用于构建实时数据管道和流应用程序。 四个术语 TopicKafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic)。 Producer发布消息的对象称之为主题生产者(Kafka topic producer)。生产者发布消息时要选定Topic上的分区。 Consumer订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)。一般消费者模型可以分为两类：队列和发布-订阅式。队列的处理方式就是一条消息只有一个消费者知道并处理，发布-订阅的处理方式则是消息被所有人都知道，所有人都可以来处理该消息，kafka为这两种模型提供了单一抽象模型：消费者组（cosumer group）。每个消费者都有一个组名，当所有人的组名都不一样的时候，这个时候就是发布-订阅模式，因为消息要按照消费者组为单位发出的，这意味着此时每个消费者都会收到消息并可以进行处理；当所有人的消费者组名字都一样时，意味着只会有一个消费者收到消息并可以进行处理，此时就是队列模式了。 Broker已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。 三个关键能力 发布和订阅消息流，在这方面，它类似于一个消息队列或企业消息系统 以容错的方式存储消息（流) 在消息流发生时处理他们 四个核心API 应用程序使用 Producer API 发布消息到1个或多个topic（主题）。 应用程序使用 Consumer API 来订阅一个或多个topic，并处理产生的消息 应用程序使用 Streams API 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。 Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。 kafka安装过程 kafka的安装 1brew install kafka 安装会依赖zookeeper 注意：安装目录：/usr/local/Cellar/kafka/0.10.2.0 安装的配置文件位置/usr/local/etc/kafka/server.properties/usr/local/etc/kafka/zookeeper.properties 启动zookeeper 1zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp; 启动kafka 1kafka-server-start /usr/local/etc/kafka/server.properties &amp; 创建topic让我们使用单个分区和只有一个副本创建一个名为“test”的主题 1kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 查看创建的topic我们现在可以看到该主题，如果我们运行list topic命令： 1kafka-topics --list --zookeeper localhost:2181 发送消息Kafka提供了一个命令行客户端，它将从文件或标准输入接收输入，并将其作为消息发送到Kafka集群。默认情况下，每行都将作为单独的消息发送。运行生产者，然后在控制台中键入一些消息发送到服务器。 1kafka-console-producer --broker-list localhost:9092 --topic test 消费消息Kafka还有一个命令行消费者，将消息转储到标准输出。 1kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning TipQ:安装kafka出现错误： 1234kafka: Java 1.8 is required to install this formula.Install AdoptOpenJDK 8 with Homebrew Cask: brew cask install homebrew/cask-versions/adoptopenjdk8Error: An unsatisfied requirement failed this build. A: 1brew cask install homebrew/cask-versions/adoptopenjdk8 bilibili学习kafkahttps://www.bilibili.com/video/av36607048?p=2 zookeeper 默认是前台启动(关闭了控制台停止)，可以在最前面加上 nohup，这样就可以后台启动了。 三个目录 bin目录1cd usr/local/Cellar/kafka/2.2.1/bin * config文件 1/usr/local/etc/kafka/server.properties * 日志 1234############################# Log Basics ############################## A comma separated list of directories under which to store log fileslog.dirs=/usr/local/var/lib/kafka-logs 删除topic1kafka-topics --delete --zookeeper localhost:2181 --topic test]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实践winrm，实现远程连接调度Windows服务器]]></title>
    <url>%2F2019%2F08%2F17%2Fpython%E5%AE%9E%E8%B7%B5winrm%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%83%E5%BA%A6Windows%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[前言最近有个需求：用自己主机控制多个windows节点，实时获取他们的cpu和运存占用情况，通过查询，决定采用python中的winrm。Tip:winrm服务是windows 一种方便远程管理的服务；开启winrm service,便于在日常工作中，远程管理服务器，或通过脚本，同时管理多台服务器，来提高工作效率。 常规做法配置远程主机,使其支持被远程控制 查看winrm service listener（分为http和https）:1winrm e winrm/config/listener 如果没有返回，则没有开启winrm服务。 开启winrm服务： 1winrm quickconfig 为winrm service 配置auth: 1winrm set winrm/config/service/auth @&#123;Basic="true"&#125; 为winrm service 配置加密方式为允许非加密： 1winrm set winrm/config/service @&#123;AllowUnencrypted="true"&#125; 查看winrm服务的配置： 1winrm get winrm/config 客户端主机 装winrm 1pip install pywinrm 测试 1234import winrmwintest = winrm.Session('http://47.98.149.160:5985/wsman',auth=('Administrator','Jwy12345a'))ret = wintest.run_cmd('ipconfig')print(ret) 遇到的问题及解决措施 在测试环节，导入winrm包后，控制台显示：winrm has no attribute session 解决办法：pip导错了包，应该是pywinrm这个包，将pip原来的包删除，重新导入一遍。 pycharm问题：module ‘pip’ has no attribute ‘main’ 解决办法：pip升级导致无法导包 测试的时候，报出以下错误： 1requests.exceptions.ConnectTimeout: HTTPConnectionPool(host='47.98.149.160', port=5985): Max retries exceeded with url: /wsman (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x104921650&gt;, 'Connection to 47.98.149.160 timed out. (connect timeout=30)')) 解决办法：由于云服务器有公网ip地址，所以本机可以ping通服务器，但是由于本机不存在公网地址，是局域网地址，所以服务器不能ping通主机，导致二者不能正常通信，只能换一种方法，也就是在云服务器端运行程序，程序提供了当前cpu运行情况和运存情况，本机可以随时访问并得到信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import timeimport psutil # cd C:\Python36-32\Scripts pip install psutil# 获取本机磁盘使用率和剩余空间G信息import pymysqlconn = pymysql.connect(user="root", passwd="No.93329332", host="134.175.5.88", port=3306, db="node_status")cur = conn.cursor()flag = 0while(True): # 循环磁盘分区 content = "" for disk in psutil.disk_partitions(): # 读写方式 光盘 or 有效磁盘类型 if 'cdrom' in disk.opts or disk.fstype == '': continue disk_name_arr = disk.device.split(':') disk_name = disk_name_arr[0] disk_info = psutil.disk_usage(disk.device) # 磁盘剩余空间，单位G free_disk_size = disk_info.free // 1024 // 1024 // 1024 # 当前磁盘使用率和剩余空间G信息 if (disk_name == 'C'): disk_c_name = disk_name disk_c_info = disk_info free_c_disk_size = free_disk_size info = "%s盘使用率：%s%%， 剩余空间：%iG" % (disk_c_name, str(disk_c_info.percent), free_c_disk_size) # print(info) # print(disk_name) if (disk_name == 'C'): # 拼接多个磁盘的信息 content = content + info print(content) # return content # cpu信息 cpu_percent = psutil.cpu_percent(interval=1) cpu_info = "CPU使用率：%i%%" % cpu_percent print(cpu_info) # return cpu_info # 内存信息 virtual_memory = psutil.virtual_memory() used_memory = virtual_memory.used / 1024 / 1024 / 1024 free_memory = virtual_memory.free / 1024 / 1024 / 1024 memory_percent = virtual_memory.percent memory_info = "内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG" % (used_memory, memory_percent, free_memory) print(memory_info) # return memory_info now = time.asctime() if(flag == 0): sql = "INSERT INTO status(ip, \ disk_percent, disk_freesize, CPU_percent, memory_used,memory_free,memory_percent,mytime) \ VALUES ('%s', '%s', '%s', '%s', '%s','%s','%s','%s')" % \ ('106.13.70.159', str(disk_c_info.percent) + "%", str(free_c_disk_size) + "G", str(cpu_percent) + "%",str(used_memory)[:3] + "G",str(free_memory)[:3] + "G",str(memory_percent) + "%",now) flag = 1 else: used_memory_float = str(used_memory)[:3] + 'G' free_memory_folat = str(free_memory)[:3] + 'G' disk_c_info_percent_str = str(disk_c_info.percent) + '%' free_c_disk_size_str = str(free_c_disk_size) + 'G' cpu_percent_str = str(cpu_percent) + '%' memory_percent_str = str(memory_percent) + '%' sql = "update status set disk_percent = '%s', disk_freesize = '%s', \ CPU_percent = '%s', memory_used = '%s' , memory_free = '%s' ,\ memory_percent = '%s' , mytime = '%s' where ip = '106.13.70.159'" % \ (disk_c_info_percent_str,free_c_disk_size_str,cpu_percent_str,used_memory_float,free_memory_folat,memory_percent_str,now) flag = 2 try: # 执行sql语句 cur.execute(sql) # 执行sql语句 conn.commit() if(flag==1): print("insert ok") else: print("update ok") except Exception as e: # 发生错误时回滚 conn.rollback() print("failed") print(e) time.sleep(60)# 关闭数据库连接conn.close() sql中update也可以 1sql = "update table set ss = '%s'where id = '1'"% disk]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>winrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo的NexT主题---从入门到入土]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%9F%BA%E4%BA%8EHexo%E7%9A%84NexT%E4%B8%BB%E9%A2%98-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.html</url>
    <content type="text"><![CDATA[前言本篇文章主要是针对nexT主题的优化说明，使用hexo其他主题的童靴请绕道~~整理一下大概优化：1.标题部分优化，颜色样式；2.设置博客文章连接为year/month/day/title.html格式3.Menu增加关于、标签、分类、互动、搜索菜单4.禁用关于、标签、分类菜单评论功能5.添加RSS6.设置背景图片7.Canvas_nest动态背景8.图片快速加载设置9.微信支付宝打赏功能10.点击出现桃心效果11.主页文章添加阴影效果12.设置代码高亮13.顶栏背景色14.底栏背景色15.修改文章内链接文本样式16.修改文章底部标签样式17.在文章末尾添加“文章结束”标记18.设置头像19.网站底部加上访问量20.网站底部字数统计21.网站底部添加网站运行时间22.网站底部添加动态桃心23.底部隐藏由Hexo强力驱动、主题–NexT.Mist24.设置网站的图标Favicon25.实现文章文字统计功能和阅读时长26.加来必力云跟帖功能27.去掉底部重复字数统计28.修改字体大小29.侧边栏社交小图标设置30.添加侧栏推荐阅读31.修改侧边栏背景图片32.添加侧边栏音乐33.修改侧边栏文字颜色34.在文章底部增加版权信息35.Hexo博客添加站内搜索36.修改选中字符的颜色37.添加aplay音乐播放38.添加博客左下角门神(看门🐶)39.增加了3D库three_waves，默认关闭40.增加了canvas页面丝带(话说这玩意真的很吃cpu，一开我的mac就铁板烧了)41.增加了首页pace加载进度42.增加图片懒加载lazyload43.增加了fancybox44.增加了fastclick解决延迟问题45.增加了gulp压缩网页css js样式46.截断首页文章内容47.代码复制功能 hexo目录结构主目录结构 _config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。 package.jsonhexo框架的参数和所依赖插件。 scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。 source这个目录很重要，新建的文章都是在保存在这个目录下的._posts，需要新建的博文都放在_posts目录下。_posts目录下是一个个 markdown 文件。你应该可以看到一个 hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。里面还有一个重要文件夹：images，是用来存放博文的图片的，这里建议使用七牛云图床来存储图片，因为可以更快的加载图片。同时强烈建议大家用一款hexo—client来进行可视化博客的书写，一站式服务，支持七牛云图床，接好传送门：hexoclient。 themes网站主题目录，我用的就是nexT主题。 node_moduleshexo依赖的组件都在其中。 主题目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 高度定制优化篇标题部分优化，颜色样式首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就去themes/nexT/source/css/_schemes/Mist/_header.styl下，添加以下代码：12345//可以加图片，也可以自己调色彩.header &#123; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; &#125; 设置背景图片默认禁用，可以在themes/nexT/source/css/_custom/custon.styl文件中启用12345678//设置背景图片body &#123; background:url(http://pw5u1sbg2.bkt.clouddn.com/145676.jpg); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; Canvas_nest动态背景背景的几何线条是采用的nest效果, 一个基于html5 canvas绘制的网页背景效果, 非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖jQuery，使用原生的javascript 非常小，只有1.66kb，如果开启gzip，可以更小 非常容易实现，配置简单，即使你不是web开发者，也能简单搞定说明 color：线条颜色，默认： ‘0,0,0’ ；三个数字分别为(R,G,B)，这里推荐一个颜色采集器：ColorSlurp，在AppStore中就可以搜到 opacity：线条透明度（0~1），默认: 0.5 count：线条的总数量， 默认：150 zIndex：背景的z-index属性，css属性用于控制所在层的位置，默认：-1不足内存占用过高做法直接找到主题配置文件，将canvas改为true即可。RSS在你的hexo站点目录下：1$ npm install hexo-generator-feed --save 打开站点目录下的_config.yml:12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 来必力评论系统等第三方插件登录 来必力 ，获取LiveRe UID，编辑主题配置文件，编辑livere_uid字段，将id填入即可，更多第三方集成插件可见：nexT官网，包括评论系统、数据统计与分析、内容分享服务、搜索服务等等。 打赏功能nexT集成了支付宝微信打赏功能，直接在主题配置文件搜索wechat或者alipay即可,然后跟上自己的微信和支付宝的收钱码图片地址即可。 点击出现桃心效果1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 新建 clicklove.js 文件并且将以上代码复制进去，然后保存。 将 clicklove.js文件放到路径 /themes/next/source/js/src 里面 然后打开 \themes\next\layout\_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 主页文章添加阴影效果打开 themes/next/source/css/_custom/custom.styl，向里面加代码:12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 代码高亮直接在主题配置文件搜索 highlight_theme：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 顶部底部背景色改变首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就themes/nexT/source/css/_schemes/Mist/_header.styl下，将颜色进行修改即可。底部颜色则在themes/nexT/source/css/_schemes/Mist/index.styl中进行修改：123456789101112131415161718// Footer// --------------------------------------------------.footer &#123; margin-top: 80px; padding: 10px 0; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; color: $grey-dim;&#125;.footer-inner &#123; margin: 0 auto; text-align: left; +mobile() &#123; width: auto; text-align: center; &#125;&#125; 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改网页底部 在图标库中找到你自己喜欢的图标, 修改桃心,打开 themes/next_config.yml ,搜索关键字 authoricon,替换图标名： 12# icon between year and author @Footerauthoricon: id-card 隐藏网页底部 Hexo 强力驱动 打开主题配置文件,搜索关键字 copyright ，如下: 12# Footer `powered-by` and `theme-info` copyrightcopyright: false 添加文章结束标记在themes/next/layout/_macro/post.swig中, 在wechat-subscriber.swig之前添加如下代码:123&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 统计功能，统计功能,显示文章字数统计,阅读时长,总字数在站点的根目录下：1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount：1234567891011# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: true separated_meta: true 设置头像打开 themes/next/_config.yml ，搜索关键字 avatar：123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: http://pw5u1sbg2.bkt.clouddn.com/avatar.png #/images/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 底部添加访问量和字数统计运用第三方插件，见nexT官网，推荐百度统计和不蒜子统计。 底部添加运行时间找到\themes\next\layout\_partials\下面的footer.swig文件，在末尾添加所示代码：12345678910111213141516171819&lt;div class="run_time" style=" text-align:center;"&gt; &lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("08/06/2019 19:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250); &lt;/script&gt;&lt;/div&gt; 底部添加红心打开 themes/next/_config.yml ，搜索关键字 footer：123456789101112131415footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # visitors count counter: true # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 添加侧边栏音乐框去往网易云音乐搜索喜欢的音乐，点击生成外链播放器， 复制代码直接放到博文末尾即可，height设为0可隐藏播放器，但仍然可以播放音乐，auto设成0可手动播放，默认是1自动播放，可把代码放到themes/next/layout/_custom/sidebar.swig文件里，播放器会显示在站点预览中,示例代码如下：12&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2588481240&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt; 添加aplayer音乐播放由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为guestbook： 1hexo new page guestbook 这时候在 /Hexo/source 文件夹下会生成一个guestbook文件夹，打开里面的index.md，示例如下： 123456789101112---title: 留言互动date: 2019-08-15 12:18:09type: "guestbook"---&lt;div align="center"&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558956326532&amp;di=82cc9907fc903cfb978a35206986d3f6&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160809%2F31283a3e2d7f411492d3fb27297180ec_th.jpg" /&gt;&lt;/div&gt;[//]: #(aplay音频播放https://github.com/MoePlayer/hexo-tag-aplayer)&#123;% meting "2331951308" "netease" "playlist" "autoplay" "mutex:false" "order:random" "listmaxheight:250px" "preload:none" "theme:#f7f7f7"%&#125; meting中配置参数含义如下： 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启固定模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 theme #ad7a86 播放器风格色彩设置 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto 打开主题_config.yml文件，在menu下新建一个名为guestbook的类，完成后如下所示： 1234567menu: home: / || home tags: /tags/ || tags categories: /categories/ || bookmark archives: /archives/ || archive about: /about/ || user 互动: /guestbook/ || comments 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 12menu: guestbook: 互动 至此，歌单页面创建完成，现在只需要在站点配置文件中开启meting模式，在_config.yml中搜索meting： 12aplayer: meting: true Tip同一个歌单不能做到实时刷新，需要24小时后aplayer才会自动更新缓存 添加博客左下角门神安装依赖:12npm install --save hexo-helper-live2dnpm install --save live2d-widget-model-wanko 站点配置添加:12345678910111213141516171819202122# hexo-helper-live2d配置, 参考https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: scale: 1 use: live2d-widget-model-wanko display: superSample: 2 # 超采样等级 width: 100 height: 100 position: left # 位置 mobile: show: false react: opacityDefault: 0.9 # 默认透明度 opacityOnHover: 0.5 # 鼠标移上透明度 增加首页pace加载进度打开主题配置文件：12345678# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-bounce 增加图片懒加载lazyload打开主题配置文件：123# Vanilla JavaScript plugin for lazyloading images.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: true 增加fancybox和fastclick解决延迟问题打开主题配置文件：123456789# Fancybox. There is support for old version 2 and new version 3.# Choose only one variant, do not need to install both.# To install 2.x: https://github.com/theme-next/theme-next-fancybox# To install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: true# Polyfill to remove click delays on browsers with touch UIs.# Dependencies: https://github.com/theme-next/theme-next-fastclickfastclick: true 截断首页文章内容打开主题配置文件，搜索auto_excerpt：12345# Automatically Excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 代码复制功能 复制该网页的代码，传送门：clipboard.min.js，然后在themes\next\source\js\src下新建clipboard.min.js文件，将以上内容复制进去即可； 在themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 123456789101112131415161718 /*页面载入完成后，创建复制按钮*/ !function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; //fa fa-globe可以去字体库替换自己想要的图标copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode(); &#125;(window, document); 在themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":1,"width":250,"height":300,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});）之前添加）： 123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 尝试了但未实现的功能1.用mob_share的app_key未能实现share的功能，经过其官方人员电话沟通，已经不再支持pc端博客服务2.aplay音乐播放歌单，不能做到实时更新歌单，究其原因是其api设置了24小时缓存，同一个歌单24小时内不会发生改变 非常有益的网址 NexT主题进阶 基于Hexo的个人博客搭建(进阶版) Hexo+Next主题优化]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题]]></title>
    <url>%2F2019%2F08%2F12%2F%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为列数。该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 My code1234567891011121314151617# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here row = len(array) col = len(array[0]) c = col - 1 r = 0 while(r &lt;= row-1 and c &gt;=0): if(target == array[r][c]): return True elif(target &gt; array[r][c]): r+=1 else: c-=1 return False 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路将字符串复制给一个新的列表，碰到空格则替换，没有则copy原字符串，最后对列表进行join，返回字符串。 易错点 My code12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here t = len(s) j = 0 m = list(s) for i in range(0,t): if(s[i] == ' '): m[j] = '%20' j+=1 else: m[j] = s[i] j+=1 pass return ''.join(m)# s = 'I want to sleep'# solution = Solution()# ss = solution.replaceSpace(s)# print(ss) 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路知识点补充python中链表的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(): '创建节点' def __init__(self,data): self.data = data self.next = None class LinkList(): '创建列表' def __init__(self, node): '初始化列表' self.head = node self.head.next = None self.tail = self.head def add_node(self, node): '添加节点' self.tail.next = node self.tail = self.tail.next def view(self): '查看列表' node = self.head link_str = '' while node is not None: if node.next is not None: link_str += str(node.data) + '--&gt;' else: link_str += str(node.data) node = node.next print ('The Linklist is:' + link_str) def length(self): '列表长度' node = self.head count = 1 while node.next is not None: count += 1 node = node.next print ('The length of linklist are %d' % count) return count def delete_node(self, index): '删除节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index-1: break node = node.next num += 1 tmp_node = node.next node.next = node.next.next return tmp_node.data def find_node(self, index): '查看具体节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index: break node = node.next num += 1 return node.data My code123456789101112131415# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here res=[] while listNode: res.append(listNode.val) listNode=listNode.next return res[::-1] #逆序打印]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>剑指</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在macOS上使用GitHub Pages+Hexo搭建个人博客]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[搭建环境操作系统：macos 10.14.5工具：github Desktop, Node.js, Git框架：Hexo, Github Pages 具体步骤安装git直接在终端输入git --version判断自己系统是否已有git，如果没有，点击该链接git下载，安装完后进入终端输入git --version检查是否安装成功。 安装node.js话不多说，上链接：node.js下载，然后傻瓜式安装就行。安装完之后请记得去控制台看看是否安装成功node --version,然后更新一下npm,输入:npm install -g npm 注册账号并创建博客仓库a.首先进入github官网：github,进行相应的注册登录，然后创建仓库，就在左上角那个猫猫旁边。b.戳进去之后,Respository name必须是:您的github账户名.github.io,然后勾选下面的创建readme，创建完成。c.进入仓库，点击Setting，启用GitHub Pages,此时你输入您的github账户名.github.io,就能看到不是404了，说明此时博客已经建立了，接下来就是利用Hexo框架让你的博客美起来啦！！！！ 安装配置Hexoa.首先建立一个文件夹(随便你建在哪)b.在该文件夹内打开终端，输入：1$ npm install hexo-cli -g 接下来你就能看到文件夹内的东西多了起来哈哈哈，如下图所示的文件结构：c.Hexo已经有了，github pages也有了，现在就剩把他们联系起来了，所以这步就是关键咯，打开上图第一个文件：_config.yml,然后在文本的结尾加上下面的一段代码：1234deploy: type: git repository: https://github.com/jeromememory/jeromememory.github.io.git branch: master 其中repository就是你最开始设置的仓库哟，记得替换自己的github用户名。 检测是否部署成功首先如果你想在本地预览你的博客，只需要打开终端,首先进入Hexo文件夹内，然后进行 hexo s即可：12$ cd /Users/jerome/Hexo $ hexo s 然后你就会看到在终端提示你在localhost:4000预览你的博客啦！！如果你想在网页上看到你的博客，只需要在终端输入：12$ hexo g$ hexo d 稍等一小会(github pages需要一小段时间才会更新)，你就能在你仓库对应的那个网址(您的github用户名.io.git)看到您的博客了，至此，您的博客应该就已经搭建完成了，当然您肯定会说这也太丑了吧，对，我也觉得，所以接下来请继续看下面的操作吧！！！ Hexo主题配置默认的主题很丑，所以这个时候我们就可以去github这个最大的开源网站找了，我推荐Hexo的next主题，我自己用的就是这个，极简至极，找到别人的主题之后，把他的代码clone下来，放到/Hexo/themes这个文件夹下：然后去开始的_config.yml中定位到theme，将后面的值改为你的主题名，别忘了，改完这些后，打开终端，输入：12$ hexo g$ hexo d 过一小会你就能看到自己的主题发生变化啦！剩下的具体配置，我就偷偷懒放个链接：NexT主题，其他主题的同学，你们也可以自己查一下对应的官网哟，都写的贼详细，好用！ 总结至此，个人博客就应该搭建好了，希望对大家有所收获！!(话说第一篇博客果然是狗屁不通啊大家凑合看吧)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
</search>
