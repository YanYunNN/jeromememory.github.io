<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[多线程相关内容]]></title>
    <url>%2F2020%2F01%2F29%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9.html</url>
    <content type="text"><![CDATA[由于今天刚结束集合有关的源码分析… 下一个阶段就是 多线程 &amp; JVM 啦！ 加油！]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法题总结]]></title>
    <url>%2F2020%2F01%2F26%2F%E9%83%A8%E5%88%86%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[数组都是arr.length，字符串是str.length()，列表是list.size() 字符串 ——&gt; 数组，可以有 str.toCharArray()，然后数组 —–&gt; 字符串 是 new String(arr)，注意如果想要直接打印数组内容则是 Arrays.toString(arr)，打印多维数组是 Arrays.deeptoString() String 不能直接变化，但是可以用StringBuilder 123StringBuilder sb = new StringBuilder(str);sb.replace(1,2,"aa");return sb.toString(); 不管是数组转换成集合，还是集合转换成数组，都要注意转换类型的一致性，String[]数组转String类型的集合，当需要使用int，double等集合的时候，需要使用对应的对象 如：数组int[]用Integer[]，double[]用Double[] ,因为List集合是对象的集合，而int、double等不是对象，所以需要用字段的对应对象类 数组直接转成列表 1234// 注意这里必须是 Integer对象的数组，否则转不了Integer[] nums = &#123;1,2,3&#125;;ArrayList arr= new ArrayList&lt;&gt;(nums.length);Collections.addAll(arr,nums); 12// 好像也可以，但是跟上面一样，得是 String、Integer类型的数组Arrays.asList(arr); 如果是int，需要装箱再转才可以 123int[] a = &#123;1,2,3,4&#125;;List arr = Arrays.stream(a).boxed().collect(Collectors.toList());System.out.println(arr); 列表转数组 采用集合的toArray()方法直接把List集合转换成数组，这里需要注意，不能这样写： 1String[] array = (String[]) mlist.toArray(); 这样写的话，编译运行时会报类型无法转换java.lang.ClassCastException的错误，这是为何呢，这样写看起来没有问题啊 因为java中的强制类型转换是针对单个对象才有效果的，而List是多对象的集合，所以将整个List强制转换是不行的 。正确的写法应该是这样的： 1String[] array = mlist.toArray(new String[0]); 12345List&lt;int[]&gt; res = new ArrayList();res.add(new int[]&#123;1,2&#125;);res.add(new int[]&#123;3,4&#125;);System.out.println(res);int[][] a = res.toArray(new int[0][]); 123456List&lt;Integer&gt; res = new ArrayList();res.add(1);res.add(2);System.out.println(res);Integer[] a = res.toArray(new Integer[0]);System.out.println(Arrays.toString(a)); 哈希表中统计数出现的次数 123456789class Solution &#123; public void majorityElement(int[] nums) &#123; Map&lt;Integer, Integer&gt; numCount = new HashMap&lt;&gt;(); for (int num : nums) &#123; int count = numCount.getOrDefault(num, 0) + 1; numCount.put(num, count); &#125; &#125;&#125; 对哈希map中的 value 值升序排列 123456789List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;Integer, Integer&gt;&gt;(hashMap.entrySet());Collections.sort(list, (o1, o2) -&gt; &#123; int compare = (o1.getValue()).compareTo(o2.getValue()); return compare;&#125;);Map&lt;Integer, Integer&gt; returnMap = new LinkedHashMap&lt;Integer, Integer&gt;();for (Map.Entry&lt;Integer, Integer&gt; entry : list) &#123; returnMap.put(entry.getKey(), entry.getValue());&#125; 数字转字符，字符转数字 12345678910// 数字转字符 方式一String str = "1230";int d = Integer.parseInt(str); //静态函数直接通过类名调用// 数字转字符 方式二int d3 = Integer.valueOf("1230");System.out.println("digit3: " + d3);// 字符转数字String s = String.valueOf(d);]]></content>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2020%2F01%2F16%2F%E7%BA%A2%E9%BB%91%E6%A0%91.html</url>
    <content type="text"><![CDATA[红黑树特点 每个节点或者是红色的，或者是黑色的； 根节点是黑色的； 每个叶子结点（最后的空节点）是黑色的； 如果一个节点是红色的，那么他的孩子都是黑色的 ；[红色不能连着] 从任意一个节点到叶子节点经过的黑色节点是一样的。 增加操作 图中 C 为当前需要插入的节点，P 为当前插入节点的双亲结点，U 为当前插入节点的叔叔节点，G 为当前插入节点的祖父节点！增加节点就是这四种情况了，我们只需要考虑三代节点，还是非常简单的… 这里推荐一个网站，可以试验一下红黑树的增加删除，感觉贼爽啊！！！ (其实是我不想画图找例子了…自己去试验吧..这四种情况的方法屡试不爽) cs.usfca.edu/~galles/visualization/RedBlack.html 话说，咱中文的博客真的好多人都不太懂这个红黑树，各种错误的例子就往上贴，其实本来是很简单的知识点，把我硬是整迷糊了…真是误人子弟啊…好气啊！ 删除操作删除是红黑树中最难的部分！但是其实跟拧魔方是一样哒！只要掌握了技巧，管你是什么，套公式就完事儿了！ [维基百科写的啥玩意儿，我的智商受到了压制…] 想要删除一个节点，首先就要考虑它有几个孩子： 若想要删除的节点，我这里记为 N，若 N 有两个孩子，则我们可以找 N 的左子树最大值 或者是 N 的右子树最小值，将其值复制到 N ,然后 不删除 N 这个节点，转而去删除被复制的那个节点(N 的左子树最大值 或者是 N 的右子树最小值所在的节点)，为什么要这样转换呢？因为我们知道，N 的左子树最大值 或者是 N 的右子树最小值最多也就一个儿子(我这里说的儿子是不包括叶子结点[叶子结点全部是黑色空节点哦，这是红黑树的性质3]的哈~) 所以我们现在只需要考虑删除 只有一个儿子或者没有儿子的节点 看上图，其实也就剩下3种情况，分别是 需删除节点为黑色，有一个颜色为红色的孩子 需删除节点为红色，且没有儿子 需删除节点为黑色，且没有儿子 前面两种情况是很好处理的，最难的就是第三种情况，需删除节点为黑色，且没有儿子，接下来我们就只需要考虑这种情况！！！ 这种情况下，只需要考虑四个节点，分别是 父亲节点 P、兄弟节点 S、S 的左孩子 S1、S 的右孩子 S2，按理说4个节点，颜色排列组合，可以排成16种，但是有些是不符合红黑树性质的组合，现在我们来一一排列一下。 粗略看一下，总共是有9种情况的！在文末会给出我自己总结的这9种分别对应的操作方式，大家可以直接看文末！！！ 一道例题 要删除的节点是黑色节点，且儿子为叶子结点 如题，要删除的节点是40，其父亲是55，黑色节点，记为P；其兄弟是65，红色节点，记为S，其侄子是60，75，黑色节点。 如图，这是删除了40之后的图，其儿子—-叶子结点变为x，现在不满足性质5，需要进行变换。 Case I：S 为 红色，P 为黑色 将 S 和 P 的颜色互换，即 S 变为黑色，P 变为红色 对父亲节点 P 进行 左旋，注意哦，因为是左旋，所以圆心是 兄弟节点 S Case II：此时又是一个新的可能出现的场景，删除节点后，P 为红色节点，而兄弟节点 S 为黑色节点，但是兄弟的左孩子为 红色，右孩子(叶子结点，当然其也只能是叶子节点，否则就违反性质5了)为黑色。 此时，将 S 变为 红色，S 的左孩子变为 黑色 然后，违法了性质 4，将 S 右旋 Case III：此时第三种情况出现了，P 为红色， S 为黑色，S 的左孩子为黑色叶子结点，S 的右孩子为红色节点 将 S 的右孩子(红色)、P(红色)、S(黑色)，颜色互换 然后将 x 现在的父亲进行左旋 维基百科部分情形1: N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。 注意：在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。 情形2： S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。（注意：这里的图中没有显示出来，N是删除了黑色节点后替换上来的子节点，所以这个过程中由P-&gt;X-&gt;N变成了P-&gt;N，实际上是少了一个黑色节点，也可以理解为Parent(Black)和Silbing(Red)那么他们的孩子黑色节点的数目肯定不等，让他们做新兄弟肯定是不平衡的，还需后面继续处理。这里看英文版本的[1]比较的明了） 情形3： N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。 情形4： S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。 情形5： S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。 情形6： S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。此时，如果一个路径不通过N，则有两种可能性：它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。 自己总结的操作方式 总结至此，红黑树告一段落了…学了两天才真正搞明白每一步干嘛的…真是太麻烦了 建议学红黑树，先熟悉它的5个性质，然后将增加和删除的操作背一下就行…自己可以多上我推荐的那个网站，用我总结的操作方式多操作几遍，就应该没啥大问题了！至于手写红黑树代码…我选择放弃了！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Map]]></title>
    <url>%2F2020%2F01%2F15%2FMap%20%26%20Set%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[HashMap参考 集合番@HashMap一文通（1.7版） 集合番@HashMap一文通（1.8版） HashMap源码分析—掘金博主 美团技术讲解HashMap 相关面试问题 问题引导由于知识点太多，我就以自己搜集到的面试常问的有关于HashMap的问题进行解决，然后再进一步深挖！ HashMap的底层数据结构？ HashMap的主要方法？ HashMap 是如何确定元素存储位置的以及如何处理哈希冲突的？ HashMap 扩容机制是怎样的？ JDK 1.8 在扩容和解决哈希冲突上对 HashMap 源码做了哪些改动？有什么好处? 什么时候会使用HashMap？他有什么特点？ 你知道HashMap的工作原理吗？ 你知道get和put的原理吗？equals()和hashCode()都有什么作用？ 你知道hash的实现吗？为什么要这样实现？ 如果HashMap的大小超过了负载因子（load factor）定义的容量，怎么办？ 你了解重新调整HashMap大小存在什么问题吗？ 为什么使用String，Interger这样的wrapper类适合作为键？ 我们可以使用自定义的对象作为键吗？ 如何对HashMap进行排序？ HashMap的删除陷阱？ 为什么只允许通过iterator进行删除操作？ 如果是遍历过程中增加或修改数据呢？ hashmap为什么初始长度为16？ HashMap中的扰动函数是什么，有什么作用，TreeMap中有吗？ HashMap为何可以插入空值？为什么它是线程不安全的？ 这20个问题的参考想法会在文章末尾给出！先一起来学习一哈HashMap的源码！ 概述 HashMap的特性 HashMap的存储结构 HashMap的重要方法—增删改查 HashMap的扩容机制 HashMap的迭代器 HashMap的Fail-Fast机制 HashMap与大家庭中其他Map的区别 接下来从这些方面拿下HashMap！！！ HashMap的特性 它根据键的 hashCode值 存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。[只是说跟hashCode的值有关系哦！并不是直接按照hashCode()返回值存取的] HashMap最多只允许一条记录的键为null，允许多条记录的值为null。 HashMap 非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用ConcurrentHashMap。 键唯一，如果键相同，则值会被覆盖。同时若键为自定义的数据类型，则需要保证已经重写了equals() 和 hashCode()。 ——&gt; equals() 和 hashCode()详解 HashMap的存储结构JDK 1.7 版本的HashMap是以 数组 + 链表 存储的，也就是我们常说的按 链地址法 存储 常见的处理哈希冲突的方法就两种： 开放地址法 开放地址法又可以分为线性探测法、平方探测法、再散列法 拉链法 JDK 1.8 版本的HashMap是以 数组 + 链表 + 红黑树 实现的，红黑树 可能大家接触的不是很多，所以我赶紧学习了一波 传送门)，具体的实现如下图所示： 源码中的相关概念重要参数 哈希桶（buckets）：在 HashMap 的注释里使用哈希桶来形象的表示数组中每个地址位置。注意这里并不是数组本身，数组是装哈希桶的，他可以被称为哈希表。 初始容量(initial capacity) : 这个很容易理解，就是哈希表中哈希桶初始的数量。如果我们没有通过构造方法修改这个容量值默认为DEFAULT_INITIAL_CAPACITY = 1&lt;&lt;4 即16。值得注意的是为了保证 HashMap 添加和查找的高效性，HashMap 的容量总是 2^n 的形式，下文会讲为什么 HashMap 的容量总是 2^n次方。 加载因子(load factor)：加载因子是哈希表（散列表）在其容量自动增加之前被允许获得的最大数量的度量。当哈希表中的条目数量超过负载因子和当前容量的乘积时，散列表就会被重新映射（即重建内部数据结构），重新创建的散列表容量大约是之前散列表哈系统桶数量的两倍。默认加载因子（0.75）在时间和空间成本之间提供了良好的折衷。加载因子过大会导致很容易链表过长，加载因子很小又容易导致频繁的扩容。所以不要轻易试着去改变这个默认值。 扩容阈值（threshold）：其实在说加载因子的时候已经提到了扩容阈值了，扩容阈值 = 哈希表容量 * 加载因子。哈希表的键值对总数 = 所有哈希桶中所有链表节点数的加和，扩容阈值比较的是是键值对的个数而不是哈希表的数组中有多少个位置被占了。 树化阀值(TREEIFY_THRESHOLD) ：这个参数概念是在 JDK1.8后加入的，它的含义代表一个哈希桶中的节点个数大于该值（默认为8）的时候将会被转为红黑树行存储结构。 非树化阀值(UNTREEIFY_THRESHOLD)： 与树化阈值相对应，表示当一个已经转化为数形存储结构的哈希桶中节点数量小于该值（默认为 6）的时候将再次改为单链表的格式存储。导致这种操作的原因可能有删除节点或者扩容。 最小树化容量(MIN_TREEIFY_CAPACITY): 经过上边的介绍我们只知道，当链表的节点数超过8的时候就会转化为树化存储，其实对于转化还有一个要求就是哈希表的数量超过最小树化容量的要求（默认要求是 64）,且为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD);在达到该要求之前优先选择扩容。扩容因为因为容量的变化可能会使单链表的长度改变。 与这个几个概念对应的在 HashMap 中几个常亮量，由于上边的介绍比较详细了，下边仅列出几个变量的声明： 1234567891011121314151617/*默认初始容量*/static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/*最大存储容量*/static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/*默认加载因子*/static final float DEFAULT_LOAD_FACTOR = 0.75f;/*默认树化阈值*/static final int TREEIFY_THRESHOLD = 8;/*默认非树化阈值*/static final int UNTREEIFY_THRESHOLD = 6;/*默认最小树化容量*/static final int MIN_TREEIFY_CAPACITY = 64; 对应的还有几个全局变量： 1234567891011121314// 扩容阈值 = 容量 x 加载因子int threshold;//存储哈希桶的数组，哈希桶中装的是一个单链表或一颗红黑树，长度一定是 2^ntransient Node&lt;K,V&gt;[] table; // HashMap中存储的键值对的数量注意这里是键值对的个数而不是数组的长度transient int size; //所有键值对的Set集合 区分于 table 可以调用 entrySet(）得到该集合transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //操作数记录 为了多线程操作时 Fast-fail 机制transient int modCount; 作者：像一只狗链接：https://juejin.im/post/5ac83fa35188255c5668afd0来源：掘金 基本存储单元Node12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) * 1.8中将Entry改成Node（内部结构不变） * 虽然只是改了名字，但名字的变更体现出HashMap对于节点概念的重视 */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//哈希值,新增final属性，表明hash值也不可变了，更加严谨 final K key;//key V value;//value Node&lt;K,V&gt; next;//链表后置节点 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; //每一个节点的hash值，是将 key 的 hashCode 和 value 的 hashCode 异或得到的。 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; //设置新的value 同时返回旧value public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; TreeNode12345678910111213141516171819202122232425262728293031/** * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn extends Node) * so can be used as extension of either regular or linked node. * 红黑树节点 相比于TreeMap， * 1.增加pre来记录前一个节点 * 2.继承LinkedHashMap.Entry&lt;K,V&gt;，而LinkedHashMap.Entry&lt;K,V&gt;又继承HashMap.Node： * 1.拥有了Node和链表Node的所有功能 * 2.具有额外6个属性Entry&lt;K,V&gt; before, after;final int hash;final K key;V value;Node&lt;K,V&gt; next; */static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父节点 TreeNode&lt;K,V&gt; left;//左子节点 TreeNode&lt;K,V&gt; right;//右子节点 TreeNode&lt;K,V&gt; prev; // 前一个元素的节点 boolean red;//是否是红节点 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; ...&#125;/** * LinkedHashMap.Entry的实现 * HashMap.Node subclass for normal LinkedHashMap entries. * 可以发现，最终TreeNode还是继承了HashMap.Node的所有功能，底层实现还是Node */static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; 重要方法确定哈希桶数组索引位置不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 1234567891011//方法一：称为扰动函数static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算，高16位和低16位进行异或 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;//方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度。 Put方法(新增) ① 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ② 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③ 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④ 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤ 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥ 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * 新增键值对 * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none *///注意 不可以被继承重载 如果使用hashMap的方式的话final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i; //当数组为空时 if ((tab = table) == null || (n = tab.length) == 0) &#123; n = (tab = resize()).length;//当初始化或者当前数组长度为0时，需要重新resize并返回新的长度 &#125; //相当于通过 h &amp; (length-1) 计算下标并获取元素 if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123; //若当前下标位置空置（即该key不存在），就新建一个普通(non-tree)节点 tab[i] = newNode(hash, key, value, null); &#125;else &#123; //当该key存在或者发生hash冲突时 Node&lt;K,V&gt; e; K k; //若在数组中通过hash和equals比较能够直接找到该值，就覆盖旧值 //即当前桶即非链表也非红黑树 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; e = p;//覆盖 &#125; //否则需要先判断节点是否是红黑树节点 else if (p instanceof TreeNode)&#123;//若是红黑树类型，执行树节点putTreeVal操作 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); &#125; else &#123; //此时发生了冲突 for (int binCount = 0; ; ++binCount) &#123; //如果此时的桶还不是链表，需要转变为链表 或者 如果在链表中没有，那就新增一个节点 if ((e = p.next) == null) &#123; //注意链表插入时1.7与1.8是不同的 //1.7:是头插入法，后来的留在数组上，先来的链在尾上（遍历时是先进后出） //1.8:是尾插入法，先来的留在数组上，后来的链在尾上（遍历时是先进先出） p.next = newNode(hash, key, value, null); //如果桶的链表长度&gt;=桶的树化阈值，需要将链表转变为红黑树 //这里需要注意：是先新增元素之后再判断树化条件，而不是先树化再新增 if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); //当前桶树化 break; &#125; //如果在链表中已经存在该值，就覆盖旧值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //原则：用新值覆盖旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; //onlyIfAbsent 若是true，不允许覆盖 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e);//相当于1.7的afterNodeAccess，LinkedHashMap专用，用于有序控制 return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold)//超过阈值就扩容 resize(); afterNodeInsertion(evict);//LinkedHashMap专用，用于删除最旧元素 (remove eldest) return null;&#125;// Create a regular (non-tree) node 创建一个普通的非树节点Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next);&#125; resize方法(扩容)整体分为两部分：1. 寻找扩容后数组的大小以及新的扩容阈值，2. 将原有哈希表拷贝到新的哈希表中。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * Initializes or doubles table size. If null, allocates in accord with initial capacity * target held in field threshold. Otherwise, because we are using power-of-two expansion, * the elements from each bin must either stay at same index, or move with a power of two * offset in the new table. * 初始化Map或2倍扩容，且会均匀的把之前的冲突的节点分散到新的桶中 * 当Map为空时，将分配与阈值一样大小的容量 * 当Map不为空时，由于2次幂扩容，元素位置会产生两种情况 * 1.要么元素所在位置不变 * 2.要么元素所在位置变动：向右位移2次幂位置 * 注意：由于1.8中容量是根据阈值得来的，因此读者会在1.8中看到很多对阈值的判断和处理，这点一定要清楚 * @return the table */final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table;//由于新数组会覆盖旧数组，所以要临时先备份一份，用于对新数组重新赋值 int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123;//当Map不为空时 //临界处理：最大值 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE;//最大值其实是Integer的最大值 return oldTab; &#125; //若2倍容量 &lt; MAXIMUM_CAPACITY 同时 原容量&gt;=默认容量(即16)，那么就扩容2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold 阈值直接两倍（容量都是根据阈值来的） &#125; else if (oldThr &gt; 0)&#123;//当Map为空时，需要判断阈值是否&gt;0 newCap = oldThr;//阈值即新容量（注意：初始化时候就是执行该操作完成容量赋值） // initial capacity was placed in threshold（容量都是根据阈值来的） &#125; else &#123; //当Map为空，且阈值不是大于0（即无效阈值），那么就使用默认值 // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY;//1 &lt;&lt; 4 = 16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//0.75 * 16 = 12 &#125; //当新阈值没有被重置时，需要根据 新容量和负载因子 重新计算出新的阈值 //注意：初始化的时候，阈值会被重置，即此时 阈值！=容量 ，容量已经在(oldThr &gt; 0)时重置过了 if (newThr == 0) &#123; //等同于1.7版本：threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr;//重置给真实阈值 @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//新建一个新容量的Node数组 table = newTab;//覆盖原数组（第一行已经备份了） //当原数组非空，需要对新数组重新填充 if (oldTab != null) &#123; //遍历 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e;//用于备份当前节点 //若该数组下标位置非空 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//先把原数组的当前位置清空，因为已经备份了 help gc if (e.next == null)//当前桶既非链表也非红黑树 newTab[e.hash &amp; (newCap - 1)] = e;//位置可能不变或移动2次幂，跟newCap-1有关 else if (e instanceof TreeNode)//若当前桶是树节点，需要对树进行切分 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order 当前桶是链表，要保持顺序 1.7的会倒置 //扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致!!! Node&lt;K,V&gt; loHead = null, loTail = null;//lo=low，表示低位（即数组前半部分的链表） Node&lt;K,V&gt; hiHead = null, hiTail = null;//hi=high，表示高位（即数组后半部分的链表） Node&lt;K,V&gt; next; //遍历当前桶的链表 //1.8:是尾插入法，先来的留在数组上，后来的链在尾上（遍历时是先进先出） do &#123; next = e.next; //根据e.hash &amp; oldCap是否为零将原链表拆分成2个链表 //判断当前位置是否发生变动 0则没变 即保留在原链表中不需要移动 if ((e.hash &amp; oldCap) == 0) &#123; //原索引 在数组前半部分处理 //若队尾为空，当前元素即是队首元素（也就是第一个插入的元素），保证先进先出 if (loTail == null) loHead = e; else //若队尾不为空，当前元素链接到原队尾元素后面，保证先进先出 loTail.next = e; loTail = e;//为了保证插入顺序不变，当前元素都需先设置为队尾元素 &#125; //原索引+oldCap 否则移动到"原索引+oldCap"的新链表中 else &#123; //在数组后半部分处理 if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e;//为了保证插入顺序不变，当前元素都需先设置为队尾元素 &#125; &#125; while ((e = next) != null); //原索引放到原桶中 if (loTail != null) &#123;//如果队尾元素非空 loTail.next = null;//loTail此时就是队尾元素 newTab[j] = loHead;//队首是放在数组里面的 &#125; //原索引+oldCap放到新桶中 if (hiTail != null) &#123;//如果队尾元素非空 hiTail.next = null;//hiTail此时就是队尾元素 newTab[j + oldCap] = hiHead;//队首是放在数组里面的 &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 所以说，JDK 1.8之后扩容的改进有： 链表上的节点是尾插法，先来的放到数组中，后来的放到链表中，先到先出，类似于栈。 JDK 1.8 不像 JDK1.7中会重新计算每个节点在新哈希表中的位置，而是通过 (e.hash &amp; oldCap) == 0是否等于0 就可以得出原来链表中的节点在新哈希表的位置。无需重新计算Hash，节省了时间，新索引=原索引+原容量 HashMap 在 1.7的时候扩容后，链表的节点顺序会倒置，1.8则不会出现这种情况。因为1.7是后进先出，1.8是先进先出。 treeifyBin方法(树化方法)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 /** * Replaces all linked nodes in bin at index for given hash unless * table is too small, in which case resizes instead. * 桶内链表树化：将桶内所有的链表节点替换成红黑树节点，当元素数量不够树化时会重新resize * 注意：不是整个Map转换，只是当前桶！ */final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; //当数组为空 或者 数组长度 &lt; 树化阈值（64）时需要执行resize方法，重新决定内部的数据结构类型 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); //否则，需要树化 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null;//hd指的是head，tl指的是tail，分别指向红黑树的头、尾节点 //从链表头节点开始遍历链表，头节点是存放在数组中的 do &#123; //新建一个树形节点，内容和当前链表节点e保持一致 //此时next默认为null，会在后面按顺序重新对next赋值 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null)//当尾节点为空，即当前节点应为头节点（因为就这一个节点） hd = p; else &#123; p.prev = tl;//prev被赋值，主要是记录当前节点的上一个节点 tl.next = p;//p指向之前尾节点的next，保持插入顺序 &#125; tl = p;//当前节点设置为尾节点，保持插入顺序 &#125; while ((e = e.next) != null); //桶内第一个元素即链表头节点，并放在数组中 if ((tab[index] = hd) != null) hd.treeify(tab);//从头节点开始遍历，将整个桶树化 //注意头节点并不一定是树的根节点：树化后的根节点会重新设置为头节点，即tab[index]=root //具体参见moveRootToFront() &#125;&#125;// For treeifyBin 新建一个树形节点TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);&#125;/** * Forms tree of the nodes linked from this node. * 塑造红黑树 * @return root of tree 这里比较有意思，明明时void但有注释@return，不知大神们何意 */final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null;//根节点需要排序后重新设置（之前链表的头节点不一定是树的根节点） //this指的是当前二叉树的头节点，从头节点开始遍历 for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; //当根节点为空时，先设置根节点为黑色，同时当前节点先当作根节点（即自上而下插入） if (root == null) &#123; x.parent = null; x.red = false;//红黑树的根节点为黑色 root = x; &#125; else &#123; //后面进入循环走的逻辑，x 指向树中的某个节点 K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; //重新循环，从根节点开始，遍历所有节点与当前节点x比较，重新调整位置，类似冒泡排序 for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h)//如果比较节点的hash比当前节点的hash大，查左子树 dir = -1; else if (ph &lt; h) dir = 1;//如果比较节点的hash比当前节点的hash小，查右子树 else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0 ) //tieBreakOrder 用于hash相同时且key无法比较时，直接根据引用比较 //这里指的是如果当前比较节点的哈希值比x大，返回-1，否则返回1 dir = tieBreakOrder(k, pk); //经过前面的计算，得到了当前节点和要插入节点x的一个大小关系 //如果当前比较节点的哈希值比x大，x就是左子节点，否则x是右子节点 TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp;//把当前节点变成x的父节点 if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root);//将根节点设置为头节点 get方法(查询) 根据键值对的 key 去获取对应的 Value 1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; //通过 getNode寻找 key 对应的 Value 如果没找到，或者找到的结果为 null 就会返回null 否则会返回对应的 Value return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //现根据 key 的 hash 值去找到对应的链表或者红黑树 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 如果第一个节点就是那么直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //如果 对应的位置为红黑树调用红黑树的方法去寻找节点 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //遍历单链表找到对应的 key 和 Value do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; JDK 1.8新增 get 方法，在寻找 key 对应 Value 的时候如果没找到则返回指定默认值。 12345@Overridepublic V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;&#125; delete方法(删除)HashMap 没有 set 方法，如果想要修改对应 key 映射的 Value ，只需要再次调用 put 方法就可以了。我们来看下如何移除 HashMap 中对应的节点的方法： 12345678910 public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125; 这里有两个参数需要我们提起注意： matchValue 如果这个值为 true 则表示只有当 Value 与第三个参数 Value 相同的时候才删除对一个的节点 movable 这个参数在红黑树中先删除节点时候使用 true 表示删除并其他数中的节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //判断哈希表是否为空，长度是否大于0 对应的位置上是否有元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; // node 用来存放要移除的节点， e 表示下个节点 k ，v 每个节点的键值 Node&lt;K,V&gt; node = null, e; K k; V v; //如果第一个节点就是我们要找的直接赋值给 node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; // 遍历红黑树找到对应的节点 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; //遍历对应的链表找到对应的节点 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; // 如果找到了节点 // !matchValue 是否不删除节点 // (v = node.value) == value || // (value != null &amp;&amp; value.equals(v))) 节点值是否相同， if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //删除节点 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 1234567891011public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); //重要操作：迭代器中删除时同步了expectedModCount值与modCount相同 expectedModCount = modCount;&#125; 迭代Map 是没有迭代器的，需要转成 Set 操作 1234567Map map = new HashMap();Iterator iter = map.entrySet().iterator();while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue();&#125; 要强调的是，无论哪种迭代器都是通过遍历 table 表来获取下个节点，来遍历的，遍历过程可以理解为一种深度优先遍历，即优先遍历链表节点（或者红黑树），然后在遍历其他数组位置。 Fail-Fast当使用迭代器的过程中有其他线程修改了map，将引发ConcurrentModificationException 1234567891011121314//修改计数 put、remove或clear时mount++ clear时清空transient int modCount;HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125;&#125;final Entry&lt;K,V&gt; nextEntry() &#123; //期望变更数量不匹配 if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 与HashTable的区别 HashMap 是线程不安全的，HashTable是线程安全的。 HashMap 允许 key 和 Vale 是 null，但是只允许一个 key 为 null,且这个元素存放在哈希表 0 角标位置。 HashTable 不允许key、value 是 null。 HashMap 内部使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值。HashTable 是直接使用 key 的 hashCode() 返回值作为 hash 值。 HashMap默认容量为 2^4 且容量一定是 2^n ; HashTable 默认容量是11,不一定是 2^n。 HashTable 取哈希桶下标是直接用模运算,扩容时新容量是原来的2倍+1。HashMap 在扩容的时候是原来的两倍，且哈希桶的下标使用 &amp;运算代替了取模。 Hashtable是Dictionary的子类同时也实现了Map接口，HashMap是Map接口的一个实现类。 面试题答案 HashMap的底层数据结构？ 数组 + 链表 + 红黑树 HashMap的主要方法？ put()、resize()、treeifyBin()、get()、delete()等等 HashMap 是如何确定元素存储位置的以及如何处理哈希冲突的？ 是通过hashcode和扰乱函数确定的，先计算好key的hashCode,然后将hashCode的低16位和高16位进行相异或，异或完成后再进行取模(其实也就是与容量-1进行相与[有0则全为0，全1才为1])。一句话总结就是： 取key的hashCode值、高位运算、取模运算 HashMap 扩容机制是怎样的？ 先判断是否超过了整数型的最大值，如果没有，再判断是否已经超过了扩容阈值，如果超过了，则直接扩容两倍，扩容的数量都是2的n次方，HashMap都是优先扩容的，然后其次才是树化等等。 总的来说分为两步：1. 寻找扩容后数组的大小以及新的扩容阈值，2. 将原有哈希表拷贝到新的哈希表中。 JDK 1.8 在扩容和解决哈希冲突上对 HashMap 源码做了哪些改动？有什么好处? 在扩容方面，由于是选用了2的n次方作为桶的数量，所以在取模的时候就非常方便了，直接看hashCode的前一位是1或者0就可以判断在扩容后的新位置，无需重新取模运算； 既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了，这一块就是JDK1.8新增的优化点； HashMap 在 1.7的时候扩容后，链表的节点顺序会倒置，1.8则不会出现这种情况。因为1.7是后进先出，1.8是先进先出。1.7是头插法，1.8是尾插法； 什么时候会使用HashMap？他有什么特点？ 基于Map接口实现的Key-Value容器，允许为空值，同时非有序，线程不安全，非同步。 你知道HashMap的工作原理吗？ 经过HashCode和扰乱函数，得到相应的索引位置，然后插入，如果非空直接插入即可，如果是有数据，则判断是链表还是红黑树，如果链表超过8则先判断是否需要扩容，如果不需要就将链表变成红黑树！ 你知道get和put的原理吗？equals()和hashCode()都有什么作用？ 通过对key的hashCode()进行哈希处理，并计算下标（n-1＆hash），从而获得存储桶的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的队列。 你知道hash的实现吗？为什么要这样实现？ 在Java 1.8的实现中，是通过hashCode（）的高16位异或低16位实现的：（h = k.hashCode（））^（h &gt;&gt;&gt; 16），主要是从速度，效益，质量来考虑的，这样做可以在bucket的n比较小的时候，也能保证考虑到高低位都参与到hash的计算中，同时不会有太大的开销。 使用hash还有一个好处就是可以确保每个链表中的长度一致 如果HashMap的大小超过了负载因子（load factor）定义的容量，怎么办？ 如果超过了负载因子（最小0.75），则重新重新调整一个原先长度的HashMap，并重新调用hash方法。 你了解重新调整HashMap大小存在什么问题吗？ 当数据过多时，很可能出现性能下降（包括rehash时间） 多线程情况下可能产生条件竞争竞争从而造成死循环（具体表现在CPU接近100％)，多线程环境下推荐使用ConcurrentHashMap 为什么使用String，Interger这样的wrapper类适合作为键？ 因为这种类具有final属性，可以保证线程的相对安全，也可以减少碰撞 [自动装箱，自动拆箱的知识点！！] 可以同时重建equals()和hashCode()方法。 我们可以使用自定义的对象作为键吗？ 当然你可能使用任何对象作为键，只要它遵守了equals（）和hashCode（）方法的定义规则，并且当对象插入到Map中之后将不会再改变了。自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 如何对HashMap进行排序？ 存入LinkedHashMap HashMap的删除陷阱？ 通过Iterator方式可正确遍历完成删除操作 直接调用list的remove方法就会抛异常 为什么只允许通过iterator进行删除操作？ HashMap和keySet的删除方法都可以通过传递key参数删除任意的元素 而iterator只能删除当前元素（当前），一旦删除的元素是iterator对象中下一个正在引用的，如果没有通过modCount，expectedModCount的比较实现快速失败异常，则下一循环该元素将成为当前指向，此时iterator就遍历了一个已移除的过期数据 之所以推荐迭代器remove的根本原因在于只有迭代器的remove方法中实现了变更时于modCount的同步工作expectedModCount = modCount; 如果是遍历过程中增加或修改数据呢？ 增加或修改数据只能通过Map的put方法实现，在遍历过程中修改数据可以，但如果增加新密钥就会在下次循环时抛出异常，因为在添加新密钥时modCount也会自增（迭代器只实现了删除方法也是原因之一） hashmap为什么初始长度为16？ 首先要为2的幂次。这是因为，hashmap计算key的hash值进行存储的时候采用的方法是 “用key的hash值和hashmap的长度减一（length-1）按位与（&amp;），2的幂次减一的二进制是111……，任何数和1与就是他本身，这样存储进来的hash位置就取决于key的二进制值了，这样会让hash分布相对分散。提升性能。 HashMap中的扰动函数是什么，有什么作用，TreeMap中有吗？ 就是返回 hashCode的高16位和低16位相异或然后与 容量-1 相与的结果，这样的话分散更均匀，TreeMap没有。 有什么方法可以减少碰撞？ 扰动函数可以减少碰撞 原理是如果两个不相等的对象返回不同的 hashcode 的话，那么碰撞的几率就会小些。这就意味着存链表结构减小，这样取值的话就不会频繁调用 equal 方法，从而提高 HashMap 的性能（扰动即 Hash 方法内部的算法实现，目的是让不同对象返回不同hashcode）。 使用不可变的、声明作 final 对象，并且采用合适的 equals() 和 hashCode() 方法，将会减少碰撞的发生 不可变性使得能够缓存不同键的 hashcode，这将提高整个获取对象的速度，使用 String、Integer 这样的 wrapper 类作为键是非常好的选择。 HashMap为何可以插入空值？为什么它是线程不安全的？ HashMap在put的时候会调用hash()方法来计算key的hashcode值，可以从hash算法中看出当key==null时返回的值为0。因此key为null时，hash算法返回值为0，不会调用key的hashcode方法。而Hashtable存入的value为null时，抛出NullPointerException异常。如果value不为null，而key为空，在执行到int hash = key.hashCode()时同样会抛出NullPointerException异常。 上面说到，HashMap会进行resize操作，在resize操作的时候会造成线程不安全。下面将举两个可能出现线程不安全的地方。 1234put的时候导致的多线程数据不一致。 * 这个问题比较好想象，比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的桶索引和线程B要插入的记录计算出来的桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。 * 另外一个比较明显的线程不安全的问题是HashMap的get操作可能因为resize而引起死循环（cpu100%)。 可以使用 CocurrentHashMap 来代替 Hashtable 吗？ 我们知道 Hashtable 是 synchronized 的，但是 ConcurrentHashMap 同步性能更好，因为它仅仅根据同步级别对 map 的一部分进行上锁 ConcurrentHashMap 当然可以代替 HashTable，但是 HashTable 提供更强的线程安全性 它们都可以用于多线程的环境，但是当 Hashtable 的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。 由于 ConcurrentHashMap 引入了分割（segmentation），不论它变得多么大，仅仅需要锁定 Map 的某个部分，其它的线程不需要等到迭代完成才能访问 Map。 简而言之，在迭代的过程中，ConcurrentHashMap 仅仅锁定 Map 的某个部分，而 Hashtable 则会锁定整个 Map。 CocurrentHashMap（JDK 1.8） CocurrentHashMap 抛弃了原有的 Segment 分段锁，采用了 CAS + synchronized 来保证并发安全性。其中的 val next 都用了 volatile 修饰，保证了可见性。 最大特点是引入了 CAS 借助 Unsafe 来实现 native code。CAS有3个操作数，内存值 V、旧的预期值 A、要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值V修改为 B，否则什么都不做。Unsafe 借助 CPU 指令 cmpxchg 来实现。 CAS 使用实例 对 sizeCtl 的控制都是用 CAS 来实现的： -1 代表 table 正在初始化 N 表示有 -N-1 个线程正在进行扩容操作 如果 table 未初始化，表示table需要初始化的大小 如果 table 初始化完成，表示table的容量，默认是table大小的0.75倍，用这个公式算 0.75（n – (n &gt;&gt;&gt; 2)） CAS 会出现的问题：ABA 解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。 贴一个复习时可以看的问答 https://cloud.tencent.com/developer/article/1491634 TreeMap 接下来我们一起来分析一波 TreeMap ！！！ 参考TreeMap 源码分析 java集合（6）：TreeMap源码分析（jdk1.8） 如何决定使用HashMap Or TreeMap 问题引导 如何决定使用 HashMap 还是 TreeMap？ TreeMap的特点 概述 TreeMap 底层基于红黑树实现 该集合最重要的特点就是可排序，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 由上图可知，TreeMap 继承了 AbstractMap，同时实现了 NavigableMap (导航 map )，而 NavigableMap 则是继承了 SortedMap ,而 SortedMap 和 AbstractMap 则是实现了 Map 接口。 NavigableMap 接口，NavigableMap 接口声明了一些列具有导航功能的方法，通过这些导航方法，我们可以快速定位到目标的 key 或 Entry。比如： 12345678910111213141516/** * 返回红黑树中最小键所对应的 Entry */Map.Entry&lt;K,V&gt; firstEntry();/** * 返回最大的键 maxKey，且 maxKey 仅小于参数 key */K lowerKey(K key);/** * 返回最小的键 minKey，且 minKey 仅大于参数 key */K higherKey(K key);// 其他略 至于 SortedMap 接口，这个接口提供了一些基于有序键的操作，比如: 1234567891011/** * 返回包含键值在 [minKey, toKey) 范围内的 Map */SortedMap&lt;K,V&gt; headMap(K toKey);();/** * 返回包含键值在 [fromKey, toKey) 范围内的 Map */SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);// 其他略 源码分析JDK 1.8中的TreeMap源码有两千多行，还是比较多的。TreeMap实现的核心部分是关于红黑树的实现，其绝大部分的方法基本都是对底层红黑树增、删、查操作的一个封装。如简介一节所说，只要弄懂了红黑树原理，TreeMap 就没什么秘密了。关于红黑树的原理，请参考本人的另一篇文章 红黑树详细分析。 类名及类成员变量1234567891011121314151617181920212223242526public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; // 比较器对象 private final Comparator&lt;? super K&gt; comparator; // 根节点 private transient Entry&lt;K,V&gt; root; // 集合大小 private transient int size = 0; // 树结构被修改的次数 private transient int modCount = 0; // 静态内部类用来表示节点类型 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; // 键 V value; // 值 Entry&lt;K,V&gt; left; // 指向左子树的引用（指针） Entry&lt;K,V&gt; right; // 指向右子树的引用（指针） Entry&lt;K,V&gt; parent; // 指向父节点的引用（指针） boolean color = BLACK; // &#125;&#125; 构造方法123456789101112131415161718192021public TreeMap() &#123; // 1,无参构造方法 comparator = null; // 默认比较机制&#125;public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; // 2，自定义比较器的构造方法 this.comparator = comparator;&#125;public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 3，构造已知Map对象为TreeMap comparator = null; // 默认比较机制 putAll(m);&#125;public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; // 4，构造已知的SortedMap对象为TreeMap comparator = m.comparator(); // 使用已知对象的构造器 try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; 查找TreeMap基于红黑树实现，而红黑树是一种自平衡二叉查找树，所以 TreeMap 的查找操作流程和二叉查找树一致。二叉树的查找流程是这样的，先将目标值和根节点的值进行比较，如果目标值小于根节点的值，则再和根节点的左孩子进行比较。如果目标值大于根节点的值，则继续和根节点的右孩子比较。在查找过程中，如果目标值和二叉树中的某个节点值相等，则返回 true，否则返回 false。TreeMap 查找和此类似，只不过在 TreeMap 中，节点（Entry）存储的是键值对。在查找过程中，比较的是键的大小，返回的是值，如果没找到，则返回null。TreeMap 中的查找方法是get，具体实现在getEntry方法中，相关源码如下： 12345678910111213141516171819202122232425262728public V get(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; // 查找操作的核心逻辑就在这个 while 循环里 // key 与 root 作比较 while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125; 遍历 Iterator 顺序遍历 12345678TreeMap map = new TreeMap();Set set = map.entrySet();Iterator iter = set.iterator();while(iter.hasNext())&#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object value = entry.getValue();&#125; foreach 遍历 1234567891011//遍历Map 第二种方式Map&lt;String, Integer&gt; map1 = new TreeMap&lt;&gt;();map1.put("jack", 20);map1.put("rose", 18);map1.put("lucy", 17);map1.put("java", 25);//通过Map.Entry(String,Integer) 获取，然后使用entry.getKey()获取到键，通过entry.getValue()获取到值for(Map.Entry&lt;String, Integer&gt; entry : map1.entrySet())&#123; System.out.println("键 key ："+entry.getKey()+" 值value ："+entry.getValue());&#125; 从上面代码片段中可以看出，大家一般都是对 TreeMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 entrySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于： 1234567Set entry = map.entrySet();Iterator ite = entry.iterator();while (ite.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); // do something&#125; 另一方面，TreeMap 有一个特性，即可以保证键的有序性，默认是正序。所以在遍历过程中，大家会发现 TreeMap 会从小到大输出键的值。那么，接下来就来分析一下keySet方法，以及在遍历 keySet 方法产生的集合时，TreeMap 是如何保证键的有序性的。相关代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public Set&lt;K&gt; keySet() &#123; return navigableKeySet();&#125;public NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nks = navigableKeySet; return (nks != null) ? nks : (navigableKeySet = new KeySet&lt;&gt;(this));&#125;static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; &#123; private final NavigableMap&lt;E, ?&gt; m; KeySet(NavigableMap&lt;E,?&gt; map) &#123; m = map; &#125; public Iterator&lt;E&gt; iterator() &#123; if (m instanceof TreeMap) return ((TreeMap&lt;E,?&gt;)m).keyIterator(); else return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).keyIterator(); &#125; // 省略非关键代码&#125;Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry());&#125;final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125;&#125;abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; Entry&lt;K,V&gt; next; Entry&lt;K,V&gt; lastReturned; int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 寻找节点 e 的后继节点 next = successor(e); lastReturned = e; return e; &#125; /** * Returns the successor of the specified Entry, or null if no such. */ static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 其他方法省略&#125; 上面的代码比较多，keySet 涉及的代码还是比较多的，大家可以从上往下看。从上面源码可以看出 keySet 方法返回的是KeySet类的对象。这个类实现了Iterable接口，可以返回一个迭代器。该迭代器的具体实现是KeyIterator，而 KeyIterator 类的核心逻辑是在PrivateEntryIterator中实现的。上面的代码虽多，但核心代码还是 KeySet 类和 PrivateEntryIterator 类的 nextEntry方法。KeySet 类就是一个集合，这里不分析了。而 nextEntry 方法比较重要，下面简单分析一下。 在初始化 KeyIterator 时，会将 TreeMap 中包含最小键的 Entry 传给 PrivateEntryIterator。当调用 nextEntry 方法时，通过调用 successor 方法找到当前 entry 的后继，并让 next 指向后继，最后返回当前的 entry。通过这种方式即可实现按正序返回键值的的逻辑。 插入与删除其实就是红黑树的插入和删除，具体红黑树的插入和删除见我另写的红黑树文章。 插入 1234567891011121314151617181920212223242526272829303132333435363738394041public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // 1.如果根节点为 null，将新节点设为根节点 if (t == null) &#123; compare(key, key); root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; // 2.为 key 在红黑树找到合适的位置 do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; // 与上面代码逻辑类似，省略 &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); // 3.将新节点链入红黑树中 if (cmp &lt; 0) parent.left = e; else parent.right = e; // 4.插入新节点可能会破坏红黑树性质，这里修正一下 fixAfterInsertion(e); size++; modCount++; return null;&#125; put 方法代码如上，逻辑和二叉查找树插入节点逻辑一致。重要的步骤我已经写了注释，并不难理解。插入逻辑的复杂之处在于插入后的修复操作，对应的方法fixAfterInsertion，该方法的源码和说明如下： 1234567891011121314151617181920212223242526272829303132333435363738394041/** From CLR */ private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; 删除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue;&#125;private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; /* * 1. 如果 p 有两个孩子节点，则找到后继节点， * 并把后继节点的值复制到节点 P 中，并让 p 指向其后继节点 */ if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; /* * 2. 将 replacement parent 引用指向新的父节点， * 同时让新的父节点指向 replacement。 */ replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // 3. 如果删除的节点 p 是黑色节点，则需要进行调整 if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // 删除的是根节点，且树中当前只有一个节点 root = null; &#125; else &#123; // 删除的节点没有孩子节点 // p 是黑色，则需要进行调整 if (p.color == BLACK) fixAfterDeletion(p); // 将 P 从树中移除 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 从源码中可以看出，remove方法只是一个简单的保证，核心实现在deleteEntry方法中。deleteEntry 主要做了这么几件事： 如果待删除节点 P 有两个孩子，则先找到 P 的后继 S，然后将 S 中的值拷贝到 P 中，并让 P 指向 S 如果最终被删除节点 P（P 现在指向最终被删除节点）的孩子不为空，则用其孩子节点替换掉 如果最终被删除的节点是黑色的话，调用 fixAfterDeletion 方法进行修复 上面说了 replacement 不为空时，deleteEntry 的执行逻辑。上面说的略微啰嗦，如果简单说的话，7个字即可总结：找后继 -&gt; 替换 -&gt; 修复。这三步中，最复杂的是修复操作。修复操作要重新使红黑树恢复平衡，修复操作的源码分析如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** From CLR */ private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; 自定义比较器 在实体类对象中实现Comparable接口并实现了compareTo()方法【String，Integer对象就是此种方式】 12345678910111213141516171819202122232425262728293031323334353637class TreeMap2_Comparable &#123; public static void main(String[] args) &#123; Map&lt;User, String&gt; map = new TreeMap&lt;&gt;(); map.put(new User("jerome", 30), "hello"); map.put(new User("memory", 30), "hello"); map.put(new User("aa", 22), "hello"); map.put(new User("bb", 20), "hello"); for (Map.Entry&lt;User, String&gt; each : map.entrySet()) &#123; System.out.println(each.getKey()+"::"+each.getValue()); &#125; &#125;&#125;class User implements Comparable&lt;User&gt;&#123; private String username; private int age; public User(String username, int age) &#123; this.username = username; this.age = age; &#125; @Override public String toString() &#123; return "User [username=" + username + ", age=" + age + "]"; &#125; @Override public int compareTo(User user) &#123; // 先比较 age ，再比较 username int temp = this.age - user.age; return temp == 0 ? this.username.compareTo(user.username) : temp; &#125;&#125; 输出： 12345&gt; User [username=bb, age=20]::hello&gt; User [username=aa, age=22]::hello&gt; User [username=jerome, age=30]::hello&gt; User [username=memory, age=30]::hello&gt; 写一个类实现java.util.Comparator接口(注意这里是Comparator，上面是Comparable)，并将该类对象传递给TreeMap的构造方法。这种方式将实体类和比较机制解耦合，可以写很多个不同的比较器对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TreeMap2_Comparator&#123; public static void main(String[] args) &#123; Map&lt;User2, String&gt; map = new TreeMap&lt;&gt;(new TreeMapComparator()); map.put(new User2("jerome", 30), "hello"); map.put(new User2("memory", 30), "hello"); map.put(new User2("aa", 22), "hello"); map.put(new User2("bb", 20), "hello"); for (Map.Entry&lt;User2, String&gt; each : map.entrySet()) &#123; System.out.println(each.getKey()+"::"+each.getValue()); &#125; &#125;&#125;class User2 &#123; // User对象不再实现任何接口 private String username; private int age; public User2(String username, int age) &#123; super(); this.username = username; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "User2 [username=" + username + ", age=" + age + "]"; &#125;&#125;class TreeMapComparator implements Comparator&lt;User2&gt; &#123; // 比较器类 @Override public int compare(User2 o1, User2 o2) &#123; int temp = o1.getAge() - o2.getAge(); return temp == 0 ? o1.getUsername().compareTo(o2.getUsername()) : temp; &#125;&#125; 输出同上 不写比较器类，而是使用匿名内部类的形式来写比较器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class TreeMap2_InnerComparator &#123; public static void main(String[] args) &#123; Map&lt;User3, String&gt; map = new TreeMap&lt;&gt;(new Comparator&lt;User3&gt;() &#123; @Override public int compare(User3 o1, User3 o2) &#123; int temp = o1.getAge() - o2.getAge(); return temp == 0 ? o1.getUsername().compareTo(o2.getUsername()) : temp; &#125; &#125;); map.put(new User3("jimmy1", 30), "hello"); map.put(new User3("jimmy2", 30), "hello"); map.put(new User3("jimmy", 22), "hello"); map.put(new User3("jimmy", 20), "hello"); for (Map.Entry&lt;User3, String&gt; each : map.entrySet()) &#123; System.out.println(each.getKey() + "::" + each.getValue()); &#125; &#125;&#125;class User3 &#123; // User对象不再实现任何接口 private String username; private int age; public User3(String username, int age) &#123; super(); this.username = username; this.age = age; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "User3 [username=" + username + ", age=" + age + "]"; &#125;&#125; 面试相关题目 HashMap 和 TreeMap 有迭代器吗？ keySet()和entrySet()方法，在将HashMap的时候已经讲过了，Map没有迭代器，要将Map转化为Set，用Set的迭代器才能进行元素迭代。 如何决定使用 HashMap 还是 TreeMap？ 都是非线程安全的，如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，故大多不需要排序的时候我们会使用HashMap。 TreeMap的特点？ 非线程安全，可排序，正常情况下不允许重复(默认没有重写比较器)，底层采用的是红黑树。因为其非线程安全，故可以允许null值，这个跟HashMap、ArrayList、LinkedList是一样的。 Map 的 key 值都是不可以重复的，故 Set 与 List 最大的区别就是一个数据不可重复，一个是可以重复的。 HashMap、TreeMap、ConcurrentHashMap、HashTable、ArrayDeque、ArrayList、LinkedList、Vector线程安全问题以及 key、value 是否能为空？ 集合 线程是否安全 key、value是否可以为空 原因 HashMap 非线程安全 Key、value均能为空 Key 可以为空，但必须唯一，value没有限制 TreeMap 非线程安 Key不能为null、value不能为null key不能为null，因为其需要排序，value可以为null ConcurrentHashMap 线程安全 Key、value均不能为空 key不能为空，因为采用了fail-safe机制，这种机制会使得读取的数据不一定是最新的，使用null值，就会使得其无法判断对应的key是不存在还是为空，因为你无法再调用一次contains(key）来对key是否存在进行判断，HashTable同理。故在入参时，若为 null 就报空指针异常，而且在取hashcode时，压根就没考虑空的情况。 HashTable 线程安全 Key、value均不能为空 value不能为空，当通过get(k)获取对应的value时，如果获取到的是null时，无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。假如线程1调用m.contains（key）返回true，然后在调用m.get(key)，这时的m可能已经不同了。因为线程2可能在线程1调用m.contains（key）时，删除了key节点，这样就会导致线程1得到的结果不明确，产生多线程安全问题，因此，Hashmap和ConcurrentHashMap的key和value不能为null。 ArrayDeque 非线程安全 值不能为空 不能存入 null，因为在add时就有判断，如果是 null，就报空指针异常 ArrayList 非线程安全 值可以为空 可以为空，当成一个对象加入或删除，添加null也会增加size LinkedList 非线程安全 值可以为空 同ArrayList Vector 线程安全 值不可以为空 不能为空，因为是线程安全的，使用了fail-safe机制，同ConcurrentHashMap LinkedHashMap参考LinkedHashMap源码详细分析 LinkedHashMap 源码解读(JDK 1.8) LinkedHashMap详解 Java集合之LinkedHashMap Java集合框架之LinkedHashMap详解 Java LinkedHashMap类源码解析 Java8集合系列之LinkedHashMap LinkedHashMap、ConcurrentHashMap概括 概述 LinkedHashMap是HashMap的一个子类，它保留插入或者访问顺序，帮助我们实现了有序的HashMap。 其维护一个双向链表，并不是说其除了维护存入的数据，另外维护了一个双向链表对象，而是说其根据重写HashMap的实体类Entry，来实现能够将HashMap的数据组成一个双向列表，其存储的结构还是数组+链表+红黑树的形式，也就是链表上的节点有三个指针，分别是before、after、next。 与 HashMap 的区别这里用一个 demo 呈现出 LinkedHashMap 的有序的特点 123456789101112 public static void main(String[] args) &#123;// LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap(16, 0.75f,true); LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap(); map.put("apple",10000); map.put("huawei",5000); map.put("xiaomi",2000);// map.get("apple");// map.get("xiaomi"); for(Map.Entry a:map.entrySet())&#123; System.out.println(a.getValue()); &#125; &#125; 1234输出为：1000050002000 可以看到，在使用上，LinkedHashMap和HashMap的区别就是LinkedHashMap是有序的。 上面这个例子是根据插入顺序排序，此外，LinkedHashMap还有一个参数(accessOrder)决定是否在此基础上再根据访问顺序(get,put)排序,记住，是在插入顺序的基础上再排序，后面看了源码就知道为什么了。看下例子: 123456789101112 public static void main(String[] args) &#123; LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap(16, 0.75f,true);// LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap(); map.put("apple",10000); map.put("huawei",5000); map.put("xiaomi",2000); map.get("apple"); map.get("xiaomi"); for(Map.Entry a:map.entrySet())&#123; System.out.println(a.getValue()); &#125; &#125; 1234输出为：5000100002000 很明显能看出来，由于将 accessOrder == true，按照了读取顺序排列，最开始的顺序是 apple - huawei - xiaomi，由于读取了apple，apple则进入到尾(tail)，顺序变为 huawei - xiaomi - apple，又读取了 xiaomi，故顺序变为 huawei - apple - xiaomi ，故最后的答案是 5000 - 10000 - 2000。 LinkedHashMap的存储结构LinkedHashMap之所以能实现存取的顺序性，主要是他重新定义了 Entry ，这个新的 Entry 继承自HashMap.Node，并做了新的扩展，下面我们结合源码来分析一下。 123456789101112131415161718192021/*** 继承自 HashMap.Node，新增了 before、after 记录插入顺序*///链表结点static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;private static final long serialVersionUID = 3801124242820219131L;//链表头部transient LinkedHashMap.Entry&lt;K,V&gt; head;//链表尾部transient LinkedHashMap.Entry&lt;K,V&gt; tail;/** * 访问顺序 * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. */final boolean accessOrder; 由上面的代码我们可以看出，这个自定义的 Entry比 HashMap.Node多了两个属性，before和after。正是使用这两个关键的属性，在LinkedHashMap内部实现了一个双向链表。双向链表就是每个节点除了存储数据本身之外，还保存着两个指针，在java里面就是指向对象的引用，一个是前驱节点，也就是他的前一个节点的引用，一个是后继节点，也就是他的后一个节点的引用。这样，就可以实现存储一个有序节点的数据结构了。（这里说明下，在jdk1.7中，使用的结构为环形双向链表）另外，继承自HashMap.Node的Entry自身还保留着用于维持单链表的next属性，因此LinkedHashMap的Entry节点具有三个指针域，next指针维护Hash桶中冲突key的链表，before和after维护双向链表。结构如下图所示： 重要方法构造函数两个构造方法，一个是继承 HashMap ，一个是可以选择 accessOrder 的值(默认 false，代表按照插入顺序排序)来确定是按插入顺序还是读取顺序排序。 123456789101112131415161718192021//调用父类HashMap的构造方法。public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;/** * //调用父类HashMap的构造方法。 * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance * with the default initial capacity (16) and load factor (0.75). */public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; put()LinkedHashMap 的 put 方法也是使用 HashMap 的方法，不同在于重写了 newNode(), afterNodeAccess() 和 afterNodeInsertion() 这几个方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// HashMap 中实现public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;// HashMap 中实现final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) &#123;...&#125; // 通过节点 hash 定位节点所在的桶位置，并检测桶中是否包含节点引用 if ((p = tab[i = (n - 1) &amp; hash]) == null) &#123;...&#125; else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) &#123;...&#125; else &#123; // 遍历链表，并统计链表长度 for (int binCount = 0; ; ++binCount) &#123; // 未在单链表中找到要插入的节点，将新节点接在单链表的后面 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) &#123;...&#125; break; &#125; // 插入的节点已经存在于单链表中 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) &#123;...&#125; afterNodeAccess(e); // 回调方法，后续说明！！！重点哈！！！ return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) &#123;...&#125; afterNodeInsertion(evict); // 回调方法，后续说明！！！重点哈！！！ return null;&#125;// HashMap 中实现Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next);&#125;// LinkedHashMap 中覆写！！！！！重点！！！Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); // 将 Entry 接在双向链表的尾部 linkNodeLast(p); return p;&#125;// LinkedHashMap 中实现！！！！！private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; // last 为 null，表明链表还未建立 if (last == null) head = p; else &#123; // 将新节点 p 接在链表尾部 p.before = last; last.after = p; &#125;&#125; 我把 newNode 方法红色背景标注了出来，这一步比较关键。LinkedHashMap 覆写了该方法。在这个方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。双向链表建立之后，我们就可以按照插入顺序去遍历 LinkedHashMap。 接下来就重点介绍 newNode() 、linkNodeLast()、afterNodeAccess() 、afterNodeInsertion()、afterNodeInsertion() newNode() 12345678910/** * 根据 key-value 创建双向链表节点 * e 表示下一个节点, 不过这里是空值, 不用理会 */Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125; linkNodeLast() 1234567891011121314/** * 把新节点插入到双向链表尾部 */private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; // 如果这是空链表, 新节点就是头结点 if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; afterNodeAccess() &amp; afterNodeInsertion() &amp; afterNodeRemoval() 1234// Callbacks to allow LinkedHashMap post-actionsvoid afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125; 根据这三个方法的注释可以看出，这些方法的用途是在增删查等操作后，通过回调的方式，让 LinkedHashMap 有机会做一些后置操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//标准的如何在双向链表中将指定元素放入队尾// LinkedHashMap 中覆写//访问元素之后的回调方法/** * 1. 使用 get 方法会访问到节点, 从而触发调用这个方法 * 2. 使用 put 方法插入节点, 如果 key 存在, 也算要访问节点, 从而触发该方法 * 3. 只有 accessOrder 是 true 才会调用该方法 * 4. 这个方法会把访问到的最后节点重新插入到双向链表结尾 */void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last // 用 last 表示插入 e 前的尾节点 // 插入 e 后 e 是尾节点, 所以也是表示 e 的前一个节点 LinkedHashMap.Entry&lt;K,V&gt; last; //如果是访问序，且当前节点并不是尾节点 //将该节点置为双向链表的尾部 if (accessOrder &amp;&amp; (last = tail) != e) &#123; // p: 当前节点 // b: 前一个节点 // a: 后一个节点 // 结构为: b &lt;=&gt; p &lt;=&gt; a LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; // 结构变成: b &lt;=&gt; p &lt;- a p.after = null; // 如果当前节点 p 本身是头节点, 那么头结点要改成 a if (b == null) head = a; // 如果 p 不是头尾节点, 把前后节点连接, 变成: b -&gt; a else b.after = a; // a 非空, 和 b 连接, 变成: b &lt;- a if (a != null) a.before = b; // 如果 a 为空, 说明 p 是尾节点, b 就是它的前一个节点, 符合 last 的定义 // 这个 else 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null else last = b; // 如果这是空链表, p 改成头结点 if (last == null) head = p; // 否则把 p 插入到链表尾部 else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 12345678910111213141516void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // 优美的一笔，学习一波如何在双向链表中删除节点 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; // 将 p 节点的前驱后后继引用置空 p.before = p.after = null; // b 为 null，表明 p 是头节点 if (b == null) head = a; else b.after = a; // a 为 null，表明 p 是尾节点 if (a == null) tail = b; else a.before = b;&#125; 123456789101112131415161718192021222324252627// 在插入一个新元素之后，如果是按插入顺序排序，即调用newNode()中的linkNodeLast()完成// 如果是按照读取顺序排序，即调用afterNodeAccess()完成// 那么这个方法是干嘛的呢，这个就是著名的 LRU 算法啦// 在插入完成之后，需要回调函数判断是否需要移除某些元素！/** * 插入新节点才会触发该方法，因为只有插入新节点才需要内存 * 根据 HashMap 的 putVal 方法, evict 一直是 true * removeEldestEntry 方法表示移除规则, 在 LinkedHashMap 里一直返回 false * 所以在 LinkedHashMap 里这个方法相当于什么都不做 */void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; // 根据条件判断是否移除最近最少被访问的节点 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;// 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存// LinkedHashMap是默认返回false的，我们可以继承LinkedHashMap然后复写该方法即可// 例如 LeetCode 第 146 题就是采用该种方法，直接 return size() &gt; capacity;protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; get()前面说了插入顺序的实现，本节来讲讲访问顺序。默认情况下，LinkedHashMap 是按插入顺序维护链表。不过我们可以在初始化 LinkedHashMap，指定 accessOrder 参数为 true，即可让它按访问顺序维护链表。访问顺序的原理上并不复杂，当我们调用get、getOrDefault、replace等方法时，只需要将这些方法访问的节点移动到链表的尾部即可。相应的源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// LinkedHashMap 中覆写public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; // 如果 accessOrder 为 true，则调用 afterNodeAccess 将被访问节点移动到链表最后 if (accessOrder) afterNodeAccess(e); return e.value;&#125;// LinkedHashMap 中覆写void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; // 如果 b 为 null，表明 p 为头节点 if (b == null) head = a; else b.after = a; if (a != null) a.before = b; /* * 这里存疑，父条件分支已经确保节点 e 不会是尾节点， * 那么 e.after 必然不会为 null，不知道 else 分支有什么作用 */ else last = b; if (last == null) head = p; else &#123; // 将 p 接在链表的最后 p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; delete()与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。那么删除及节点后，被删除的节点该如何从双链表中移除呢？当然，办法还算是有的。上一节最后提到 HashMap 中三个回调方法运行 LinkedHashMap 对一些操作做出响应。所以，在删除及节点后，回调方法 afterNodeRemoval 会被调用。LinkedHashMap 覆写该方法，并在该方法中完成了移除被删除节点的操作。相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// HashMap 中实现public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;// HashMap 中实现final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) &#123;...&#125; else &#123; // 遍历单链表，寻找要删除的节点，并赋值给 node 变量 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) &#123;...&#125; // 将要删除的节点从单链表中移除 else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); // 调用删除回调方法进行后续操作 return node; &#125; &#125; return null;&#125;//具体分析 上面 put() 中讲的很清楚了！// LinkedHashMap 中覆写void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; // 将 p 节点的前驱后后继引用置空 p.before = p.after = null; // b 为 null，表明 p 是头节点 if (b == null) head = a; else b.after = a; // a 为 null，表明 p 是尾节点 if (a == null) tail = b; else a.before = b;&#125;// 我已经在 HashMap 部分讲过了final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; 删除的过程并不复杂，上面这么多代码其实就做了三件事： 根据 hash 定位到桶位置 遍历链表或调用红黑树相关的删除方法 从 LinkedHashMap 维护的双链表中移除要删除的节点 replacementTreeNode()在进行红黑树转换的时候一些方法也进行了重写，如下： 123456789101112131415161718192021TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; LinkedHashMap.Entry&lt;K,V&gt; q = (LinkedHashMap.Entry&lt;K,V&gt;)p; //TreeNode依旧是HashMap中的内部类 TreeNode&lt;K,V&gt; t = new TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next); transferLinks(q, t); return t;&#125;//就是对原来双向链表中的结点结点进行替换，替换成TreeNode结点（另外，TreeNode继承了LinkedHashMap.Entry）private void transferLinks(LinkedHashMap.Entry&lt;K,V&gt; src, LinkedHashMap.Entry&lt;K,V&gt; dst) &#123; LinkedHashMap.Entry&lt;K,V&gt; b = dst.before = src.before; LinkedHashMap.Entry&lt;K,V&gt; a = dst.after = src.after; if (b == null) head = dst; else b.after = dst; if (a == null) tail = dst; else a.before = dst;&#125; 迭代LinkedHashMap 的遍历方式和 HashMap 的一样，都是通过 entrySet 方法返回 Set 实例,，然后通过 iterator 方法返回迭代器进行遍历。 entrySet 12345678910111213141516171819/** * 返回 LinkedEntrySet 实例, 这是非静态内部类 */public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es;&#125;/** * 和 HashMap 的 EntrySet 类一样继承 AbstractSet * iterator 方法返回 LinkedEntryIterator 实例 */final class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; ... public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new LinkedEntryIterator(); &#125; ...&#125; next 和 hasNext 1234567891011121314151617181920212223242526272829303132333435363738394041/** * next 方法实际是调用父类 nextNode 方法返回节点 */final class LinkedEntryIterator extends LinkedHashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;&#125;abstract class LinkedHashIterator &#123; LinkedHashMap.Entry&lt;K,V&gt; next; LinkedHashMap.Entry&lt;K,V&gt; current; int expectedModCount; /** * 构造函数, 从双向链表头节点开始遍历 */ LinkedHashIterator() &#123; next = head; expectedModCount = modCount; current = null; &#125; public final boolean hasNext() &#123; return next != null; &#125; /** * 遍历比较简单, 直接读取下一个节点就行 */ final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123; LinkedHashMap.Entry&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); current = e; next = e.after; //直接遍历双向链表的下一个节点即可 return e; &#125; ...&#125; 重要补充点###为何 TreeNode 这个类继承的是 LinkedHashMap 的 Entry，而不是 HashMap 中的 Node ？ 先来看看继承体系结构图： 上面的继承体系乍一看还是有点复杂的，同时也有点让人迷惑。HashMap 的内部类 TreeNode 不继承它的内部类 Node，却继承自 Node 的子类 LinkedHashMap 内部类 Entry。这里这样做是有一定原因的，这里先不说。先来简单说明一下上面的继承体系。LinkedHashMap 内部类 Entry 继承自 HashMap 内部类 Node，并新增了两个引用，分别是 before 和 after。这两个引用的用途不难理解，也就是用于维护双向链表。同时，TreeNode 继承 LinkedHashMap 的内部类 Entry 后，就具备了和其他 Entry 一起组成链表的能力。但是这里需要大家考虑一个问题。当我们使用 HashMap 时，TreeNode 并不需要具备组成链表能力。如果继承 LinkedHashMap 内部类 Entry ，TreeNode 就多了两个用不到的引用，这样做不是会浪费空间吗？简单说明一下这个问题（水平有限，不保证完全正确），这里这么做确实会浪费空间，但与 TreeNode 通过继承获取的组成链表的能力相比，这点浪费是值得的。在 HashMap 的设计思路注释中，有这样一段话： Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins. Inusages with well-distributed user hashCodes, tree bins arerarely used. 大致的意思是 TreeNode 对象的大小约是普通 Node 对象的2倍，我们仅在桶（bin）中包含足够多的节点时再使用。当桶中的节点数量变少时（取决于删除和扩容），TreeNode 会被转成 Node。当用户实现的 hashCode 方法具有良好分布性时，树类型的桶将会很少被使用。 通过上面的注释，我们可以了解到。一般情况下，只要 hashCode 的实现不糟糕，Node 组成的链表很少会被转成由 TreeNode 组成的红黑树。也就是说 TreeNode 使用的并不多，浪费那点空间是可接受的。假如 TreeNode 机制继承自 Node 类，那么它要想具备组成链表的能力，就需要 Node 去继承 LinkedHashMap 的内部类 Entry。这个时候就得不偿失了，浪费很多空间去获取不一定用得到的能力。 利用LinkedHashMap实现LRU缓存( 或者 LeetCode 第 146 题)LRU即Least Recently Used，最近最少使用，也就是说，当缓存满了，会优先淘汰那些最近最不常访问的数据。我们的LinkedHashMap正好满足这个特性，为什么呢？当我们开启accessOrder为true时，最新访问(get或者put(更新操作))的数据会被丢到队列的尾巴处，那么双向队列的头就是最不经常使用的数据了。比如: 如果有1 2 3这3个Entry，那么访问了1，就把1移到尾部去，即2 3 1。每次访问都把访问的那个数据移到双向队列的尾部去，那么每次要淘汰数据的时候，双向队列最头的那个数据不就是最不常访问的那个数据了吗？换句话说，双向链表最头的那个数据就是要淘汰的数据。 此外，LinkedHashMap还提供了一个方法，这个方法就是为了我们实现LRU缓存而提供的，removeEldestEntry(Map.Entry eldest) 方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回 false。 来，给大家一个简陋的LRU缓存: 1234567891011121314151617public class LRUCache extends LinkedHashMap&#123; public LRUCache(int maxSize) &#123; super(maxSize, 0.75F, true); maxElements = maxSize; &#125; protected boolean removeEldestEntry(java.util.Map.Entry eldest) &#123; //逻辑很简单，当大小超出了Map的容量，就移除掉双向队列头部的元素，给其他元素腾出点地来。 return size() &gt; maxElements; &#125; private static final long serialVersionUID = 1L; protected int maxElements;&#125; ConcurrentHashMap参考ConcurrentHashMap 源码分析 并发容器之ConcurrentHashMap(JDK 1.8版本) 写的最好！ 死磕 ConcurrentHashMap Java 8 ConcurrentHashMap源码分析 ConcurrentHashMap 详解一 java并发之ConcurrentHashMap 1.8原理详解 写的也非常有深度，可惜排版很差！！！ 写得好 主要就是参考上面三个自己觉得写得好的！ 概述在使用 HashMap 时在多线程情况下扩容会出现 CPU 接近 100%的情况，因为 hashmap 并不是线程安全的，通常我们可以使用在 java 体系中古老的 hashtable 类，该类基本上所有的方法都采用 synchronized 进行线程安全的控制，可想而知，在高并发的情况下，每次只有一个线程能够获取对象监视器锁，这样的并发性能的确不令人满意。另外一种方式通过 Collections 的Map synchronizedMap(Map m)将 hashmap 包装成一个线程安全的 map。比如 SynchronzedMap 的 put 方法源码为： 123public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125;&#125; 实际上 SynchronizedMap 实现依然是采用 synchronized 独占式锁进行线程安全的并发控制的。同样，这种方案的性能也是令人不太满意的。针对这种境况，Doug Lea 大师不遗余力的为我们创造了一些线程安全的并发容器，让每一个 java 开发人员倍感幸福。相对于 hashmap 来说，ConcurrentHashMap 就是线程安全的 map，其中利用了锁分段的思想提高了并发度。 ConcurrentHashMap 在 JDK1.6 的版本网上资料很多，有兴趣的可以去看看。 JDK 1.6 版本关键要素： segment 继承了 ReentrantLock 充当锁的角色，为每一个 segment 提供了线程安全的保障； segment 维护了哈希散列表的若干个桶，每个桶由 HashEntry 构成的链表。 而到了 JDK 1.8 的 ConcurrentHashMap 就有了很大的变化，光是代码量就足足增加了很多。1.8 版本舍弃了 segment，并且大量使用了 synchronized，以及 CAS 无锁操作以保证 ConcurrentHashMap 操作的线程安全性。至于为什么不用 ReentrantLock 而是 Synchronzied 呢？实际上，synchronzied 做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用 synchronized 相较于 ReentrantLock 的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。 作者: 你听___链接：https://juejin.im/post/5aeeaba8f265da0b9d781d16来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 与HashMap区别线程安全 与 非线程安全 的区别 关键属性和类table所有数据都存在table中，table的容量会根据实际情况进行扩容，table[i]存放的数据类型有以下3种： TreeBin 用于包装红黑树结构的结点类型 ForwardingNode 扩容时存放的结点类型，并发扩容的实现关键之一 Node 普通结点类型，表示链表头结点 作为 ConcurrentHashMap 的数据容器，采用 懒加载 的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为 2 的幂次方。 nextTable12//扩容时使用，平时为 null，只有在扩容的时候才为非 nullvolatile Node&lt;K,V&gt;[] nextTable; sizeCtl1private transient volatile int sizeCtl; 控制标识符，用来控制table的初始化和扩容的操作，不同的值有不同的含义： 当为负数时：-1代表正在初始化，-N代表有N-1个线程正在 进行扩容 当为0时：代表当时的table还没有被初始化 当为正数时：表示初始化或者下一次进行扩容的大小 sizeCtl 变量担当了 5 种角色， 设计非常精巧 ① 首次初始化时， 其变量含义为初始容量 ② 扩容以后， 其值为触发下一次扩容的元素数量阈值 ③ 其正负状态， 标识了当前数组是否处于扩容状态 ④ sizeCtl 为负值时，高16位bit反映了正在进行的扩容操作是针对哪个容量进行的 ⑤ sizeCtl 为负值时, 低 16位bit 反映了参与此次扩容的线程有多少个 1234567891011if table未完成初始化: sizeCtl = 0 //未指定初始容量时的默认值 sizeCtl &gt; 0 //指定初始容量(非传入值，是2的幂次修正值)大小的两倍 sizeCtl =- 1 //表明table正在初始化else if nextTable为空: if 扩容时发生错误(如内存不足、table.length * 2 &gt; Integer.MAX_VALUE等): sizeCtl = Integer.MAX_VALUE //不必再扩容了！ else: sizeCtl = table.length * 0.75 //扩容阈值调为table容量大小的0.75倍else: sizeCtl = -(1+N) //N的低RESIZE_STAMP_SHIFT位表示参与扩容线程数，后面详细介绍 sun.misc.Unsafe U在 ConcurrentHashMapde 的实现中可以看到大量的 U.compareAndSwapXXXX 的方法去修改 ConcurrentHashMap 的一些属性。这些方法实际上是利用了 CAS 算法 保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而 CAS 操作依赖于现代处理器指令集，通过底层CMPXCHG指令实现。CAS(V,O,N)核心思想为：若当前变量实际值 V 与期望的旧值 O 相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值 N 赋值给变量；若当前变量实际值 V 与期望的旧值 O 不相同，则表明该变量已经被其他线程做了处理，此时将新值 N 赋给变量操作就是不安全的，在进行重试。而在大量的同步组件和并发容器的实现中使用 CAS 是通过sun.misc.Unsafe类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为 java 中的“指针”。该成员变量的获取是在静态代码块中： 12345678static &#123; try &#123; U = sun.misc.Unsafe.getUnsafe(); ....... &#125; catch (Exception e) &#123; throw new Error(e); &#125;&#125; 在 ConcurrentHashMap 中，主要用到 CAS 算法的有三个方法： tabAt 123static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125; 该方法用来获取 table 数组中索引为 i 的 Node 元素。 casTabAt 1234static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125; 基于 CAS 尝试更新 table 上下标为 i 的结点的值为 v。 setTabAt 123static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125; 用于设置 table 上下标为 i 的结点为 v，相对于 casTabAt 方法的区别在于不关注历史值。 NodeNode 类实现了 Map.Entry 接口，主要存放 key-value 对，并且具有 next 域，另外可以看出很多属性都是用 volatile 进行修饰的，也就是为了保证内存可见性。 1234567static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; ......&#125; TreeNode树节点，继承于承载数据的 Node 类。而红黑树的操作是针对 TreeBin 类的，从该类的注释也可以看出，也就是 TreeBin 会将 TreeNode 进行再一次封装 1234567891011** * Nodes for use in TreeBins */static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; ......&#125; TreeBin这个类并不负责包装用户的 key、value 信息，而是包装的很多 TreeNode 节点。实际的 ConcurrentHashMap“数组”中，存放的是 TreeBin 对象，而不是 TreeNode 对象。 1234567891011static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; root; volatile TreeNode&lt;K,V&gt; first; volatile Thread waiter; volatile int lockState; // values for lockState static final int WRITER = 1; // set while holding write lock static final int WAITER = 2; // set when waiting for write lock static final int READER = 4; // increment value for setting read lock ......&#125; ForwardingNode在扩容时才会出现的特殊节点，在转移的时候放在头部的节点，是一个空节点，其 key,value,hash 全部为 null。并拥有 nextTable 指针引用新的 table 数组。 12345678static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; final Node&lt;K,V&gt;[] nextTable; ForwardingNode(Node&lt;K,V&gt;[] tab) &#123; super(MOVED, null, null, null); this.nextTable = tab; &#125; .....&#125; 部分 final 常量1234567891011121314151617181920212223242526272829// node数组最大容量：2^30=1073741824,因为第一位是符号位，所以是 30 次幂private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默认初始值，必须是2的幂数private static final int DEFAULT_CAPACITY = 16;//数组可能最大值，需要与toArray（）相关方法关联static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//并发级别，遗留下来的，为兼容以前的版本private static final int DEFAULT_CONCURRENCY_LEVEL = 16;// 负载因子private static final float LOAD_FACTOR = 0.75f;// 链表转红黑树阀值,&gt; 8 链表转换为红黑树static final int TREEIFY_THRESHOLD = 8;//树转链表阀值，小于等于6（tranfer时，lc、hc=0两个计数器分别++记录原bin、新binTreeNode数量，&lt;=UNTREEIFY_THRESHOLD 则untreeify(lo)）static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64;private static final int MIN_TRANSFER_STRIDE = 16;private static int RESIZE_STAMP_BITS = 16;// 2^15-1，help resize的最大线程数private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;// 32-16=16，sizeCtl中记录size大小的偏移量private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS;// forwarding nodes的hash值static final int MOVED = -1; // 树根节点的hash值static final int TREEBIN = -2; // ReservationNode的hash值static final int RESERVED = -3; // 可用处理器数量static final int NCPU = Runtime.getRuntime().availableProcessors(); 主要方法构造函数在使用 ConcurrentHashMap 第一件事自然而然就是 new 出来一个 ConcurrentHashMap 对象，一共提供了如下几个构造器方法： 1234567891011// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16ConcurrentHashMap()// 2. 给定map的大小ConcurrentHashMap(int initialCapacity)// 3. 给定一个mapConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)// 4. 给定map的大小以及加载因子ConcurrentHashMap(int initialCapacity, float loadFactor)// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程，jdk1.8基本不用）ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)复制代码 ConcurrentHashMap 一共给我们提供了 5 中构造器方法，具体使用请看注释，我们来看看第 2 种构造器，传入指定大小时的情况，该构造器源码为： 123456789101112public ConcurrentHashMap(int initialCapacity) &#123; //1. 小于0直接抛异常 if (initialCapacity &lt; 0) throw new IllegalArgumentException(); //2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理 // 至于为什么这样取这个值...暂时我还没搞懂，后面也有tryPresize()也是这样 int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); //3. 赋值给sizeCtl this.sizeCtl = cap;&#125; 这段代码的逻辑请看注释，很容易理解，如果小于 0 就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将 cap 赋值给 sizeCtl,关于 sizeCtl 的说明请看上面的说明，当调用构造器方法之后，sizeCtl 的大小应该就代表了 ConcurrentHashMap 的大小，即 table 数组长度。tableSizeFor 做了哪些事情了？源码为： 12345678910111213/** * Returns a power of two table size for the given desired capacity. * See Hackers Delight, sec 3.2 */private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个 2 的幂次方数，也就是说 ConcurrentHashMap 的大小一定是 2 的幂次方，比如，当指定大小为 18 时，为了满足 2 的幂次方特性，实际上 concurrentHashMapd 的大小为 2 的 5 次方（32）。另外，需要注意的是，调用构造器方法的时候并未构造出 table 数组（可以理解为 ConcurrentHashMap 的数据容器），只是算出 table 数组的长度，当第一次向 ConcurrentHashMap 插入数据的时候才真正的完成初始化创建 table 数组的工作。 初始化table整体流程如下： 判断 sizeCtl 值是否小于 0，如果小于 0 则表示 ConcurrentHashMap 正在执行初始化操作，所以需要先等待一会，如果其它线程初始化失败还可以顶替上去 如果 sizeCtl 值大于等于 0，则基于 CAS 策略抢占标记 sizeCtl 为 -1，表示 ConcurrentHashMap 正在执行初始化，然后构造 table，并更新 sizeCtl 的值 1234567891011121314151617181920212223242526private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0) // 1. 保证只有一个线程正在进行初始化操作，发现sizeCtl为负数时，得让出时间片等待 Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; // 2. 得出数组的大小 int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") // 3. 这里才真正的初始化数组 Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; // 4. 计算数组中可用的大小：实际大小n*0.75（加载因子） sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; put() 【重点，有很多引申，包括扩容】先放源码，然后我们慢慢来分析一波，这是整个 ConcurrentHashMap() 的核心，我们以点推面，将 put() 用到的比较有代表性的函数都挑出来讲一讲！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public V put(K key, V value) &#123; return putVal(key, value, false);&#125;/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); //1.两次hash，减少hash冲突，可以均匀分布，后面会讲 int binCount = 0; //用于记录元素个数,也就是链表长度 for (Node&lt;K,V&gt;[] tab = table;;) &#123; //对这个table进行迭代 Node&lt;K,V&gt; f; int n, i, fh; //2.这里就是上面构造方法没有进行初始化，在这里进行判断，为null就调用initTable进行初始化，属于懒汉模式初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); //上面已经讲过了 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;//3.如果i位置没有数据，就直接无锁CAS插入,上文已经讲过了 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED)//4.如果在进行扩容(当前节点是forwardingNode)，则先进行扩容操作 tab = helpTransfer(tab, f); //后面会详解 else &#123; V oldVal = null; //5.如果以上条件都不满足，那就要进行加锁操作，即存在hash冲突，锁住链表或者红黑树的头结点 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; //f改变再次循环 if (fh &gt;= 0) &#123; //表示该节点是链表结构(红黑树 -2，或者正在转移都为负数) binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; //这里涉及到相同的key进行put就会覆盖原先的value if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) //只有不存在的时候才插入 e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; //插入链表尾部 pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123;//红黑树结构 Node&lt;K,V&gt; p; binCount = 2; //红黑树结构旋转插入 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; //6.如果链表的长度大于8时就会进行红黑树的转换 if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount);//7.统计size，并且检查是否需要扩容 return null; 故整个 put() 的流程分为 7 步： 1.调用 spread()，进行两次哈希 2.如果没有初始化就先调用 initTable() 方法来进行初始化过程 3.如果没有hash冲突就直接 CAS 插入 4.如果还在进行扩容操作就先进行扩容 5.如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入， 6.最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环 7.如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容 接下来针对每一步进行细致的分析，包括内部函数的具体实现！ spread()首先是 spread() 函数！先上源码！ 1234static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hashstatic final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; 就是我们在 HashMap 章节讲过的，将 hashcode 值的低16位和高16位 相异或，也称之为 扰动函数！ initTable() &amp; tabAt() &amp; casTabAt()上文已经讲过这三个函数了，让我们 go on！！ helpTransfer()如果在进行扩容，则先进行扩容操作，这个函数就是帮助扩容的！这样可以提高扩容的速度！ 该方法的主要作用就是基于 CAS 尝试添加一个线程去协助扩容操作，如果能够成功加入则将 sizeCtl 值加 1。方法 transfer 是真正执行扩容操作的地方，并在多个步骤中被触发。这里先给出该方法的定义（如下），具体的实现后面会专门进行分析，该方法接收 2 个参数，其中 tab 是当前需要被扩容的 table，而 nextTab 是扩容之后的 table，容量上是之前的两倍，helpTransfer 传递的 nextTab 是一个非 null 值，因为触发 helpTransfer 的前提就是当前已经处于扩容阶段。 1234567891011121314151617181920212223242526272829303132 /** * Helps transfer if a resize is in progress. * 帮助从旧的table的元素复制到新的table中 */final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; // 新的table nextTab已经存在前提下才能帮助扩容 // 当前结点是 ForwardingNode 类型 if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; int rs = resizeStamp(tab.length); // 下面会讲，扩容戳 while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; // 条件1判断是否为当前扩容戳 // 条件2判断是否扩容结束 // 条件3判断扩容线程是否已经超过最大并发扩容线程数 (这其实是一个bug,见下面详解) // 条件4判断当前是否有可以分配的任务 // sc=((rs=resizeStamp())&lt;&lt;&lt;RESIZE_STAMP_SHIFT ) // sc 高16位用于记录本次扩容戳,低16位用于记录扩容线程数量,rs = sc - 1 if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; // 基于 CAS 将 扩容线程数 + 1，说明又有一个线程加入扩容了 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab);// 调用扩容方法，扩容最核心的函数 break; &#125; &#125; return nextTab; &#125; return table;&#125; 在 helptransfer() 中，调用了 resizeStamp() 函数(当然还有 transfer()，这个是扩容核心代码，下面单独会拎出来讲)，我们现在分析一下这两个函数！ 123456789 /* ---------------- Table Initialization and Resizing -------------- */// 生成表的扩容戳，每个n都有不同的扩容戳 /** * Returns the stamp bits for resizing a table of size n. * Must be negative when shifted left by RESIZE_STAMP_SHIFT. */ static final int resizeStamp(int n) &#123; return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)); &#125; Integer.numberOfLeadingZeros(n) 在指定 int 值的二进制补码表示形式中最高位（最左边）的 1 位之前，返回零位的数量。具体我也不懂啥意思，反正就是会生成一个特殊的扩容戳！ treeifyBin()来到这里，就是 put() 的第六步了，上源码！ 12345678910111213141516171819202122232425262728293031private final void treeifyBin(Node&lt;K, V&gt;[] tab, int index) &#123; Node&lt;K, V&gt; b; int n, sc; if (tab != null) &#123; // 1. 如果 table 长度小于 64，执行扩容操作 if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123; this.tryPresize(n &lt;&lt; 1); &#125; // 2. 否则，将链表转换成红黑树 else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; // 头结点 hash 大于 0，说明是链表 synchronized (b) &#123; if (tabAt(tab, index) == b) &#123; TreeNode&lt;K, V&gt; hd = null, tl = null; // 将链表转换成一棵红黑树 for (Node&lt;K, V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K, V&gt; p = new TreeNode&lt;&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) &#123; hd = p; &#125; else &#123; tl.next = p; &#125; tl = p; &#125; // 将红黑树设置到 table 对应的位置 // 注意哦，数组中存储的可是 TreeBin setTabAt(tab, index, new TreeBin&lt;&gt;(hd)); &#125; &#125; &#125; &#125;&#125; 细心的小伙伴发现了，这里又有一个扩容操作的函数 tryPresize() ，来，咱不能放过它，进去看看！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private final void tryPresize(int size) &#123; // 如果当前期望的大小（size）小于最大允许容量的一半，则扩容大小为 size 的 1.5 倍加 1，在向上取最小的 2 次幂,注意哦，这里的 size 传进来的时候就已经是原数组的两倍大小了！！！ // 这里我没搞清他要干嘛... 因为 c 可是一次性扩了好多倍 // 真正去执行扩容的还是 transfer 这个函数 int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1); int sc; while ((sc = sizeCtl) &gt;= 0) &#123; // 检查当前未处于扩容阶段 Node&lt;K, V&gt;[] tab = table; int n; // 初始化 nextTable if (tab == null || (n = tab.length) == 0) &#123; n = (sc &gt; c) ? sc : c; if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if (table == tab) &#123; @SuppressWarnings("unchecked") Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) new Node&lt;?, ?&gt;[n]; table = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; &#125; &#125; else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) &#123; break; &#125; else if (tab == table) &#123; int rs = resizeStamp(n); // 2. 基于 CAS 将 sc 的值加 1，然后执行 transfer 方法 if (sc &lt; 0) &#123; Node&lt;K, V&gt;[] nt; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) &#123; break; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; // 执行 transfer 方法 this.transfer(tab, nt); &#125; &#125; // 1. 基于 CAS 将 sizeCtl 的值设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2 else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) &#123; // 执行 transfer 方法，此时 nextTable 是 null this.transfer(tab, null); &#125; &#125; &#125;&#125; 该方法的核心操作在于最后一个添加 transfer 任务，并设置 sizeCtl 值，该方法第一次调用 transfer 方法时 sizeCtl 一定是大于等于 0 的，所以方法会尝试将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，这是大负数，并执行 transfer(tab, null) 操作，后面的循环 sizeCtl 均小于 0，所以会执行 transfer(tab, nt)，并将 sizeCtl 加 1。注意整个过程中 sizeCtl 值的变化，在一次扩容操作中第一次调用 transfer 方法时将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，并在扩容过程再次调用 transfer 方法时将 sizeCtl 加 1。这对于下一节理解扩容操作什么时候结束至关重要。 transfer()来了，它终于来了…在之前我们已经铺垫了很久了，本来是打算再放到后面一点的，因为在 put() 的第七步 addCount() 方法中也调用了这个方法，但是… 我忍不住了！！！ 在讲 transfer() 之前，我们来回顾一下总共有哪些函数调用了它，也就是我们需要在什么时候扩容呢？ helpTransfer()。当一个线程要对table中元素进行操作的时候，如果检测到节点的HASH值为MOVED的时候，就会调用helpTransfer方法，在helpTransfer中再调用transfer方法来帮助完成数组的扩容。 tryPresize()。treeIfybin 和 putAll 方法中调用，treeIfybin 主要是在put添加元素完之后，判断该数组节点相关元素是不是已经超过8个的时候，如果超过则会调用这个 tryPresize 方法来扩容数组或者把链表转为树。 addCount()。当对数组进行操作，使得数组中存储的元素个数发生了变化的时候会调用的方法。 总结一下，也就是两种情况： 只有在往map中添加元素的时候，在某一个节点的数目已经超过了8个，同时数组的长度又小于64的时候，才会触发数组的扩容。 当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容。 扩容操作简单地说就是新建一个长度翻倍的 nextTable，然后将之前 table 上的结点重新哈希迁移到新的 nextTable 上，并在迁移完成之后使用 nextTable 替换原先的 table。对于一个 table 而言，上面分布着 n 个 bin 结点，而结点迁移的过程可以是并发的，这样可以提升迁移的效率。ConcurrentHashMap 使用了一个 stride 变量用于指定将 stride 个 bin 结点组成一个任务单元由一个线程负责处理，在单核 CPU 下 stride 的值为 table 的长度 n，在多核 CPU 下为 (n &gt;&gt;&gt; 3) / NCPU，最小值为 16。 ConcurrentHashMap 定义了一个类实例变量 transferIndex，用于指定任务的边界。任务划分的过程在 table 上是从后往前进行的，例如现在有 n 个结点，则编号 （n-1-stride, ..., n-1） 的任务交给第 1 个线程进行处理，编号 （n-1-2*stride, ..., n-1-stride） 的任务交给第 2 个线程进行处理，以此类推。当有新的线程加入时可以依据 transferIndex 值知道接下去应该分配哪一块的 bin 结点给当前线程。 具体代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203private final void transfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab) &#123; int n = tab.length, stride; /* * stride 即步进， * 在单核下为 table 的长度 n，在多核模式下为 (n &gt;&gt;&gt; 3) / NCPU，最小值为 16 */ // 每核处理的量小于16，则强制赋值16 // NCPU为CPU核心数，每个核心均分复制任务，如果均分小于16个，那么以16为步长分给处理器 // 例如0-15号给处理器1，16-32号分给处理器2。处理器3就不用接任务了。 if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) &#123; stride = MIN_TRANSFER_STRIDE; // subdivide range &#125; // 1. 如果 nextTable 未初始化，则先进行初始化，容量是之前的两倍 // 如果nextTab为空则初始化为原tab的两倍，这里只会有单线程进得来，因为初始化nextTab只需要一个， // addcount里面判断了nextTab为空则不执行扩容任务 if (nextTab == null) &#123; try &#123; @SuppressWarnings("unchecked") Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) new Node&lt;?, ?&gt;[n &lt;&lt; 1]; // 容量翻倍 nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; //扩容总进度，transferIndex之后的桶都已分配出去,因为是倒序分配 &#125; // 2. 执行迁移工作 int nextn = nextTab.length; // ForwardingNode 表示一个正在被迁移的结点，对应的 hash 值是 MOVED ForwardingNode&lt;K, V&gt; fwd = new ForwardingNode&lt;&gt;(nextTab); boolean advance = true; // 标记一个结点是否迁移完成 boolean finishing = false; // 标记扩容任务是否完成 // i 是索引，bound 是边界值（左边界值），从后往前迁移 for (int i = 0, bound = 0; ; ) &#123; Node&lt;K, V&gt; f; int fh; /* * 2.1 基于 CAS 计算本次任务的边界值，即 i 和 bound 值， * 将 i 指向 transferIndex，将 bound 指向 transferIndex - stride */ while (advance) &#123; int nextIndex, nextBound; // 标记当前结点迁移完成 if (--i &gt;= bound || finishing) &#123; advance = false; &#125; // 一旦 transferIndex &lt;= 0，表示所有任务已经分配给相应的线程进行处理 else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; // 分配完成，下面直接执行迁移任务 advance = false; &#125; // 基于 CAS 计算 transferIndex 值（即 transferIndex - stride） // nextBound 是本次任务的边界 //确定当前线程每次分配的待迁移桶的范围[bound, nextIndex) //每个线程执行完之前的任务以后会走这个分支继续获取新的任务,直到所有任务都分配完毕 else if (U.compareAndSwapInt( this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; // ~end while /* * 2.2 执行迁移任务 */ if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; // 完成了所有结点的迁移 if (finishing) &#123; nextTable = null; table = nextTab; // 更新 table 为 nextTable sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); // sizeCtl 值更新为 table 长度的 1.5 倍 return; &#125; // 任务继续 /* * 基于 CAS 将 sizeCtl 减 1 * 在迁移操作开始前会将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，每一个线程加入迁移任务就会将 sizeCtl 加 1， * 所以这里执行 sizeCtl 减 1，代表当前任务完成 */ if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123; // 当前任务结束，但是整体任务还未完成 return; &#125; // 此时 sizeCtl == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，说明所有的任务都执行完了 finishing = advance = true; i = n; // recheck before commit,再次检查一下整张表 &#125; &#125; // 否则，获取 table 中位置为 i 的头结点，且为 null else if ((f = tabAt(tab, i)) == null) &#123; // 在当前位置设置一个空的 ForwardingNode 节点 advance = casTabAt(tab, i, null, fwd); &#125; // 否则，当前位置已经是一个 ForwardingNode，代表正在执行迁移工作 else if ((fh = f.hash) == MOVED) &#123; advance = true; // already processed &#125; // 否则，开始对当前结点执行迁移工作 else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; // 再次校验结点 Node&lt;K, V&gt; ln, hn; // 当前 bin 是一个链表 if (fh &gt;= 0) &#123; int runBit = fh &amp; n; // n 为老 table 的长度 Node&lt;K, V&gt; lastRun = f; // 遍历当前链表，找到最后 p.hash &amp; n 值相同的第一个结点 for (Node&lt;K, V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; // runBit == 0 表示还在老 table 原先的位置 if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; // 此处 runBit 等于老 table 的长度，即 n else &#123; hn = lastRun; ln = null; &#125; // 以 lastRun 为界 for (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) &#123; ln = new Node&lt;&gt;(ph, pk, pv, ln); &#125; else &#123; hn = new Node&lt;&gt;(ph, pk, pv, hn); &#125; &#125; // 将其中一个链表放置在 nextTable 的 i 位置 setTabAt(nextTab, i, ln); // 将另外一个链表放置在 nextTable 的 i+n 位置 setTabAt(nextTab, i + n, hn); // 设置当前 table 的 i 位置为 ForwardingNode 空结点，代表已经处理完 setTabAt(tab, i, fwd); advance = true; &#125; // 当前 bin 是一颗红黑树 else if (f instanceof TreeBin) &#123; TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f; TreeNode&lt;K, V&gt; lo = null, loTail = null; TreeNode&lt;K, V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K, V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K, V&gt; p = new TreeNode&lt;&gt;(h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) &#123; lo = p; &#125; else &#123; loTail.next = p; &#125; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) &#123; hi = p; &#125; else &#123; hiTail.next = p; &#125; hiTail = p; ++hc; &#125; &#125; /* 如果将红黑树一分为二后，结点数目小于 6，则将红黑树转换成链表 */ ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;&gt;(hi) : t; // 将其中一个红黑树（或链表）放置在 nextTable 的 i 位置 setTabAt(nextTab, i, ln); // 将另外一个红黑树（或链表）放置在 nextTable 的 i+n 位置 setTabAt(nextTab, i + n, hn); // 设置当前 table 的 i 位置为 ForwardingNode 空结点，代表已经处理完 setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125;&#125; 方法的实现很复杂，不过整体流程可以概括为 2 大部分： 如果 nextTable 未初始化，则先执行初始化操作，新的 table 容量翻倍 执行迁移任务 其中过程 1 比较简单，不过需要注意的是并不是所有触发 transfer 方法都需要执行初始化 table 的操作，只有主动触发扩容的线程需要执行该操作，对于后来加入“帮忙”的线程会跳过过程 1，直接进入过程 2。 过程 2 通过 transferIndex 实例变量协调任务的分配，并为每个线程分配 stride 个结点进行迁移，任务分配的过程实际上就是确定当前线程迁移结点的上下界的过程，该过程位于 while 循环中（即代码注释 2.1），该循环整体上就是一个 CAS 操作，如果迁移任务已经完成，或者没有剩余的结点可以迁移（实例变量 transferIndex 小于等于 0），则退出 CAS，否则尝试为本次任务分配新的上下界，同时更新 transferIndex 值。 接下来正式开始迁移工作，整体流程可以概括为： 检查整体迁移任务是否完成，如果完成则更新 table 和 sizeCtl 值 否则，检查当前任务是否已经完成，如果完成则退出本次任务 对于仍在进行中的任务会继续执行迁移操作，如果当前结点是一个空结点，则在该位置设置一个空的 ForwardingNode 结点，用于标记当前结点正在迁移中 否则，如果当前结点是一个 ForwardingNode 结点，即当前结点正在迁移中，进入下一轮任务分配 否则，对当前结点执行迁移操作 下面针对流程中的一些关键点进行说明，首先来看一下过程 2 相关的代码： 123456789101112131415/* * 基于 CAS 将 sizeCtl 减 1 * 在迁移操作开始前会将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，每一个线程加入迁移任务就会将 sizeCtl 加 1， * 前面两个调用 transfer函数的，在调用之前都会先加 sizeCtl + 1 * 所以这里执行 sizeCtl 减 1，代表当前任务完成 */if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123; // 当前任务结束，但是整体任务还未完成 return; &#125; // 此时 sizeCtl == (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，说明所有的任务都执行完了 finishing = advance = true; i = n; // recheck before commit&#125; 前面我们曾提到当新增一个线程支持迁移任务时会执行 U.compareAndSwapInt(this, SIZECTL, sc, sc + 1) 操作，并且在扩容操作开始前会设置 sizeCtl 的值为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，而这里在完成一个任务的时候会执行 U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1) 操作将 sizeCtl 的值减 1。上面的代码会判定当前 sizeCtl 值是否等于 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2，如果相等则说明整体扩容任务完成，否则仅说明当前任务完成，将线程任务数减 1。 接下来我们继续来看一个结点迁移的过程，迁移区分链表和红黑树，不过基本思想是想通的，这里以链表进行说明，相关实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041// 当前 bin 是一个链表if (fh &gt;= 0) &#123; int runBit = fh &amp; n; // n 为老 table 的长度 Node&lt;K, V&gt; lastRun = f; // 遍历当前链表，找到最后 p.hash &amp; n 值相同的第一个结点 for (Node&lt;K, V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; // runBit == 0 表示还在老 table 原先的位置 if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; // 此处 runBit 等于老 table 的长度，即 n else &#123; hn = lastRun; ln = null; &#125; // 以 lastRun 为界 for (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) &#123; ln = new Node&lt;&gt;(ph, pk, pv, ln); &#125; else &#123; hn = new Node&lt;&gt;(ph, pk, pv, hn); &#125; &#125; // 将其中一个链表放置在 nextTable 的 i 位置 setTabAt(nextTab, i, ln); // 将另外一个链表放置在 nextTable 的 i+n 位置 setTabAt(nextTab, i + n, hn); // 设置当前 table 的 i 位置为 ForwardingNode 空结点，代表已经处理完 setTabAt(tab, i, fwd); advance = true;&#125; 这一段代码如果希望更好的理解，建议自己模拟一个 table，并 debug 一下执行流程。其实也不难，这段代码的工作就是将一个链表的拆分成两个链表，并将它们插入到新 table 适当的位置。假设老的 table 长度为 16，那么上面的实现有一个巧妙的地方在于对链表中所有结点的哈希值执行 p.hash &amp; n 操作，其结果不是 0 就是 16（老 table 的长度），所以我们可以依据 p.hash &amp; n 的值将一个链表拆分成两个链表，其中值均为 0 的结点构成的链表仍然放置在新 table 的当前位置 i，而值均为 16 的结点构成的链表则放置在新的位置，即 i + 16。变量 lastRun 所表示的结点实际上是最后几个具备相同 p.hash &amp; n 值的连续结点的最左边结点，因为这样可以减少该结点右边几个结点的迁移工作，因为它们具备相同的 p.hash &amp; n 值，自然也就位于同一个链表上。 addCount()在 put 方法结尾处调用了 addCount 方法，把当前 ConcurrentHashMap 的元素个数+1， 这个方法一共做了两件事,更新 baseCount 的值，检测是否进行扩容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 从 putVal 传入的参数是 1//binCount，binCount 默认是0，只有 hash 冲突了才会大于 1.且他的大小是链表的长度（如果不是红黑数结构的话）private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; //利用CAS方法更新baseCount的值 // 如果计数盒子不是空 或者 // 如果修改 baseCount 失败 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; // 如果计数盒子是空（尚未出现并发） // 如果随机取余一个数组位置为空 或者 // 修改这个槽位的变量失败（出现并发了） // 执行 fullAddCount 方法。并结束 if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; // 如果需要检查,检查是否需要扩容，在 putVal 方法调用时，默认就是要检查的。 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; // 如果map.size() 大于 sizeCtl（达到扩容阈值需要扩容） 且 // table 不是空；且 table 的长度小于 1 &lt;&lt; 30。（可以扩容） while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; // 根据 length 得到一个标识 int rs = resizeStamp(n); // 如果正在扩容 if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; // 如果已经有其他线程在执行扩容操作 // 可以帮助扩容，那么将 sc 加 1. 表示多了一个线程在帮助扩容 if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) // 扩容 transfer(tab, nt); &#125; // 如果不在扩容，将 sc 更新：标识符左移 16 位 然后 + 2. 也就是变成一个负数。高 16 位是标识符，低 16 位初始是 2. else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) // 更新 sizeCtl 为负数后，开始扩容。 transfer(tab, null); s = sumCount(); &#125; &#125;&#125; 总结一下该方法的逻辑： x 参数表示的此次需要对表中元素的个数加几。check 参数表示是否需要进行扩容检查，大于等于0 需要进行检查，而我们的 putVal 方法的 binCount 参数最小也是 0 ，因此，每次添加元素都会进行检查。（除非是覆盖操作） 判断计数盒子属性是否是空，如果是空，就尝试修改 baseCount 变量，对该变量进行加 X。 如果计数盒子不是空，或者修改 baseCount 变量失败了，则放弃对 baseCount 进行操作。 如果计数盒子是 null 或者计数盒子的 length 是 0，或者随机取一个位置取于数组长度是 null，那么就对刚刚的元素进行 CAS 赋值。 如果赋值失败，或者满足上面的条件，则调用 fullAddCount 方法重新死循环插入。 这里如果操作 baseCount 失败了（或者计数盒子不是 Null），且对计数盒子赋值成功，那么就检查 check 变量，如果该变量小于等于 1. 直接结束。否则，计算一下 count 变量。 如果 check 大于等于 0 ，说明需要对是否扩容进行检查。 如果 map 的 size 大于 sizeCtl（扩容阈值），且 table 的长度小于 1 &lt;&lt; 30，那么就进行扩容。 根据 length 得到一个标识符，然后，判断 sizeCtl 状态，如果小于 0 ，说明要么在初始化，要么在扩容。 如果正在扩容，那么就校验一下数据是否变化了（具体可以看上面代码的注释）。如果检验数据不通过，break。 如果校验数据通过了，那么将 sizeCtl 加一，表示多了一个线程帮助扩容。然后进行扩容。 如果没有在扩容，但是需要扩容。那么就将 sizeCtl 更新，赋值为标识符左移 16 位 —— 一个负数。然后加 2。 表示，已经有一个线程开始扩容了。然后进行扩容。然后再次更新 count，看看是否还需要扩容。 从上面的分析中我们可以看，addCount()是扩容是老老实实按容量x2来扩容的，tryPresize()会传入一个size参数，可能一次性扩容很多倍。后面采用一样的方式调用transfer()来进行真正的扩容处理。 作者：exposure链接：https://juejin.im/post/5c36bcc0e51d45513236ee78来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 get()方法 put 的执行流程可以加深我们对于 ConcurrentHashMap 存储结构的理解，而理解了 ConcurrentHashMap 的存储结构，那么分析 get 方法的运行机制也是水到渠成的事情，实现如下： 12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; e, p; int n, eh; K ek; // 计算 key 的 hash 值 int h = spread(key.hashCode()); // table 表不为空，且 key 对应的 table 头结点存在 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) &#123; // 找到对应的 key，返回 value return e.val; &#125; &#125; // 当前 bin 为树，执行 find 方法检索 else if (eh &lt; 0) &#123; return (p = e.find(h, key)) != null ? p.val : null; &#125; // 当前 bin 是链表，直接遍历检索 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; return e.val; &#125; &#125; &#125; return null;&#125; 方法首先依据相同的实现计算 key 的哈希值，然后定位 key 在 table 中的 bin 位置。如果 bin 结点存在，则依据当前 bin 类型（链表或红黑树）检索目标值。 HashTable由于这个基本已经被淘汰了…所以就不再进行系统的源码分析了。 其实 HashTable 源代码只有1000多行点，源代码很少，也基本上是 HashMap 的原来的版本加上 synchronized 关键字，每次都是锁定整个哈希表，所以效率非常低下，注意哈~ 跟 HashMap 的区别主要其基本元素还是 Entry，然后默认初始值是 11，不是 2 的幂次方，同时扩容的时候也不是按 2 的幂次方进行扩容的，而是 2 的幂次方 + 1来扩容的，并且，其扰动函数依旧是原来的 jdk7的扰动函数方式，即扰动4次，效率低下，取余也是直接取余，因为其总数不是 2 的幂次方，故不能直接相与得到哈希桶的下标值。 与HashMap区别 实现方式不一样 Hashtable继承自 Dictionary 类，而 HashMap 继承自 AbstractMap 类。但二者都实现了 Map 接口。 12public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 线程安全性不同 Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。 是否提供contains方法HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。 key和value是否允许null值 【重点！！！可以引申到 fail-fast 和 fail-safe 机制，进而引发到多线程上】 迭代器不同 HashMap 中的 Iterator 迭代器是 fail-fast 的，而 Hashtable 的 Enumerator 不是 fail-fast 的。 所以，当其他线程改变了HashMap 的结构，如：增删，将会抛出ConcurrentModificationException 异常，而 Hashtable 则不会。[fail-fast 和 fail-safe] 扩容机制不同 当现有容量大于总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 + 1。 初始化容量不同 HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。 Hash值获取不一样 HashMap 内部使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值。HashTable 是直接使用 key 的 hashCode() 返回值作为 hash 值。 HashSet &amp; TreeSet &amp; LinkedHashSetSet 的底层实现就是 Map，唯一的区别就是 Set 存的值就是 Map 的 key，value 值是一个固定值，所以…就不用分析啦！！！ 有个注意点哈~~ TreeMap 由于 key 不可以为 null，value 可以为null。所以在 TreeSet 中，就不能插入 null 元素。 相关知识点fail-fast 和 fail-safe 机制一：快速失败（fail—fast） 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。 原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。 注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。 场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。 二：安全失败（fail—safe） 采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。 缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。 场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。 快速失败和安全失败是对迭代器而言的。 快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。 安全失败：在迭代时候会在集合二层做一个拷贝，所以在修改集合上层元素不会影响下层。在java.util.concurrent下都是安全失败。 线程安全详解参考线程安全问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[二叉树专题总结]]></title>
    <url>%2F2020%2F01%2F10%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98%E9%83%A8%E5%88%86.html</url>
    <content type="text"><![CDATA[四种遍历先序、中序、后序遍历，非常简单！接下来我会用一种通用的方式完成这三种遍历哟！ 保证你看完能迅速手写三种遍历的非递归！ 先序遍历递归1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); preorderHelper(root, result); return result; &#125; private void preorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; result.add(root.val); // 访问根节点 preorderHelper(root.left, result); // 递归遍历左子树 preorderHelper(root.right, result); //递归遍历右子树 &#125;&#125; 非递归12345678910111213141516171819202122232425/** * 再写一个非递归的 * 统一先序中序后序的写法 * 从此压栈时再无左子树压栈，全部都是根节点和其右子树！ * @param root */private List&lt;Integer&gt; preorderTraversalByIteration(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); //得用一个栈来进行处理 Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty())&#123; while (cur != null)&#123; //先把根节点加入到list，然后把所有的根节点加入 //左节点其实也就是子树的根节点 res.add(cur.val); stack.push(cur); cur = cur.left; &#125; //然后拿到根节点的右子树，进行遍历 TreeNode top = stack.pop(); cur = top.right; &#125; return res;&#125; Tip: 我这里再拓展一种非递归的想法吧…但是我觉得这种想法不是很好，没有通用的非递归思想简单！强烈建议使用上面的非递归思想！！！ 至于为何非要提这种思想捏，原因就是 栈 如果换成 队列，左右节点顺序调一下，就是层序遍历了！ 思想： 上面的非递归的做法是把一棵树看做只有根节点和右节点，先全部把根节点读完了，再去读其右节点，这样也就做到了 根 - 左 - 右 下面要讲的非递归的做法是 先读根节点，然后将其加入栈，然后只要栈非空，就弹栈，将其加入需要返回的列表中，然后先将其右子树节点加入到栈中，然后将左子树节点加入到栈中，注意，这里是先右子树，后左子树，因为栈是后进先出！下一步就是左子树出栈，将其加入列表中。 12345678910111213141516class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null) return result; Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); toVisit.push(root); TreeNode cur; while (!toVisit.isEmpty()) &#123; cur = toVisit.pop(); result.add(cur.val); // 访问根节点 if (cur.right != null) toVisit.push(cur.right); // 右节点入栈 if (cur.left != null) toVisit.push(cur.left); // 左节点入栈 &#125; return result; &#125;&#125; 中序遍历递归1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); preorderHelper(root, result); return result; &#125; private void preorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; preorderHelper(root.left, result); // 递归遍历左子树 result.add(root.val); // 访问根节点 preorderHelper(root.right, result); //递归遍历右子树 &#125;&#125; 非递归123456789101112131415161718private List&lt;Integer&gt; inorderTraversalByIteration(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while(cur != null || !stack.isEmpty())&#123; while (cur != null)&#123; //左节点其实也就是子树的根节点 stack.push(cur); cur = cur.left; &#125; //从最底下的根节点开始，放入列表 TreeNode top = stack.pop(); res.add(top.val); //然后拿到根节点的右子树，进行遍历 cur = top.right; &#125; return res;&#125; 后序遍历递归1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); preorderHelper(root, result); return result; &#125; private void preorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; preorderHelper(root.left, result); // 递归遍历左子树 preorderHelper(root.right, result); //递归遍历右子树 result.add(root.val); // 访问根节点 &#125;&#125; 非递归后序非递归相对前两个遍历的非递归需要一个小技巧！ 后序是 左 - 右 - 根，反过来就是根 - 右 - 左,那其实跟先序基本就一模一样了，先序是根 - 左 - 右，所以只需要在先序的非递归中 改两行代码 + 加一行代码 就完成了！ 12345678910111213141516private List&lt;Integer&gt; postorderTraversalByIteration(TreeNode root)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); TreeNode cur = root; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(cur != null || !stack.isEmpty())&#123; while(cur != null)&#123; list.add(cur.val); stack.push(cur); cur = cur.right; &#125; TreeNode top = stack.pop(); cur = top.left; &#125; Collections.reverse(list); return list;&#125; 层序遍历层序是不是还有一个名字 叫 BFS 递归这个竟然时间和空间击败了100%的人… 莫名有点开心啊 123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; helper(root, 0, res); return res;&#125;private void helper(Node root, int depth, List&lt;List&lt;Integer&gt;&gt; res) &#123; if (root == null) return; //判断是否是新的一层 if (depth + 1 &gt; res.size()) &#123; res.add(new ArrayList&lt;&gt;()); &#125; res.get(depth).add(root.val); //处理子节点 for (Node node : root.children) &#123; if (node != null) &#123; helper(node, depth + 1, res); &#125; &#125;&#125; 非递归上面讲了一种用队列实现的非递归思想 1234567891011121314public static List&lt;Integer&gt; levelOrder(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null) return result; Queue&lt;TreeNode&gt; toVisit = new ArrayDeque&lt;&gt;(); toVisit.add(root); TreeNode cur; while (!toVisit.isEmpty()) &#123; cur = toVisit.poll(); result.add(cur.val); // 访问根节点 if (cur.left != null) toVisit.add(cur.left); // 左节点入队列 if (cur.right != null) toVisit.add(cur.right); // 右节点入队列 &#125; return result;&#125; 1234567891011121314151617181920212223242526272829/** * 非递归方法二，返回值不一样 * @param root * @return */public List&lt;List&lt;Integer&gt;&gt; levelOrderBy(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(root); TreeNode cur; while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int pre_number = queue.size(); while(pre_number &gt; 0)&#123; cur = queue.poll(); pre_number--; list.add(cur.val); if (cur.left != null)&#123; queue.add(cur.left); // 左节点入队列 &#125; if (cur.right != null) &#123; queue.add(cur.right); // 右节点入队列 &#125; &#125; res.add(list); &#125; return res;&#125; 相关题型对称二叉树题目给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 思路 先讲一下自己的思路: 利用层序非递归，用双层List存储树的节点，每一层存入一个单层List中，然后单层List可以采用二分判断是否对称！ 答案思路：树的复制，这个想法很nice！复制原树，判断其左子树节点是否和右子树节点相同且判断其左子树的左是否等于右子树的右，左子树的右是否等于右子树的左。在非递归的写法中，树的复制这种思想体现的更加明显，这个就是典型的用空间换时间！ 实现 树复制思想之递归 12345678910111213141516171819202122232425262728293031323334/** * 对称二叉树 递归做法 * 我的想法是使用层序遍历，找到对称点，每一层判断完即可！ * 结果是没写出来 * 看了答案是自己跟自己镜像比较，太妙了！！ * @param root * @return */ private static boolean isSymmetricByRecursion(TreeNode root)&#123; if (root == null) return true; return helper(root.left,root.right); &#125; /** * 递归三部曲 * 1、确定递归出口，当节点为空时，即无需再递归 * 2、确定返回值，返回值为boolean，判断当前 * 3、镜像嘿嘿，这个想法很nice * @param tree1 * @param tree2 * @return */ private static boolean helper(TreeNode tree1, TreeNode tree2) &#123; //判断是否是新的一层 if(tree1 == null &amp;&amp; tree2 == null)&#123; return true; &#125; else if(tree1 == null || tree2 == null)&#123; return false; &#125; else &#123; return tree1.val == tree2.val &amp;&amp; helper(tree1.left,tree2.right) &amp;&amp; helper(tree1.right,tree2.left); &#125; &#125; 树复制之非递归 Tip: 在复现非递归时，发现一个问题，就是Queue的实现类ArrayDeque是非线程安全的，但是其不允许存储null元素，这个跟ArrayList、LinkedList、HashMap、TreeMap等非线程安全的集合不同！！！！因为系统根据某个位置是否为null来判断元素的存在，null插入直接会报空指针异常。[ArrayDeque当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。] 所以这里使用了Queue的另外一个实现类LinkedList，它也是非线程安全的哟，但是可以存储null！！！ 123456789101112131415161718private static boolean isSymmetricByIteration(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null) return true; queue.add(root.left); queue.add(root.right); while(!queue.isEmpty())&#123; TreeNode tree1 = queue.poll(); TreeNode tree2 = queue.poll(); if(tree1 == null &amp;&amp; tree2 == null ) continue; if(tree1 == null || tree2 == null) return false; if(tree1.val != tree2.val) return false; queue.add(tree1.left); queue.add(tree2.right); queue.add(tree1.right); queue.add(tree2.left); &#125; return true;&#125; 层序非递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 迭代 * @param root * @return */ private static boolean isSymmetricByLevel(TreeNode root)&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); TreeNode cur; //得到双层list while (!queue.isEmpty()) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int pre_number = queue.size(); System.out.println(pre_number); while(pre_number &gt; 0 )&#123; cur = queue.poll(); pre_number--; if(cur == null) &#123; list.add(null); continue; &#125; list.add(cur.val); if (cur.left != null)&#123; queue.add(cur.left); // 左节点入队列 &#125; else&#123; queue.add(null); &#125; if (cur.right != null) &#123; queue.add(cur.right); // 右节点入队列 &#125; else&#123; queue.add(null); &#125; &#125; res.add(list); &#125; //对每一层list进行判断，看是否是对称的，可以使用dp for(List list:res)&#123; int size = list.size(); for(int i = 0;i &lt; size/2;i++)&#123; if(list.get(i) != list.get(size-1-i))&#123; return false; &#125; &#125; &#125; return true; &#125; 二叉树的最大深度吖！这个是二叉树最简单的题目了吧…但是绝对是一道经典好题！下面将用最常用的三种方法解决它！ 题目给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。 思路 方法一：递归。这个我在另外一篇递归中的文章中有提到，可以一行代码解决哟！ 方法二：层序遍历。即用BFS解决，每遍历完一层就记录深度。 方法三：DFS。用栈实现即可。(还学到Pair这玩意…为何我以前都不知道) 实现 递归 1、找出口，节点为空即可退出递归。 2、找返回值，返回的是该节点所在层的深度。 3、确定一次递归需要做什么。当前节点深度 = 子节点最大深度 + 1。 12345class Solution &#123; public int maxDepth(TreeNode root) &#123; return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125; BFS 层序非递归遍历，稍微改写一下就好了，这里不需要存储节点，所以只需要用一个值来记录深度即可。 第一种非递归方式改写 12345678910111213141516171819import javafx.util.Pair;class Solution &#123; public int maxDepth(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null) return 0; Queue&lt;Pair&lt;TreeNode,Integer&gt;&gt; toVisit = new ArrayDeque&lt;&gt;(); toVisit.add(new Pair&lt;&gt;(root,1)); Pair&lt;TreeNode,Integer&gt; cur; int max_depth = 0; while (!toVisit.isEmpty()) &#123; cur = toVisit.poll(); int depth = cur.getValue(); max_depth = Math.max(max_depth,depth); if (cur.getKey().left != null) toVisit.add(new Pair&lt;&gt;(cur.getKey().left,depth + 1)); // 左节点入队列 if (cur.getKey().right != null) toVisit.add(new Pair&lt;&gt;(cur.getKey().right,depth + 1)); // 右节点入队列 &#125; return max_depth; &#125;&#125; 第二种非递归方式改写 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; // List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); //这里无需存储节点，只需记录深度即可 int depth = 0; if (root == null) return depth; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.add(root); TreeNode cur; while (!queue.isEmpty()) &#123;// List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int pre_number = queue.size(); while(pre_number &gt; 0)&#123; cur = queue.poll(); pre_number--;// list.add(cur.val); //这里可以不用加入列表 if (cur.left != null)&#123; queue.add(cur.left); // 左节点入队列 &#125; if (cur.right != null) &#123; queue.add(cur.right); // 右节点入队列 &#125; &#125;// res.add(list); depth++; &#125;// return res.size(); return depth; &#125;&#125; DFS 其实就是在先序非递归的基础上稍加改动，压栈的不再只是节点，还包括了节点的深度，用Pair类型存储！ 尝试了用Map类型存储，发现行不通…因为拿不到栈顶的节点！ 123456789101112131415161718192021222324import javafx.util.Pair;class Solution &#123; public int maxDepth(TreeNode root) &#123; //得用一个栈来进行处理 Stack&lt;Pair&lt;TreeNode,Integer&gt;&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; int depth= 0; int MaxDepth = 0; while(cur != null || !stack.isEmpty())&#123; while (cur != null)&#123; //左节点其实也就是子树的根节点 depth++; stack.push(new Pair&lt;&gt;(cur,depth)); cur = cur.left; &#125; //然后拿到根节点的右子树，进行遍历 Pair&lt;TreeNode,Integer&gt; top = stack.pop(); depth = top.getValue(); MaxDepth = Math.max(depth,MaxDepth); cur = top.getKey().right; &#125; return MaxDepth; &#125;&#125; 路径总和题目给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 思路 递归。我都递归的要吐了，二叉树日常递归！ DFS，自己建栈模拟递归。 实现 递归 1 （三元表达式纯粹装逼哈哈哈） 12345678910class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; return root == null ? false : hasPathSumByRecursion(root,0,sum); &#125; private boolean hasPathSumByRecursion(TreeNode root, int total, int sum) &#123; if(root == null) return false; total = total + root.val; return (root.left == null &amp;&amp; root.right == null) ? total == sum : hasPathSumByRecursion(root.left,total,sum) || hasPathSumByRecursion(root.right,total,sum); &#125;&#125; 递归 2 12345678public boolean hasPathSum(TreeNode root,int sum)&#123; if(root == null) return false; sum-=root.val; if(root.left == null &amp;&amp; root.right == null)&#123; return sum == 0; &#125; return hasPathSum(root.left,sum) || hasPathSum(root.right,sum);&#125; DFS 我觉得思想都很简单啊，其实二叉树的基本上所有的题目都是建立在前序和层序遍历的基础上的，熟练掌握了前序和层序的递归非递归就基本能解所有题目了… (在前序非递归的基础上稍加改动就行了…) 123456789101112131415import javafx.util.Pair;class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; Stack&lt;Pair&lt;TreeNode,Integer&gt;&gt; toVisit = new Stack&lt;&gt;(); toVisit.push(new Pair&lt;&gt;(root,root.val)); while (!toVisit.isEmpty())&#123; Pair&lt;TreeNode,Integer&gt; cur = toVisit.pop(); if (cur.getKey().right != null) toVisit.push(new Pair&lt;&gt;(cur.getKey().right,cur.getValue()+cur.getKey().right.val)); // 右节点入栈 if (cur.getKey().left != null) toVisit.push(new Pair&lt;&gt;(cur.getKey().left,cur.getValue()+cur.getKey().left.val)); // 左节点入栈 if(cur.getKey().left == null &amp;&amp; cur.getKey().right == null &amp;&amp; cur.getValue() == sum) return true; &#125; return false; &#125;&#125; 从中序与后序遍历序列构造二叉树题目根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 思路我写的应该比较简洁，参数少的原因是抓住了后序是左--右--根的特点，所以后序遍历从后向前是根--右--左，故在递归时根本没有必要将后序遍历的数组界限传入，每次有节点加入就自减一就行，只要满足了先拿到根节点然后遍历右子树，再遍历左子树这个原则就Okay。 至于递归如何写，其实把握三个原则就行： 递归出口，这里就不解释了 每次递归的返回值，这里很明显就是题目要求的root节点 单次递归需要做的事，我们需要构建一个树，那么单次递归就是拿到根节点，并且指向正确的左右子树即可。 代码123456789101112131415161718192021222324class Solution &#123; int index; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] inorder,int[] postorder)&#123; index = inorder.length - 1; for(int i = 0;i &lt;= index; i++)&#123; map.put(inorder[i],i); &#125; return buildTreeByRecursion(inorder,postorder,0,index); &#125; private TreeNode buildTreeByRecursion(int[] inorder,int[] postorder,int inorder_start,int inorder_end)&#123; if(inorder_start &gt; inorder_end) return null; //先拿到根节点的值,确定其在中序遍历的位置，并且将其后序遍历的索引值的末尾往前一位 int inorder_root = map.get(postorder[index]); TreeNode root = new TreeNode(postorder[index--]); //然后确定左右子树，并且递归即可 // 注意哦！是必须先递归右子树，再递归左子树，因为后序是左右根的顺序，后序末尾自减一，此时应该是右子树的根节点！ // 所以必须全部右子树构建完成再去构建左子树 root.right = buildTreeByRecursion(inorder,postorder,inorder_root + 1,inorder_end); root.left = buildTreeByRecursion(inorder,postorder,inorder_start,inorder_root - 1); return root; &#125;&#125; 从前序与中序遍历序列构造二叉树题目根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 思路跟上面的思路一致，就是刚好相反而已嘛… 代码1234567891011121314151617181920212223class Solution &#123; int pre = 0; Map&lt;Integer,Integer&gt; pre_in_map = new HashMap&lt;&gt;(); public TreeNode buildTree(int[] preorder,int[] inorder)&#123; int inorder_end = inorder.length - 1; for(int i = 0;i &lt;= inorder_end; i++)&#123; pre_in_map.put(inorder[i],i); &#125; return buildTreeByRecursion(preorder,inorder,0,inorder_end); &#125; private TreeNode buildTreeByRecursion(int[] preorder,int[] inorder,int inorder_start,int inorder_end)&#123; if(inorder_start &gt; inorder_end) return null; //先拿到根节点的值,确定其在中序遍历的位置，并且将先序遍历的索引值的开始值向前一位 int inorder_root = pre_in_map.get(preorder[pre]); TreeNode root = new TreeNode(preorder[pre++]); //然后确定左右子树，并且递归即可 // 注意哦！是必须先递归左子树，再递归右子树，因为先序是根左右的顺序 // 所以必须全部左子树构建完成再去构建右子树 root.left = buildTreeByRecursion(preorder,inorder,inorder_start,inorder_root - 1); root.right = buildTreeByRecursion(preorder,inorder,inorder_root + 1,inorder_end); return root; &#125;&#125; 填充每个节点的下一个右侧节点指针题目给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 思路 最简单的思路：层序遍历，分别获得每层的节点，然后生成链表，所以这个不是完美二叉树也可以做，也就是说没有用到 完全二叉树 的性质！所以必定不是最优解！而且这个使用的不是常量级的空间，其实是不太符合要求的。 (看了答案的)高赞的 拉拉链解法，将一棵大的二叉树一分为二，处理两棵小二叉树的连接，再递归解决小二叉树内部连接。 还有一种非递归的方法，个人觉得也是非常的精妙，之前我们是用列表保存每一层的节点，其实这是一种浪费。只需要解决三个问题就够了。参考网址 每一层怎么遍历？ 之前是用队列将下一层的节点保存了起来。 这里的话，其实只需要提前把下一层的next构造完成，到了下一层的时候就可以遍历了。 什么时候进入下一层？ 之前是得到当前队列的元素个数，然后遍历那么多次。 ​ 这里的话，注意到最右边的节点的next为null，所以可以判断当前遍历的节点是不是null。 怎么得到每层开头节点？ 之前队列把当前层的所以节点存了起来，得到开头节点当然很容易。 这里的话，我们额外需要一个变量把它存起来。 三个问题都解决了，就可以写代码了。利用三个指针，start指的是当前层的最左节点，也就是本层的起点，cur指的是当前正在遍历的节点，cur.next指的是正在遍历的节点的下一个节点！我觉得这个方法最难想的就是 在遍历本层的时候，将下层的next构造完成！！！ 代码 方法一：层序遍历 12345678910111213141516171819202122232425262728293031/** * 层序遍历 * @param root * @return */public Node connect1(Node root) &#123; if (root == null) &#123; return root; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); Node pre = null; for (int i = 0; i &lt; size; i++) &#123; Node cur = queue.poll(); //从第二个节点开始，将前一个节点的 pre 指向当前节点 if (i &gt; 0) &#123; pre.next = cur; &#125; pre = cur; if (cur.left != null) &#123; queue.offer(cur.left); &#125; if (cur.right != null) &#123; queue.offer(cur.right); &#125; &#125; &#125; return root;&#125; 方法二：拉拉链法 123456789101112131415161718/** * 方法二 拉拉链法 * @param root * @return */public Node connect2(Node root)&#123; if(root == null) return null; Node left = root.left; Node right = root.right; while(left != null)&#123; left.next = right; left = left.right; right = right.left; &#125; connect1(root.left); connect1(root.right); return root;&#125; 方法三：非递归解法（个人最推荐的做法） 12345678910111213141516171819/** * 非递归解法，这个应该是最符合题意的解法 * @param root * @return */public Node connect3(Node root)&#123; if(root == null) return null; Node start = root; while(start.left != null)&#123; Node cur = start; while(cur != null)&#123; cur.left.next = cur.right; if(cur.next != null) cur.right.next = cur.next.left; cur = cur.next; &#125; start = start.left; &#125; return root;&#125; 填充每个节点的下一个右侧节点指针 II题目给定一个二叉树 123456struct Node &#123; int val; Node *left; Node *right; Node *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 进阶： 你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例： 123输入：root = [1,2,3,4,5,null,7]输出：[1,#,2,3,#,4,5,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。 提示： 树中的节点数小于 6000 -100 &lt;= node.val &lt;= 100 思路 方法一：上一题已经讲过，依旧可以用上面的代码，BFS。 方法二：题目要求只能使用常量级额外空间，意味着其实严格上不能使用队列，那怎么做呢？ 可以使用一个尾指针，将所有的节点连接起来，刚好就是题目的next指针，可以做到这一点，至于每一层如何开始，只需要再引入一个指针进行标记即可，不同于BFS的是，BFS在遍历当前层时，是处理当前层的横向连接，并且将子节点加入队列中以便下一次的遍历，而方法二则是在每次循环时，直接处理下一层节点的横向连接问题，因为我并不知道每一层的节点数量和具体位置(无法保存)，只能是如果该层下的子节点存在，就将他们连接！ 1234567891011cur 指针利用 next 不停的遍历当前层。如果 cur 的孩子不为 null 就将它接到 tail 后边，然后更新tail。当 cur 为 null 的时候，再利用 dummy 指针得到新的一层的开始节点。dummy 指针在链表中经常用到，他只是为了处理头结点的情况，它并不属于当前链表。作者：windliang链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-28/来源：力扣（LeetCode） 代码 方法一：同上(略) 方法二： 12345678910111213141516171819202122232425public Node connectII(Node root)&#123; if(root == null) return null; Node cur = root; //遍历的当前节点 Node tail; //中间节点，起承接的作用 while(cur != null)&#123; //遍历整棵树 //注意这里的start应该是一个链表头结点，其指向的next为当前层的下一层的第一个节点 Node start = new Node(); tail = start; //遍历当前层 while(cur != null)&#123; if(cur.left != null)&#123; tail.next = cur.left; tail = tail.next; &#125; if(cur.right != null)&#123; tail.next = cur.right; tail = tail.next; &#125; cur = cur.next; &#125; cur = start.next; &#125; return root;&#125; 二叉树的最近公共祖先题目给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 思路注意p,q必然存在树内, 且所有节点的值唯一！！！递归思想，对以root为根的(子)树进行查找p和q，如果root == null || p || q 直接返回root表示对于当前树的查找已经完毕，否则对左右子树进行查找，根据左右子树的返回值判断: 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA 如果左右子树返回值只有一个不为null, 说明只有p和q存在于左或右子树中, 最先找到的那个节点为LCA 左右子树返回值均为null, p和q均不在树中, 返回null 代码123456789class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || p == root || q == root)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left!=null &amp;&amp; right != null)return root; return left == null ? right : left; &#125;&#125; 二叉树的序列化与反序列化题目序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 "[1,2,3,null,null,4,5]" 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 思路这题做了两个小时…还没整出来…思路其实特别的简单，就是用层序遍历，将所有结点存入列表中（包括了空节点），然后转成字符串，字符串再转成列表然后建立树 卡在建立树这块…心态有点炸…冷静会 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; if (root == null) &#123; return "[]"; &#125; Queue&lt;String&gt; res = new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); res.offer(String.valueOf(root.val)); while(!queue.isEmpty()) &#123; TreeNode node = queue.poll(); // 有左节点就插入左节点，没有就插入null if (node.left != null) &#123; queue.offer(node.left); res.offer(String.valueOf(node.left.val)); &#125; else &#123; res.offer("null"); &#125; // 有右节点就插入右节点，没有就插入null if (node.right != null) &#123; queue.offer(node.right); res.offer(String.valueOf(node.right.val)); &#125; else &#123; res.offer("null"); &#125; &#125; StringBuilder sb = new StringBuilder(); sb.append("["); while(!res.isEmpty()) &#123; sb.append(res.poll()); if (!res.isEmpty()) &#123; sb.append(","); &#125; &#125; sb.append("]"); return sb.toString(); &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; data = data.substring(1, data.length()-1); if (data.length() == 0) &#123; return null; &#125; Queue&lt;String&gt; ls = new LinkedList&lt;&gt;(Arrays.asList(data.split(","))); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); TreeNode root = null; while(!ls.isEmpty()) &#123; String res = ls.poll(); // 创建根节点 if (root == null) &#123; root = new TreeNode(Integer.valueOf(res)); queue.offer(root); continue; &#125; // 注意：ls的长度总是奇数的，所以除了根节点，其余节点创建时可以一次取两个ls中的元素 TreeNode father = queue.poll(); // 创建左节点 if (!res.equals("null")) &#123; TreeNode curr = new TreeNode(Integer.valueOf(res)); father.left = curr; queue.offer(curr); &#125; // 创建右节点 res = ls.poll(); if (!res.equals("null")) &#123; TreeNode curr = new TreeNode(Integer.valueOf(res)); father.right = curr; queue.offer(curr); &#125; &#125; return root; &#125;&#125; 翻转二叉树题目翻转一棵二叉树。 示例： 输入： 4 / \ 2 7 / \ / \ 1 3 6 9 输出： 4 / \ 7 2 / \ / \ 9 6 3 1 思路递归…注释有说 代码1234567891011121314151617/** * 递归三部曲 * 1、找到出口，节点为空即为出口 * 2、找到返回值，返回值，返回值应该是子树的根节点 * 3、一次递归需要做啥，需要将左右子树翻转，现在我们手上也就是三个节点 * 分别是根节点，左子树根节点，右子树根节点，要做的就只是左右子树根节点翻转即可 * @param root * @return */private static TreeNode invertTree(TreeNode root)&#123; if(root == null) return null; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root;&#125; 合并二叉树题目给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 思路使用递归。我们可以对这两棵树同时进行前序遍历，并将对应的节点进行合并。在遍历时，如果两棵树的当前节点均不为空，我们就将它们的值进行相加，并对它们的左孩子和右孩子进行递归合并；如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。 代码123456789101112131415161718192021/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; if (t1 == null) return t2; if (t2 == null) return t1; t1.val += t2.val; t1.left = mergeTrees(t1.left, t2.left); t1.right = mergeTrees(t1.right, t2.right); return t1; &#125;&#125; 验证二叉搜索树题目给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。根节点的值为 5 ，但是其右子节点值为 4 。 思路二叉搜索树的特点，就是根节点要大于左子树全部节点的数，小于右子树全部节点的数，故如果我们是中序遍历，则二叉搜索树遍历的节点的值一定是递增的！当然我们没有必要用一个数组将所有节点的值存起来，只需要存储当前遍历节点的之前一个节点的值即可！ 代码123456789101112131415class Solution &#123; public boolean isValidBST(TreeNode root) &#123; // 不用int[]是为了防止初始化值等于TreeNode中的val return validByInorderTraversal(root, new long[] &#123;Long.MIN_VALUE&#125;); &#125; boolean validByInorderTraversal(TreeNode root, long[] prev) &#123; if (root == null) return true; if (!validByInorderTraversal(root.left, prev)) return false; // 每次跟只跟前一个元素做判断，符合条件则替换，否则返回false if (prev[0] &gt;= root.val) return false; prev[0] = root.val; if (!validByInorderTraversal(root.right, prev)) return false; return true; &#125;&#125; 二叉树的直径题目给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 :给定二叉树 12345 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 思路按照常用方法计算一个节点的深度：max(depth of node.left, depth of node.right) + 1。在计算的同时，经过这个节点的最大直径为 (depth of node.left) + (depth of node.right) 。搜索每个节点并记录这些路径经过的点数最大值，期望长度是就是结果。 代码12345678910111213141516class Solution &#123; int ans; public int diameterOfBinaryTree(TreeNode root) &#123; ans = 0; //拿到每个节点的左右子树的深度的和，ans代表了最长直径，其实也就是最大的左右子树深度之和 depth(root); return ans; &#125; public int depth(TreeNode node) &#123; if (node == null) return 0; int L = depth(node.left); int R = depth(node.right); ans = Math.max(ans, L+R); return Math.max(L, R) + 1; &#125;&#125; 把二叉搜索树转换为累加树题目给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。 例如： 123456789101112输入: 二叉搜索树: 5 / \ 2 13输出: 转换为累加树: 18 / \ 20 13来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree 思路二叉搜索树，第一想法就是用中序递归去做，累加树的意思是 根节点的值 = 根节点的值 + 右子树的值 ，然后再更新左子树的值 = 根节点的值 + 左子树的值，所以就符合右中左的遍历顺序，只要写出来右中左的递归，然后用一个全局变量记录上一个遍历的节点的值再加上本身的值，就okay了！ 代码1234567891011class Solution &#123; int add = 0; public TreeNode convertBST(TreeNode root) &#123; if (root == null) return root; convertBST(root.right); root.val += add; add = root.val; convertBST(root.left); return root; &#125;&#125; Tip: 其实个人觉得这个题目有问题，既然是累加树，为何是按照右中左的遍历顺序来累加呢…我的根节点还得加到我左子树的最右叶子节点上！真的荒唐啊… 二叉树展开为链表题目给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 12345 1 / \ 2 5 / \ \3 4 6 将其展开为： 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 思路注意题目的要求是 原地 展开！ 这里强推一手题解里一位大佬写的！总共3个大方法，非常好！！！ 二叉树转换成链表 解法一[自顶向下非递归]可以发现展开的顺序其实就是二叉树的先序遍历。算法和 94 题中序遍历的 Morris 算法有些神似。 将左子树插入到右子树的地方 将原来的右子树接到左子树的最右边节点 代码的话也很好写，首先我们需要找出左子树最右边的节点以便把右子树接过来。 1234567891011121314151617181920public void flatten(TreeNode root) &#123; while (root != null) &#123; //左子树为 null，直接考虑下一个节点 if (root.left == null) &#123; root = root.right; &#125; else &#123; // 找左子树最右边的节点 TreeNode pre = root.left; while (pre.right != null) &#123; pre = pre.right; &#125; //将原来的右子树接到左子树的最右边节点 pre.right = root.right; // 将左子树插入到右子树的地方 root.right = root.left; root.left = null; // 考虑下一个节点 root = root.right; &#125; &#125; 解法二[自顶向上，推荐]题目中，要求说是 in-place，之前一直以为这个意思就是要求空间复杂度是 O(1)。偶然看见评论区大神的解释， in-place 的意思可能更多说的是直接在原来的节点上改变指向，空间复杂度并没有要求。所以这道题也可以用递归解一下。利用变形的后序遍历 右左根即可。 1234567891011private TreeNode pre = null;public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = pre; root.left = null; pre = root;&#125; 相应的左孩子也要置为 null，同样的也不用担心左孩子丢失，因为是后序遍历，左孩子已经遍历过了。和 112 题一样，都巧妙的利用了后序遍历。 既然后序遍历这么有用，利用 112 题介绍的后序遍历的迭代方法，把这道题也改一下吧。 12345678910111213141516171819202122232425public void flatten(TreeNode root) &#123; Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode pre = null; while (cur != null || !toVisit.isEmpty()) &#123; while (cur != null) &#123; toVisit.push(cur); // 添加根节点 cur = cur.right; // 递归添加右节点 &#125; cur = toVisit.peek(); // 已经访问到最右的节点了 // 在不存在左节点或者右节点已经访问过的情况下，访问根节点 if (cur.left == null || cur.left == pre) &#123; toVisit.pop(); /**************修改的地方***************/ cur.right = pre; cur.left = null; /*************************************/ pre = cur; cur = null; &#125; else &#123; cur = cur.left; // 左节点还没有访问过就先访问左节点 &#125; &#125; &#125; 解法三[自顶向上]解法二中提到如果用先序遍历的话，会丢失掉右孩子，除了用后序遍历，还有没有其他的方法避免这个问题。在 Discuss 又发现了一种解法。 为了更好的控制算法，所以我们用先序遍历迭代的形式，正常的先序遍历代码如下， 123456789101112131415public static void preOrderStack(TreeNode root) &#123; if (root == null) &#123; return; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); while (root != null || !s.isEmpty()) &#123; while (root != null) &#123; System.out.println(root.val); s.push(root); root = root.left; &#125; root = s.pop(); root = root.right; &#125;&#125; 还有一种特殊的先序遍历，提前将右孩子保存到栈中，我们利用这种遍历方式就可以防止右孩子的丢失了。由于栈是先进后出，所以我们先将右节点入栈。 1234567891011121314151617public static void preOrderStack(TreeNode root) &#123; if (root == null)&#123; return; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); s.push(root); while (!s.isEmpty()) &#123; TreeNode temp = s.pop(); System.out.println(temp.val); if (temp.right != null)&#123; s.push(temp.right); &#125; if (temp.left != null)&#123; s.push(temp.left); &#125; &#125;&#125; 之前我们的思路如下： 题目其实就是将二叉树通过右指针，组成一个链表。 11 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 我们知道题目给定的遍历顺序其实就是先序遍历的顺序，所以我们可以利用先序遍历的代码，每遍历一个节点，就将上一个节点的右指针更新为当前节点。12345先序遍历的顺序是 1 2 3 4 5 6。遍历到 2，把 1 的右指针指向 2。1 -&gt; 2 3 4 5 6。遍历到 3，把 2 的右指针指向 3。1 -&gt; 2 -&gt; 3 4 5 6。 因为我们用栈保存了右孩子，所以不需要担心右孩子丢失了。用一个 pre 变量保存上次遍历的节点。修改的代码如下：1234567891011121314151617181920212223242526public void flatten(TreeNode root) &#123; if (root == null)&#123; return; &#125; Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); s.push(root); TreeNode pre = null; while (!s.isEmpty()) &#123; TreeNode temp = s.pop(); /***********修改的地方*************/ if(pre!=null)&#123; pre.right = temp; pre.left = null; &#125; /********************************/ if (temp.right != null)&#123; s.push(temp.right); &#125; if (temp.left != null)&#123; s.push(temp.left); &#125; /***********修改的地方*************/ pre = temp; /********************************/ &#125;&#125; 总结解法一和解法三可以看作自顶向下的解决问题，解法二可以看作自底向上。以前觉得后序遍历比较麻烦，没想到竟然连续遇到了后序遍历的应用。先序遍历的两种方式自己也是第一次意识到，之前都是用的第一种正常的方式。 作者：windliang链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--26/ Tips: 这个大佬写的是真好！ 深度和广度优先搜索]]></content>
  </entry>
  <entry>
    <title><![CDATA[复试准备]]></title>
    <url>%2F2020%2F01%2F05%2F%E5%A4%8D%E8%AF%95%E5%87%86%E5%A4%87.html</url>
    <content type="text"><![CDATA[复试准备大概说一下准备策略吧…最近有考试，也没啥时间，就初略的写一下叭…凑合看！ 科目 概述今年的复试跟去年只有一个不同，就是将往年的30分的计算机网络更换为算法设计与分析，其他全部保持一致。 复试分为机试(200) + 面试(140) + 英语笔试(10)，总分共计350分，最后分数是直接与初试分数相加，按照总成绩分数进行排名，其中机试尤为关键，按照往年经验来说，机试分差在50分左右都是非常常见的！至于面试，大家差的都不多，我下面会主要讲一下机试准备，顺带讲一下复试！ 复试流程一般会在3月初进行复试，我们去年是2月14出的成绩，3月7号就得到达哈尔滨进行考前的一些手续办理，中间大概只有15天的时间准备，所以务必要提前备考(我就很后悔没有提前备考…流下悔恨的泪水啊…) 考前一两天会先让你交各种材料，然后心理测评，然后就开始复试。复试是一整天的，上午机试，下午面试，机试时间是两小时，时间是比较紧张的，因为题量比较大，下面我会详细说的！在机试开始之前，会让你先做英语笔试，也就是坐在电脑面前会先给你发一张英语试卷(其实就是一篇英文论文),然后你需要看这篇论文，回答相关的5个问题，一共10分，每小问2分(这个大家都不会，不要影响自己的机试就行！) 然后是开始机试！两个小时，应该是9点半到11点半？(我也不记得了呀) ，机试完之后基本没有休息，大概中午一点就需要进入面试准备了，所有人会放到一个大房间里，去年是有8条线，每条线都是不一样的老师，也就是流水线作业，一共有四轮面试，每轮35分，共140分，每个人会分到一个数字，代表你是8条线的哪一条，然后进行面试，然后只有等到所有人全部面试结束，方可离开。 复试完当天就会有深圳校区的宣讲会，所有老师都会到场！！！报考深圳的你！！！！千万千万不要错过，脸皮一定要厚！！！！！当天就需要确定导师的，如果你不去找，到时候上线了只能挑别人剩下的，所以不管你复试到底成绩咋样(复试成绩会在之后两天才出)，先找老师，上线了就可以直接跟他走，没上线的话就再联系本部老师就行了！ 机试部分首先是200分的机试，按照往年推算，今年应该题型大概保持一致，也就是120分选择题 + 80分主观题，其中80分主观题去年是分为20分编程题 + 60分改错题。 选择题：120分选择题，包含了数据库系统、离散数学、算法设计与分析、逻辑思维能力。也就是各占30分，其中要说明的是数据库系统、离散数学、算法设计与分析都是2分一题，也就是共有45题，而逻辑思维题是6分一题(忘了是5分还是6分了…)，所以加起来选择题有50来道，这个题量是很大的，务必要考前计划好时间！！！！因为去年坐我旁边的两位大哥…我选择题都做完了他们还在做20题，最后他们我看分数都是80上下… 主观题：80分，我只讲去年的题型。60分改错，20分编程题。 先讲20分编程题，题目要求用C语言作答！题目的难度基本与C语言那本书(苏小红的)的课后题持平，或者说略微难一些些，去年是考的字符串排序之类的(我也有点忘记啦，你们可以上王道论坛看看最新的复试试卷，我是没有收集的哈~我给的资料都是我去年的，没有集合19年的)。 再讲60分改错。改错也是给你一道题，给你代码，然后你修改，全部改对才能ac，否则就是0分，一共3题，每题20分！改对一道就基本比较稳了。 数据库系统我建议这个可以放到后面复习，考试题目是在中国大学MOOC中战德臣讲的《数据库系统》中的测验里的题目出，不会超出这个范围哟！！！！！如果后期时间不太够，可以直接看题目背答案，当然你需要背的很熟哦(我当时是刷了很多遍，直接背的题目和答案，看到题目就知道答案！)，因为我当时时间很紧迫，就没有全部看完视频，因为视频太多了…上中下…感觉得看几星期。 预期如果一边看视频，一边背题的话，一星期大概就能拿下！你可以自己去感受下题量还有视频的多少，然后自己估计需要多久时间，能把里面的题目全部做会，并且要反应特别快，这样会给机试争取大量时间…这可能就是我机试比别人做得快的原因吧… 离散数学这是所有复试科目里面最难的一门！！因为包括了集合论与图论以及近世代数！建议看Mooc，看咱工大老师的离散数学！具体名字我给忘了！一定要趁早复习，不然基本上后期就是完全放弃的状态，这个一定提早复习，预期复习时间至少要给到 15-20 天… 习题的话建议把我资料里那些离散数学部分的习题做完就差不多了，难度基本与之持平。 算法设计与分析这个我没考过..预期是算时间复杂度之类的题型吧…毕竟是选择题… 逻辑思维能力这个考前无需准备，稍微看一下我给的资料里的题目就行，题目比较简单，建议考试先做这个，分值很重，很多同学在考试的时候最后都没时间做这个！！！！贼可惜的吖！！送分题变成了送命题… C语言这个80分是大头哟，基本上决定你能不能上你的一志愿！基本上做出一两道改错就很稳了，毕竟20分一题吖！如何准备？我建议这个在出分前就基本要准备完成，出分后可以进行数据库系统的复习和离散数学近世代数部分复习。准备方式就是刷苏小红老师那本C语言的书，把重要章节(字符串那几章)课后题全部刷一遍，找到ac题目的感觉，同时温馨提醒可以上LeetCode找一些相关的专题进行练习，这样在考场会有一种熟悉的感觉！ 这个准备起来时间应该差不多15天左右，一定要多写代码，有感觉是最重要的。 面试部分我是没有做过任何面试部分的准备的！但是！我有些话还是要告诫你一下！ 一面35分，第一面自我介绍，然后给你一张图，让你看看能看到啥(鬼知道这是在整啥玩意…)，全程可以选择英文 or 中文，可能用英文全程作答会有点加分吧… 二面35分，第二面是讲竞赛经历和项目经历，主要是看证书(奖学金证书啥的没用哈)，要的是CCF之类的获奖证书，其他的一律不看！ 三面是专业面，就是给你一道题，你在外面思考5分钟，如何做，一般就是普通的智力题，不用太担心，挺简单的，我当时的题目是爬山问题，一个人从山下爬上去，一个从山下下来，什么时候相遇…这类的问题。 四面！！！！这个我最想讲，因为我面的不好，没有准备，也没经验！！现在，经验来了！！一定要看看人工智能，自然语言，机器翻译，模式识别等等之类的东西，这一面主要就问这个，我当时是面的人工智能，妈呀啥也不会啊，讲不出话…你准备的话就大概看看人工智能是个啥…用于哪些领域，有大概哪些技术，初略的大概看看就行，不然到时候没话说贼尴尬的！]]></content>
  </entry>
  <entry>
    <title><![CDATA[递归总结(转)]]></title>
    <url>%2F2020%2F01%2F04%2F%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[3道题彻底搞定：套路解决递归问题(转)前言转的哈~我自己学习看的！！ 原文链接 ——-&gt; 解决递归 相信不少同学和我一样，在刚学完数据结构后开始刷算法题时，遇到递归的问题总是很头疼，而一看解答，却发现大佬们几行递归代码就优雅的解决了问题。从我自己的学习经历来看，刚开始理解递归思路都很困难，更别说自己写了。 我一直觉得刷算法题和应试一样，既然是应试就一定有套路存在。在刷题中，我总结出了一套解决递归问题的模版思路与解法，用这个思路可以秒解很多递归问题。 递归解题三部曲何为递归？程序反复调用自身即是递归。 我自己在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。 相信很多初学者和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，因此我们只需要关注一级递归的解决过程即可。 我们需要关心的主要是以下三点： 整个递归的终止条件。 一级递归需要做什么？ 应该返回给上一级的返回值是什么？ 因此，也就有了我们解递归题的三部曲： 找整个递归的终止条件：递归应该在什么时候结束？ 找返回值：应该给上一级返回什么信息？ 本级递归应该做什么：在这一级递归中，应该完成什么任务？ 一定要理解这3步，这就是以后递归秒杀算法题的依据和思路。 但这么说好像很空，我们来以题目作为例子，看看怎么套这个模版，相信3道题下来，你就能慢慢理解这个模版。之后再解这种套路递归题都能直接秒了。 例1：求二叉树的最大深度先看一道简单的Leetcode题目： Leetcode 104. 二叉树的最大深度 题目很简单，求二叉树的最大深度，那么直接套递归解题三部曲模版： 找终止条件。 什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。 找返回值。 应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。 本级递归应该做什么。 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。 具体Java代码如下： 12345678910111213class Solution &#123; public int maxDepth(TreeNode root) &#123; //终止条件：当树为空时结束递归，并返回当前深度0 if(root == null)&#123; return 0; &#125; //root的左、右子树的最大深度 int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); //返回的是左右子树的最大深度+1 return Math.max(leftDepth, rightDepth) + 1; &#125;&#125; 当足够熟练后，也可以和Leetcode评论区一样，很骚的几行代码搞定问题，让之后的新手看的一脸懵逼(这道题也是我第一次一行代码搞定一道Leetcode题)： 12345class Solution &#123; public int maxDepth(TreeNode root) &#123; return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125; 例2：两两交换链表中的节点看了一道递归套路解决二叉树的问题后，有点套路搞定递归的感觉了吗？我们再来看一道Leetcode中等难度的链表的问题，掌握套路后这种中等难度的问题真的就是秒：Leetcode 24. 两两交换链表中的节点 直接上三部曲模版： 找终止条件。 什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。 找返回值。 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。 本级递归应该做什么。 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。 附上Java代码： 123456789101112131415class Solution &#123; public ListNode swapPairs(ListNode head) &#123; //终止条件：链表只剩一个节点或者没节点了，没得交换了。返回的是已经处理好的链表 if(head == null || head.next == null)&#123; return head; &#125; //一共三个节点:head, next, swapPairs(next.next) //下面的任务便是交换这3个节点中的前两个节点 ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; //根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分 return next; &#125;&#125; 例3：平衡二叉树相信经过以上2道题，你已经大概理解了这个模版的解题流程了。 那么请你先不看以下部分，尝试解决一下这道easy难度的Leetcode题（个人觉得此题比上面的medium难度要难）：Leetcode 110. 平衡二叉树 我觉得这个题真的是集合了模版的精髓所在，下面套三部曲模版： 找终止条件。 什么情况下递归应该终止？自然是子树为空的时候，空树自然是平衡二叉树了。 应该返回什么信息： 为什么我说这个题是集合了模版精髓？正是因为此题的返回值。要知道我们搞这么多花里胡哨的，都是为了能写出正确的递归函数，因此在解这个题的时候，我们就需要思考，我们到底希望返回什么值？ 何为平衡二叉树？平衡二叉树即左右两棵子树高度差不大于1的二叉树。而对于一颗树，它是一个平衡二叉树需要满足三个条件：它的左子树是平衡二叉树，它的右子树是平衡二叉树，它的左右子树的高度差不大于1。换句话说：如果它的左子树或右子树不是平衡二叉树，或者它的左右子树高度差大于1，那么它就不是平衡二叉树。 而在我们眼里，这颗二叉树就3个节点：root、left、right。那么我们应该返回什么呢？如果返回一个当前树是否是平衡二叉树的boolean类型的值，那么我只知道left和right这两棵树是否是平衡二叉树，无法得出left和right的高度差是否不大于1，自然也就无法得出root这棵树是否是平衡二叉树了。而如果我返回的是一个平衡二叉树的高度的int类型的值，那么我就只知道两棵树的高度，但无法知道这两棵树是不是平衡二叉树，自然也就没法判断root这棵树是不是平衡二叉树了。 因此，这里我们返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的boolean类型的值。可以单独定义一个ReturnNode类，如下： 123456789class ReturnNode&#123; boolean isB; int depth; //构造方法 public ReturnNode(boolean isB, int depth)&#123; this.isB = isB; this.depth = depth; &#125;&#125; 本级递归应该做什么。 知道了第二步的返回值后，这一步就很简单了。目前树有三个节点：root，left，right。我们首先判断left子树和right子树是否是平衡二叉树，如果不是则直接返回false。再判断两树高度差是否不大于1，如果大于1也直接返回false。否则说明以root为节点的子树是平衡二叉树，那么就返回true和它的高度。 具体的Java代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; //这个ReturnNode是参考我描述的递归套路的第二步：思考返回值是什么 //一棵树是BST等价于它的左、右俩子树都是BST且俩子树高度差不超过1 //因此我认为返回值应该包含当前树是否是BST和当前树的高度这两个信息 private class ReturnNode&#123; boolean isB; int depth; public ReturnNode(int depth, boolean isB)&#123; this.isB = isB; this.depth = depth; &#125; &#125; //主函数 public boolean isBalanced(TreeNode root) &#123; return isBST(root).isB; &#125; //参考递归套路的第三部：描述单次执行过程是什么样的 //这里的单次执行过程具体如下： //是否终止?-&gt;没终止的话，判断是否满足不平衡的三个条件-&gt;返回值 public ReturnNode isBST(TreeNode root)&#123; if(root == null)&#123; return new ReturnNode(0, true); &#125; //不平衡的情况有3种：左树不平衡、右树不平衡、左树和右树差的绝对值大于1 ReturnNode left = isBST(root.left); ReturnNode right = isBST(root.right); if(left.isB == false || right.isB == false)&#123; return new ReturnNode(0, false); &#125; if(Math.abs(left.depth - right.depth) &gt; 1)&#123; return new ReturnNode(0, false); &#125; //不满足上面3种情况，说明平衡了，树的深度为左右俩子树最大深度+1 return new ReturnNode(Math.max(left.depth, right.depth) + 1, true); &#125;&#125; 一些可以用这个套路解决的题暂时就写这么多啦，作为一个高考语文及格分，大学又学了工科的人，表述能力实在差因此啰啰嗦嗦写了一大堆，希望大家能理解这个很好用的套路。 下面我再列举几道我在刷题过程中遇到的也是用这个套路秒的题，真的太多了，大部分链表和树的递归题都能这么秒，因为树和链表天生就是适合递归的结构。 我会随时补充，正好大家可以看了上面三个题后可以拿这些题来练练手，看看自己是否能独立快速准确的写出递归解法了。 Leetcode 101. 对称二叉树 Leetcode 111. 二叉树的最小深度 Leetcode 226. 翻转二叉树：这个题的备注是最骚的。Mac OS下载神器homebrew的大佬作者去面试谷歌，没做出来这道算法题，然后被谷歌面试官怼了：”我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。” Leetcode 617. 合并二叉树 Leetcode 654. 最大二叉树 Leetcode 83. 删除排序链表中的重复元素 Leetcode 206. 翻转链表]]></content>
      <tags>
        <tag>算法</tag>
        <tag>recrusion</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[历年面经总结]]></title>
    <url>%2F2019%2F12%2F27%2F%E5%8E%86%E5%B9%B4%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[快手篇数据结构 说说B+树和B树的区别，优缺点等？ 经有一个查询好友的接口，设计一个微信朋友圈，可以实现发表朋友圈，添加评论，查看评论等功能。主要是设计数据结构 操作系统计算机网络 TCP三次握手四次挥手，四次挥手过程中服务端的哪几种状态，哪几种包 算法 算法题：无序数列中求第k大的数(维护最小堆，然后依次遍历，与堆顶比较 写一个选择排序或者插入排序 写一个生产者消费者 一个二维矩阵进行逆置操作，也就是行变列列变行。扩展一下，二维数组存在500g的文件中，怎么做才能完成上面算法的操作，我就说先按行拆分，最后再拼接。 java基础 HashMap的底层数据结构 HashMap哈希函数的认识，JDK1.8采用的hash函数 多线程 多线程JUC包下的一些常见的类，比如CountDownLatch、Semaphore等 锁的概念，锁相关的关键字，volatile，synchronized。还比较了ReentrantLock与synchronized。 线程池有哪些参数？分别有什么用？如果任务数超过的核心线程数，会发生什么？阻塞队列大小是多少？ 怎么实现一个线程安全的计数器？ 接着聊ConcurrentHashMap，底层实现 Java多线程了解么，什么时候一个int，类型的操作是不安全的，自加呢，赋值呢。如果使用volatile修饰的话有什么作用。 有一个场景，多线程并发，为每个线程安排一个随机的睡眠时间，设想一种数据结构去唤醒睡眠时间结束的线程，应该用哪种结构，答应该用优先级队列，也就是小顶堆，顶部是剩余睡眠时间最短的那个线程。 JVM 你了解哪些收集器？CMS和G1。详细谈谈G1的优点？什么时候进行Full GC呢？ 消息中间件spring全家桶 Spring中涉及的一些设计模式 聊聊Spring，主要IOC等等 数据库 MySQL创建索引的原则，好处 数据库索引，索引底层的实现，B+树的结构以及与普通查找树的优点 MySQL和redis的区别是什么 为什么MySQL和Redis都要使用独立进程来部署，开放端口来提供服务，为什么不写在内核中。 其他 设计模式：讲了单例，工厂方法，抽象工厂，策略模式，观察者模式，代理模式，还顺便讲了下spring动态代理的实现原理 红黑树的具体结构及实现，红黑树与查找树的区别体现 项目中用到dubbo？那你说说什么是rpc框架？和http调用的区别是什么？ Redis有哪些数据结构？持久化方案和区别？ Redis哨兵、集群的设计原理和区别？ Redis缓存和数据库会存在一致性问题吗？怎么解决 Kafka怎么保证数据可靠性？讲了生产者端发送消息到broker持久化，分区和副本机制，消费者消费消息的at-least-once和at-most-once？怎么实现Exactly-Once？ 字节篇数据结构操作系统 用户态如何切换到内核态 进程间通信的方式，哪种最快 信号量怎么实现对共享资源的访问 select和epoll 计算机网络 TCP的流量控制和拥塞控制 不同子网可以通过ARP获取mac地址吗 浏览器中输入网址到获得页面的全过程 输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS 三次握手 握手时产生的序列号干什么用的 讲一下接收窗口 TCP和UDP的本质区别 什么时候选择TCP/UDP HTTPS的连接过程 7层模型和4层模型，每一层有哪些常见协议？ 路由器/交换机是哪一层 网络层用来干嘛？传输层用来干嘛？ HTTP可以使用UDP吗 HTTPS怎么确认收到的包就是服务器发来的 确定发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb/s，接收端100Mb/s 网络五层模型，每一层分别有哪些协议 ICMP，TCP，IP，HTTP分别是哪一层，为什么网络模型要分层，每一层之间怎么传递 http头里的gzip 反向***说一下 三次握手，为什么要三次，每一次分别确认了什么 TCP协议的三次握手和四次挥手过程？ 算法 求x的y次方，想出比直接for循环更好的方案 求绝对众数 算法题：红蓝两种球，总共N个， N&gt;2, 排列组合，连续3个颜色一样是非法的，求合法的排列数量 描述一下堆排的过程？建堆的时间复杂度？最大堆中求前k个最大值的时间复杂度？ 算法题：海岛面积计算题，给一个矩阵，0表示海水，相连的1表示海岛，上下左右表示相连。000111101110001（1）求最大海岛面积。（2）求最大海岛面积和对应海岛的所有坐标。（3）求所有海岛的所有坐标，按海岛分。每小题讲思路，最后写第二题。 java基础 Bean的默认作用范围是什么？其他的作用范围？ 平常用线程主要是怎么写的，会用一些线程框架吗？（没有用框架）Java线程池的概念？线程池有哪些？线程池工厂有哪些线程池类型，及其线程池参数是什么？ ConcurrentHashMap讲一讲？ Java bin包下面的工具用过哪些？ 同步IO和异步IO的区别？ 线程如何实现同步？ ConcurrentHashMap 在Java7和Java8中的区别？为什么Java8并发效率更好？什么情况下用HashMap，什么情况用ConcurrentHashMap？ 加锁有什么机制？ ThreadLocal？应用场景？ 多线程JVM Java GC机制？GC Roots有哪些？ 消息中间件spring全家桶 微服务注册发现，为什么用微服务，grpc，protobuf，dubbo讲一下 IoC是什么概念？ Web容器用的什么？你项目里涉及了SSM框架，一个请求到Tomcat容器了，怎么到SSM代码中去？ 数据库 事务的四大特性 四种隔离级别 什么是幻读 InnoDB 怎么防止幻读 B+树原理，为什么使用B+而不是二叉平衡树 1000万个object的文件，有ABC三个date member，怎么根据ABC的条件查询比较快 联合索引 索引是什么概念有什么作用？MySQL里主要有哪些索引结构？哈希索引和B+树索引比较？ MySQL了解到什么程度？binLog知道吗？ 其他 redis分布式锁两种实现 怎么理解微服务 什么是Python生成器，迭代器； 什么是装饰器； 浏览器缓存、CPU的缓存和Redis的缓存的关系，为什么要有缓存 元组和list的区别； Python中的dict底层怎么实现的 list的底层怎么实现的； 双等于和is有什么区别 JSON和protobuf区别 BloomFilter干嘛的，解决了什么问题 REST api和RPC 为什么protobuf效率更高，JSON缺点 1000万条相同class格式object组成的json，怎么压缩 123456789设计题：一个数据库存了以下数据：用户id，登录时间，登出时间；如何找到一天当中的用户峰值（用一个hash map存所有秒数的在线人数）为什么要分用户态和内核态Git 切换分支，提交，具体如何合并分支Python多线程用了几个CPU算法：二叉树，输出所有和为n的路径（可以从中间结点到中间结点） 阿里数据结构操作系统计算机网络算法 红黑树、二叉树的算法 java基础 Servlet规范了解吗？Servlet的整个业务流程？session和cookie的区别？session怎么变成cookie，怎么变回session？谁来实现整个流程？ 刚才提到的分布式实现多个应用的Session共享问题？ 多线程JVM消息中间件spring全家桶 项目提到的SSM框架里面了解哪些？Spring IoC中Bean的生命周期？谁来管理Bean的生命周期？BeanFactory和ApplicationContext的关系？@Autowired和@Resource的区别？ Spring的自动扫描怎么实现的？谁实现的？ MyBatis介绍一下？你说到这是一个持久层框架，那你了解JPA规范吗？ 数据库其他 UML了解吗？（不会）设计模式？ Zookeeper了解吗？ 单例模式、工厂模式、***模式……单例模式有什么需要注意的吗？（多线程并发问题：synchronized+volatile）你写单例的时候如果这个单例对象有字段值，你会去改变这些字段值吗？为什么呢？ 鹅厂数据结构操作系统计算机网络 http三次握手四次挥手 HTTP常见错误码？TCP三次握手？ 算法 海量数据寻找TopK 海量数据排序 16G的文件储存的是一个数组，要求只用1G内存把他们排好序。 排序算法了解哪些？Java里内置的是用什么排序方法？快排是稳定的吗？快排排对象的时候有什么问题？（提示我，三个字段，第一个字段和第二个字段做hash，第三个不做，还是不太懂） 十亿个IP，获得访问次数最多的十个。 五个单词，在一个长文本中查找是否存在。 快速排序算法 java基础 Java中各种锁聊一下，CAS机制。 stl说一下，map原理，时间复杂度 HashMap有了解吗？HashMap的时间复杂度？HashMap中Hash冲突是怎么解决的？链表的上一级结构是什么？Java8中的HashMap有什么变化？红黑树需要比较大小才能进行插入，是依据什么进行比较的？其他Hash冲突解决方式？ 实现线程安全的方式？ThreadLocal原理？线程池了解吗说说看？自己用线程池怎么定参数？ 多线程 volatile有用过么，底层实现，这个问题是讲到了CPU填充缓存行指令。 Java线程池 JVM GC回收器JVM调优参数配置 JJava堆中怎么分区？怎么判断对象是否需要回收？Java内存占用过大怎么查看？Java内存溢出有碰到过吗？Java内存溢出怎么定位？ 消息中间件spring全家桶数据库 数据库的事务隔离级别，mvcc机制聊一下。 数据库索引，B+树结构和特点。怎么进行优化 mysql间隙锁为了解决什么问题，什么条件下会触发。 MySQL数据库引擎？应用场景？查询优化？NoSQL有用或了解吗？ 其他 红黑树，AVL树，查询时间复杂度，什么情况下用红黑树而不用map 进程和线程的区别？平常的开发环境是Windows还是Linux？Linux命令知道哪些？要在多个文本文件中找一个关键词用什么命令？（grep）网络相关的命令是什么？ 度娘数据结构操作系统计算机网络算法java基础多线程JVM消息中间件spring全家桶 springboot和spring比有什么优点 springboot自动配置原理 数据库 高并发数据库大表优化，分库分表，水平怎么拆，垂直怎么拆 知道哪些索引，索引数据结构 联合索引规则 数据库怎么优化，查询性能瓶颈怎么查（explain） 其他美团数据结构操作系统计算机网络算法java基础多线程JVM消息中间件spring全家桶数据库其他拼夕夕数据结构 二叉树的后序遍历，非递归算法。 操作系统计算机网络 TCP三次握手的过程，如果没有第三次握手有什么问题。 算法java基础 如何访问一个文件的字节流呢 多线程 做的主要是Java对吧，讲一下多线程把，用到哪些写一下，写了thread和runnable，然后写了线程池，她问我线程池由哪些组件组成，有哪些线程池，分别怎么使用，以及拒绝策略有哪些。 什么时候多线程会发生死锁，写一个例子吧，然后我写了一个两个线程，两个锁，分别持有一个，请求另一个的死锁实例 集合类熟悉吧，写一个题目，一个字符串集合，找出pdd并且删除，我直接写了一个list然后for循环判断相等时删除，她说明显问题，我才发现list直接删位置会出错，于是我说改用数组，她说不太符合要求，所以应该使用iterator删除会好一点，修改会反映到集合类，并且不会出错。 然后说一下Redis吧，是单线程还是多线程，Redis的分布式怎么做，说了集群。 RPC了解么，我说了主要是协议栈+数据格式+序列化方式，然后需要有服务注册中心管理生产者和消费者，他问我注册中心宕机怎么办，我说可以做高可用，他说要问的不是这个，是想问我注册中心宕机时消费者是否能访问生产者。 线程数很多会怎么样，我说会占内存，还有就是切换线程比较频繁，他问切换线程会发生什么，应该就是CPU切换上下文，具体就是寄存器和内存地址的刷新。 JVM消息中间件spring全家桶数据库 MySQL的主从复制怎么做的，答日志，具体原理是什么，有什么优缺点。 其他 Redis了解哪些内容，是单线程么，为什么是单线程呢，数据一定是存在物理内存中么，我不懂这话啥意思，就问了一下是不是指可能也在虚拟内存中。他说那讲一下虚拟内存的机制把，我就讲了分页，页表，换页这些东西。 分布式了解哪些东西，消息队列了解么，用在什么场景，说了削峰，限流和异步。说了kafka，问我怎么保证数据不丢失，以及确保消息不会被重复消费。还问了消息送达确认是怎么做的。 cap了解么，分别指什么，base呢，强一致性和弱一致性有什么方法来做，2pc了解么，说一下大概过程。 这样一个题目，一个节点要和客户连接建立心跳检测，大概有百万数量的连接，并且会定期发送心跳包，要写一个update方法和check方法，update方法更新心跳状态，check删除超时节点，怎么做，刚开始做了个hash发现check要轮询太慢了，然后用计时器和开线程检测也不行，最后说了个LRU，他说OK的。 华为数据结构操作系统计算机网络算法java基础多线程JVM消息中间件spring全家桶 请求到SSH框架的流程图画一下？远程调用Shell脚本用到哪些命令？ 数据库 数据量多大？项目PG（PostgreSQL）版本？非结构化数据指的是什么？有没有考虑过nosql？分库分表怎么分？查询的表会合并在一起吗？ 项目性能有没有考虑过？（我是做服务端的，主要考虑请求并发量）数据库性能呢？（了解一点，MySQL主从结构） 其他 Nginx原理了解吗？（只用到负载均衡，介绍了一下负载均衡策略 网易数据结构操作系统计算机网络算法 判断树对称 数组顺时针旋转90度 用wait和notify模拟生产者消费者模式 java基础 public protected private区别？final和finally区别？final可以用在方法参数上吗？RuntimeException和非RuntimeException？各举几个例子？比方说文件读写的时候会有什么异常？怎么实现序列化？除了Java原生序列化方法，序列化还有什么格式？ ArrayList和LinkedList区别？ ArrayList和LinkedList是线程安全的吗？为什么说他们不是线程安全的，举实际场景？ 有什么线程安全的List？（CopyOnWriteArrayList）讲一下怎么实现线程安全的？（读时复制，写时共享，加锁机制） 线程A和线程B同时针对一个共享变量进行操作，如何实现线程安全？ 平常怎么创建线程？线程池里闲置线程怎么保活？（不清楚，说了自己的想法）那怎么唤醒？如果用wait()和notify()，对谁加锁？ synchronized 和 ReentranLock的区别？平常有用哪些集合类？Concurrent包有用吗？ 多线程JVM JVM内存模型？如果给一个类，里面只有一个main方法，方法里面只有一句System.out.println(“helloworld”)，问运行这个类会在Java内存模型里发生什么？ “helloworld”存储在哪里？ JVM内存模型？每个区是做什么的？垃圾回收机制？ 消息中间件spring全家桶 Spring中Bean生命周期？提到的Aware相关接口指的是什么？平常会自己会用Aware相关接口吗？Bean生命周期这么长是为什么？ 数据库 给一个数据库表，ID、score两个字段分别代表学生ID和成绩，写SQL语句求ID=？的学生排第几名？ 假设是InnoDB，给上述SQL语句加索引怎么加？为什么这样建立？聚集索引和非聚集索引有什么区别？ MySQL数据库，给一个用户表格，ID、用户名、性别、用户信息…，假设经常对性别字段进行查询，问怎么建立索引？为什么？假设用户名需要是唯一的，问怎么建索引？ 添加索引的SQL语句？给一个abc三个字段的索引，where a=0 order by c能用到索引吗？where a=0 and b大于0 order by c能用到索引吗？Hash索引和B树索引的区别？Hash索引有区间查询吗？有没有用nosql？ 其他 介绍一下觉得做得最好的项目？画一下项目的框架结构图？Nginx用来做什么？采用了什么负载均衡策略？万一某一个服务器挂掉怎么办？（一致性hash）如果添加一个节点呢？ 平常用到哪些设计模式？介绍一下模式？模式和装饰器模式区别？ NIO和BIO区别？NIO怎么写？阻塞和非阻塞，同步和异步区别？ CVTE数据结构操作系统计算机网络算法java基础 Java为什么说是面向对象的？ ava的三大特性？如果说有两个方法，同名同参数但不同返回值，问是重载吗？ 平常用到哪些集合类？ArrayList和LinkedList区别？HashMap内部数据结构？ConcurrentHashMap分段锁？ 多线程 Volatile关键词？是线程安全的吗？ 如何实现synchronized一样的效果？ JVM消息中间件spring全家桶 Spring Cloud用到什么东西？如何实现负载均衡？服务挂了注册中心怎么判断 Spring的优点？Spring AOP实现原理？AOP应用场景？拦截器用来做什么业务？ 数据库 MySQL数据库引擎和应用场景 MySQL行锁是否会有死锁的情况？ MySQL事务隔离级别 MySQL平常有索引优化吗？怎么去知道一个SQL语句需不需要优化？一个表，建立了索引（B，A），问where A=1 and B=2索引是否能够生效？ 乐观锁和悲观锁了解吗？JDK中涉及到乐观锁和悲观锁的内容 其他 Nginx负载均衡策略？ ip_hash的优缺点？ Nginx和其他负载均衡框架对比过吗？ Tomcat集群Session共享问题？ MySQL采用了什么存储引擎，为什么？ 分布式锁？]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口技巧汇总]]></title>
    <url>%2F2019%2F12%2F24%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。 LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。 本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解： unordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。 可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。 所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。 本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。 一、最小覆盖子串 题目链接 题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。 如果我们使用暴力解法，代码大概是这样的： 1234for (int i = 0; i &lt; s.size(); i++) for (int j = i + 1; j &lt; s.size(); j++) if s[i:j] 包含 t 的所有字母: 更新答案 思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。 滑动窗口算法的思路是这样： 1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。 下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。 初始状态： 0 增加 right，直到窗口 [left, right] 包含了 T 中所有字符： 0 现在开始增加 left，缩小窗口 [left, right]。 0 直到窗口中的字符串不再符合要求，left 不再继续移动。 0 之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。 如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。 上述过程可以简单地写出如下伪码框架： 123456789101112131415161718string s, t;// 在 s 中寻找 t 的「最小覆盖子串」int left = 0, right = 0;string res = s;while(right &lt; s.size()) &#123; window.add(s[right]); right++; // 如果符合要求，移动 left 缩小窗口 while (window 符合要求) &#123; // 如果这个窗口的子串更短，则更新 res res = minLen(res, window); window.remove(s[left]); left++; &#125;&#125;return res; 如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left…right] 是否符合要求，是否包含 t 的所有字符呢？ 可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。 现在将上面的框架继续细化： 123456789101112131415161718192021222324252627282930313233343536373839404142string s, t;// 在 s 中寻找 t 的「最小覆盖子串」int left = 0, right = 0;string res = s;// 相当于两个计数器unordered_map&lt;char, int&gt; window;unordered_map&lt;char, int&gt; needs;for (char c : t) needs[c]++;// 记录 window 中已经有多少字符符合要求了int match = 0; while (right &lt; s.size()) &#123; char c1 = s[right]; if (needs.count(c1)) &#123; window[c1]++; // 加入 window if (window[c1] == needs[c1]) // 字符 c1 的出现次数符合要求了 match++; &#125; right++; // window 中的字符串已符合 needs 的要求了 while (match == needs.size()) &#123; // 更新结果 res res = minLen(res, window); char c2 = s[left]; if (needs.count(c2)) &#123; window[c2]--; // 移出 window if (window[c2] &lt; needs[c2]) // 字符 c2 出现次数不再符合要求 match--; &#125; left++; &#125;&#125;return res; 上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142string minWindow(string s, string t) &#123; // 记录最短子串的开始位置和长度 int start = 0, minLen = INT_MAX; int left = 0, right = 0; unordered_map&lt;char, int&gt; window; unordered_map&lt;char, int&gt; needs; for (char c : t) needs[c]++; int match = 0; while (right &lt; s.size()) &#123; char c1 = s[right]; if (needs.count(c1)) &#123; window[c1]++; if (window[c1] == needs[c1]) match++; &#125; right++; while (match == needs.size()) &#123; if (right - left &lt; minLen) &#123; // 更新最小子串的位置和长度 start = left; minLen = right - left; &#125; char c2 = s[left]; if (needs.count(c2)) &#123; window[c2]--; if (window[c2] &lt; needs[c2]) match--; &#125; left++; &#125; &#125; return minLen == INT_MAX ? "" : s.substr(start, minLen);&#125; 如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？ 这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行 2M 次，时间 O(M)。 读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。 二、找到字符串中所有字母异位词 题目链接 这道题的难度是 Easy，但是评论区点赞最多的一条是这样： 1How can this problem be marked as easy??? 实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解： 12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; findAnagrams(string s, string t) &#123; // 用数组记录答案 vector&lt;int&gt; res; int left = 0, right = 0; unordered_map&lt;char, int&gt; needs; unordered_map&lt;char, int&gt; window; for (char c : t) needs[c]++; int match = 0; while (right &lt; s.size()) &#123; char c1 = s[right]; if (needs.count(c1)) &#123; window[c1]++; if (window[c1] == needs[c1]) match++; &#125; right++; while (match == needs.size()) &#123; // 如果 window 的大小合适 // 就把起始索引 left 加入结果 if (right - left == t.size()) &#123; res.push_back(left); &#125; char c2 = s[left]; if (needs.count(c2)) &#123; window[c2]--; if (window[c2] &lt; needs[c2]) match--; &#125; left++; &#125; &#125; return res;&#125; 因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。 三、无重复字符的最长子串 题目链接 遇到子串问题，首先想到的就是滑动窗口技巧。 类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复： 123456789101112131415161718192021int lengthOfLongestSubstring(string s) &#123; int left = 0, right = 0; unordered_map&lt;char, int&gt; window; int res = 0; // 记录最长长度 while (right &lt; s.size()) &#123; char c1 = s[right]; window[c1]++; right++; // 如果 window 中出现重复字符 // 开始移动 left 缩小窗口 while (window[c1] &gt; 1) &#123; char c2 = s[left]; window[c2]--; left++; &#125; res = max(res, right - left); &#125; return res;&#125; 需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。 最后总结通过上面三道题，我们可以总结出滑动窗口算法的抽象思想： 12345678910111213int left = 0, right = 0;while (right &lt; s.size()) &#123; window.add(s[right]); right++; while (valid) &#123; window.remove(s[left]); left++; &#125;&#125; 其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。 稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。]]></content>
      <tags>
        <tag>java</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针技巧汇总]]></title>
    <url>%2F2019%2F12%2F24%2F%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。 一、快慢指针的常见算法快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。 1、判定链表中是否含有环 这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。 单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。 如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。 12345boolean hasCycle(ListNode head) &#123; while (head != null) head = head.next; return false;&#125; 但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。 经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。 123456789101112boolean hasCycle(ListNode head) &#123; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) return true; &#125; return false;&#125; 2、已知链表中含有环，返回这个环的起始位置 1 这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码： 12345678910111213141516ListNode detectCycle(ListNode head) &#123; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) break; &#125; // 上面的代码类似 hasCycle 函数 slow = head; while (slow != fast) &#123; fast = fast.next; slow = slow.next; &#125; return slow;&#125; 可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？ 第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。 2 设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。 巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。 3 所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。 3、寻找链表的中点 类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。 123456while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next;&#125;// slow 就在中间位置return slow; 当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右： center 寻找链表中点的一个重要作用是对链表进行归并排序。 回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。 但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。 4、寻找链表的倒数第 k 个元素 我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）： 1234567891011ListNode slow, fast;slow = fast = head;while (k-- &gt; 0) fast = fast.next;while (fast != null) &#123; slow = slow.next; fast = fast.next;&#125;return slow; 二、左右指针的常用算法左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。 1、二分查找 前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性： 1234567891011121314int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125; 2、两数之和 直接看一道 LeetCode 题目吧： title 只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小： 123456789101112131415int[] twoSum(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; // 题目要求的索引是从 1 开始的 return new int[]&#123;left + 1, right + 1&#125;; &#125; else if (sum &lt; target) &#123; left++; // 让 sum 大一点 &#125; else if (sum &gt; target) &#123; right--; // 让 sum 小一点 &#125; &#125; return new int[]&#123;-1, -1&#125;;&#125; 3、反转数组 1234567891011void reverse(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; // swap(nums[left], nums[right]) int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125;&#125; 4、滑动窗口算法 这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。 幸运的是，这类算法是有框架模板的，下篇文章就准备讲解「滑动窗口」算法模板，帮大家秒杀几道 LeetCode 子串匹配的问题。]]></content>
      <tags>
        <tag>java</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[labuladong公众号笔记]]></title>
    <url>%2F2019%2F12%2F22%2Flabuladong%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0(dp%26%26%E4%BA%8C%E5%88%86).html</url>
    <content type="text"><![CDATA[动态规划：不同的定义产生不同的解法文章链接键盘组合问题 收获对状态机的定义不同，得到的状态转移方程就完全不同 经典面试题：最长回文子串（LeetCode第5题）文章链接经典面试题：最长回文子串 收获回文子串有两个做法，一个是从中间展开的算法，一个是两侧向中间靠齐的dp 单调栈文章链接单调栈 Monotonic Stack 的使用 收获 单调栈算法过程 处理Next Greater Number，从后向前遍历 先判断 栈是否为空 和 栈顶的值是不是比即将入栈的值小 如果栈空，则说明找不到比该数大的数，将其Next Greater Number置为-1 栈不为空，直到找到比该数大的数，将其置为栈顶，比其小的也就没有存在的意义了 然后将该数的Next Greater Number定为栈顶元素，并将该数加入栈中 处理循环数组 将该数组的双倍长度构造出来，这样的话就就不仅能比较右边的数，还能比较左边的数了 二分查找算法详解文章链接二分查找算法详解 二分查找的框架 最基本的框架1（形式是[a,b)） 123456789101112131415int binarySearch(int nums[],int target)&#123; int left = 0; int right = nums.length; while(left &lt; right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid; &#125; return -1;&#125; 最基本的框架2 (形式是[a,b]) 123456789101112131415int binarySearch(int nums[],int target)&#123; int left = 0; int right = nums.length - 1; while(left &lt;= right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125; 寻找左侧边界的二分搜索 12345678910111213141516171819202122232425/** * 返回的是比target小的数量，同时也是最左target的下标 * @param nums * @param target * @return */int binarySearchLeft(int nums[],int target)&#123; int left = 0; int right = nums.length; while(left &lt; right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) right = mid; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid; &#125; //要时刻注意处理边界，如果整个数组都没有这个target，则left会到nums.length // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1;&#125; 寻找右侧边界的二分搜索 1234567891011121314151617181920212223242526/** * 返回的是最右target的下标 * @param nums * @param target * @return */int binarySearchRight(int nums[],int target)&#123; int left = 0; int right = nums.length; while(left &lt; right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) left = mid + 1; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid; &#125; //要时刻注意处理边界，如果整个数组都没有这个target，则left会到nums.length // target 比所有数都大 // return left - 1; if (left == 0) return -1; // 类似之前算法的处理方式 return nums[left-1] == target ? (left-1) : -1;&#125; 收获 左侧边界的二分搜索，left即代表比target小的数的数量 右侧边界的二分搜索，left即代表比target大的第一个数的下标，比如是5，则代表索引为4是target的最右侧数 最长递归子序列(LeetCode第300题)文章链接动态规划之最长递归子序列 两个方法： dp 扑克牌算法，运用二分查找 dp注意事项最重要的是先确定状态转移方程，并且明确dp数组的含义，这里要求的是最长递归子序列，所建立的dp数组是一个一维数组(为何选取的是一维数组呢？)，并且dp[i]的含义是指以索引i结尾的最长递归子序列。 采用归纳法可知，若dp[0…i-1]可知，则 1234for(int j = 0; j &lt; i;j++)&#123; if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i],dp[j]+1);&#125; 即dp[i]是之前的dp[0…i-1]，判断其是否小于nums[i]，若小于则nums[i]可以接到其后面，最后选取一个最长的递归子序列即可。 还有要考虑的就是basecase，由于是最短递归子序列至少为1，所以basecase为1，所以dp数组全部初始化为1即可。 代码123456789101112131415public int lengthOfLtsByDp(int nums[])&#123; int[] dp = new int[nums.length]; Arrays.fill(dp,1); for(int i = 0;i &lt; nums.length;i++)&#123; for(int j = 0; j &lt; i;j++)&#123; if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; int res = 0; for(int i = 0; i &lt; dp.length; i++)&#123; res = Math.max(res,dp[i]); &#125; return res;&#125; 扑克牌算法最长递归子序列其实类似于我们平时玩的蜘蛛纸牌，eg：2，3，1，9，7，4，6，3 ，同一堆的牌只能是小的放在大的上面，如上，就分成2，1 3 9，7，6，3 4 一共4堆，则最长递归子序列数为 4 。 至于如何处理扑克牌放置问题，则可以采用二分查找，因为堆顶都是有序的。 12345678910111213141516171819202122232425public int lengthOfLtsByBinarySearch(int[] nums)&#123; //堆的个数 int piles = 0; //记录每个堆的最上面的牌，保证有序，所以必须利用最左侧边界的二分法 int[] top = new int[nums.length]; for(int i = 0;i &lt; nums.length;i++)&#123; int poker = nums[i]; int left = 0; int right = piles; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(poker &lt; top[mid]) right = mid; else if(poker &gt; top[mid]) left = mid + 1; else right = mid; &#125; //left的取值有[0,nums.length],当left为nums.length时，这里是piles，说明牌堆上的第一张牌全部比它小，则说明此时需要新建一个牌堆 if (left == piles) piles++; top[left] = poker; &#125; return piles;&#125; ​ 子序列解题模板文章链接子序列解题模板 收获两种思路 dp数组为一维数组。常见题型有 最长递增子序列。在子数组array[0..i]中，以array[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。 模板： 12345678int n = array.length;int[] dp = new int[n];for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] = 最值(dp[i], dp[j] + ...) &#125;&#125; dp数组为二维数组。二维数组又分为是对两字符串而言和一个字符串而言。 模板： 1234567891011int n = arr.length;int[][] dp = new dp[n][n];for (int i = 0; i &lt; n; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) &#125;&#125; 对一个字符串使用的dp为二维数组。常见题型有之前做过的 最长回文子串，使用双指针，从两边向中间靠拢，二维分别指的是左侧指针和右侧指针的索引值。可以推广到最长回文子序列。 对两个字符串使用的dp为二维数组。例如 编辑距离 和 最长公共子序列 回文子序列的求解(LeetCode第516题)回文子序列的求解，是在回文子串的基础上进行的，dp[i][j] 的长度取决于s[i]和s[j]以及dp[i+1][j-1] 当s[i] == s[j]时，dp[i][j] = dp[i+1][j-1] + 2 当s[i] != s[j]时， dp[i][j] = Math.max(dp[i][j-1]，dp[i+1][j]) 当转移方程写好后，最大的难点就是如何遍历dp，建议采用表的形式，从方程中可以看到，我们必须得到左边、下边、左下，三个dp表达式才能得到下一个dp表达式，故可以采用斜着遍历的方式和逆循环从下往上遍历即可。 123456789101112131415161718192021222324/** * 斜着遍历的dp * @param nums * @return */ private static int dp(int[] nums)&#123; int[][] dp = new int[nums.length][nums.length];// Arrays.fill(dp, 0); int j = 0; for(int i = 0;i &lt; nums.length;i++)&#123; dp[i][i] = 1; &#125; //斜着循环遍历 for(int n = 1;n &lt; nums.length;n++)&#123; for(int i = 0; i &lt; nums.length - n;i++)&#123; j = i + n; if(nums[i] == nums[j]) dp[i][j] = dp[i+1][j-1] + 2; else dp[i][j] = Math.max(dp[i][j-1],dp[i+1][j]); &#125; &#125; return dp[0][nums.length-1]; &#125; 12345678910111213141516171819202122232425 /** * 逆循环遍历的dp * @param nums * @return */ private static int dpByInverse(int[] nums)&#123; int[][] dp = new int[nums.length][nums.length];// Arrays.fill(dp, 0);// int j = 0; int n = nums.length; for(int i = 0;i &lt; nums.length;i++)&#123; dp[i][i] = 1; &#125; // 反着遍历保证正确的状态转移 for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; // 状态转移方程 if (nums[i] == nums[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; return dp[0][nums.length-1]; &#125; 编辑距离（LeetCode第72题）先总结一哈：从后往前，然后写递归函数，然后画DP Table，写非递归，注意Base case！ 文章链接编辑距离 题目给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符示例 1: 123456输入: word1 = "horse", word2 = "ros"输出: 3解释: horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e') 示例 2: 12345678输入: word1 = "intention", word2 = "execution"输出: 5解释: intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 思路个人觉得公众号说的有的啰嗦哈~ 我就稍微总结一下我的想法： 拿到题目，又是两个字符串之间的问题，毫无疑问第一想法想到使用双指针的dp，因为一般遇到两个字符串的问题都是采用dp二维数组解决(双指针)； dp解决问题，首先就要搞清楚dp数组代表什么，其次就是状态转移有哪几种情况！ 一般dp二维数组 dp[i][j] ,代表以s1[i-1]、s2[j-1]结尾的转换的最少操作数，为啥是i-1,j-1！因为dp是从dp[1][1]开始的，代表字符串的第一个字符！！ 搞明白了dp数组是啥含义，现在就要搞清楚有哪几种状态转移，从公众号中可以看到，dp[i][j]想要往前移动，则可以进行删除、修改、插入操作，如果双指针指向的字符相同，则无需进行任何操作，直接向前移动就行，也就是此时 dp[i][j] = dp[i-1][j-1] ; 剩下的插入、删除、修改如何做呢…取三者最小值就好了嘛！！！ 其实这个画个DP表就非常的清晰了，画DP表也能提醒我们注意Base Case,因为没有Base Case ，我们是肯定写不出来DP表中的值的； 有个注意的点，就是备忘录做法是从0开始的，所以当i或者j = -1时，此时的i、j代表的是数组的下标，是从0开始的，比如说此时j = 5的，说明还有6个字符需要删除，所以要记得+1 ，而dp是从dp[1][1]开始的(比如两个字符串’’abc””acd”，dp[1][1]指的是都指向a)！！！！这个很容易错！ 三种做法 常规暴力递归(超时) 123456789101112131415161718192021class Solution &#123; public int minDistance(String word1, String word2) &#123; int len = dp_violence(word1,word2,word1.length()-1,word2.length()-1); return len; &#125; private int dp_violence(String s1,String s2,int i, int j) &#123; if(i == -1) return j + 1; if(j == -1) return i + 1; if(s1.charAt(i) == s2.charAt(j))&#123; return dp_violence(s1,s2,i-1,j-1); &#125; else&#123; int min = Math.min(dp_violence(s1,s2,i-1,j-1)+1, dp_violence(s1,s2,i-1,j)+1); min = Math.min( dp_violence(s1,s2,i,j-1)+1,min); return min; &#125; &#125;&#125; 带备忘录的递归(这个貌似比dp更优秀) 1234567891011121314151617181920212223242526272829class Solution &#123; public int minDistance(String word1, String word2) &#123; int[][] beiwanglu = new int[word1.length()][word2.length()]; int len = dp_beiwanglu(beiwanglu,word1,word2,word1.length()-1,word2.length()-1); return len; &#125; private int dp_beiwanglu(int[][] beiwanglu,String s1, String s2, int i, int j) &#123; if(i == -1) return j + 1; if(j == -1) return i + 1; if(beiwanglu[i][j] != 0)&#123; return beiwanglu[i][j]; &#125; if(s1.charAt(i) == s2.charAt(j))&#123; beiwanglu[i][j] = dp_beiwanglu(beiwanglu,s1,s2,i-1,j-1); return dp_beiwanglu(beiwanglu,s1,s2,i-1,j-1); &#125; else&#123; int min = Math.min(dp_beiwanglu(beiwanglu,s1,s2,i-1,j-1)+1, dp_beiwanglu(beiwanglu,s1,s2,i-1,j)+1); min = Math.min( dp_beiwanglu(beiwanglu,s1,s2,i,j-1)+1,min); beiwanglu[i][j] = min; return min; &#125; &#125;&#125; dp 1234567891011121314151617181920212223class Solution &#123; public int minDistance(String s1, String s2) &#123; int[][] dp = new int[s1.length()+1][s2.length()+1]; for(int i = 0;i&lt;= s1.length();i++)&#123; dp[i][0] = i; &#125; for(int j = 0;j&lt;=s2.length();j++)&#123; dp[0][j] = j; &#125; for(int i = 1;i&lt;= s1.length();i++)&#123; for(int j = 1;j &lt;= s2.length();j++)&#123; if(s1.charAt(i-1) == s2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125; else&#123; dp[i][j] = Math.min(dp[i-1][j-1] + 1,dp[i-1][j] + 1); dp[i][j] = Math.min(dp[i][j],dp[i][j-1] + 1); &#125; &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125; 最长公共子序列问题（LeetCode第1143题）典型的dp二维数组解决，太简单了… 第一个要注意的就是该dp可以优化，当双指针指向的字符不等时，dp[i-1][j-1]可以不用考虑！！！！因为max(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])是一定轮不到最后这个的； 第二个要注意的点就是记得Base Case,记得要画DP表！ 同样要注意这里的第一个字符串对应的就是dp[1][1]！！！！！ 代码1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int[][] dp = new int[text1.length() + 1][text2.length() + 1]; for(int i = 1;i &lt;= text1.length();i++)&#123; for(int j = 1;j &lt;=text2.length();j++)&#123; if(text1.charAt(i-1) == text2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[text1.length()][text2.length()]; &#125;&#125; 滑动窗口算法(示例:LeetCode第1143：最小覆盖子串问题) Tip：最重要的是过最后一个用例的艰辛，因为需要考虑到Integer是一个对象，超过-127~128之后会new一个新的对象，导致就算是值相等，其也会显示不相等！！！！！！！ 文章链接滑动窗口算法 代码文章中使用C++实现的，我是在LeetCode用的Java实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public String minWindow(String s, String t) &#123; // 利用双指针的思想，先记录下t会出现的单词以及次数 // 然后右指针开始遍历，每当一个单词及其次数到位后，当前单词就匹配完成，直到所有单词都匹配完成 // 然后记录下当前的子串的开始和结尾，即左右指针的位置 // 然后开始试图移动左指针，当然前提是t中所有字符然后全部匹配完成，否则就跳出循环，继续走右边指针 // 直到右边指针走到底，如果走到底长度依旧没有，则说明找不到最小子串，返回"" 否则返回适当的子串 int left = 0,right = 0; //计算匹配的单词数量 int match = 0; //统计目标字符串的不同字符的个数 int nums = 0; int min_length = Integer.MAX_VALUE; int start = 0; char[] t_char = t.toCharArray(); char[] s_char = s.toCharArray(); HashMap&lt;Character, Integer&gt; windows = new HashMap&lt;Character, Integer&gt;(); HashMap&lt;Character,Integer&gt; tt = new HashMap&lt;Character, Integer&gt;(); // 用两个map来存储两个字符串，存储方式为key为单词，value为单词出现的数量 // for (char t1: t_char)&#123; if(tt.containsKey(t1)) &#123; int value = tt.get(t1).intValue(); tt.put(t1, ++value); &#125; else&#123; nums++; tt.put(t1,1); &#125; &#125; while(right &lt; s.length())&#123; if(windows.containsKey(s_char[right]))&#123; int windows_value = windows.get(s_char[right]).intValue(); windows.put(s_char[right],++windows_value); &#125; else&#123; windows.put(s_char[right],1); &#125; //如果全部符合要求 if(tt.containsKey(s_char[right]) &amp;&amp; windows.get(s_char[right]).intValue() == tt.get(s_char[right]).intValue())&#123; match++; &#125; right++; while(match == nums)&#123; //说明已经找到一个符合条件的了，记录下该字符串的起始和结束位置 int Len = right - left; if(Len &lt; min_length) &#123; min_length = Math.min(min_length,Len); start = left; &#125; int left_value = windows.get(s_char[left]).intValue(); left_value--; windows.put(s_char[left],left_value); if(tt.containsKey(s_char[left]) &amp;&amp; windows.get(s_char[left]).intValue() &lt; tt.get(s_char[left]).intValue())&#123; match--; &#125; left++; &#125; &#125; return min_length == Integer.MAX_VALUE ? "" : s.substring(start,min_length +start); &#125;&#125; 最大子序列和(LeetCode第53题)先总结一下，可以运用 dp 和 滑动窗口 两种方法！！！ 题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路 dp 要的是子串，必然可以用dp，而且是单子串且非回文，则必然使用一维dp数组 只要定义好了dp数组，这道题就没有任何难度，dp[i]定义为以i为索引的字符结尾的最大和 则dp[i] = Math.max(dp[i-1],nums[i])，然后取dp[i]中最大的即可！ 这题只有一个小难点，那就是找Base Case,好像并不存在Base Case,但是我们可以创造Base Case,可以令dp[0] = nums[0]，这样就有Base Case了，同时注意哈，这里不需要将dp数组的大小变为nums.length+1,因为这个题目不存在Base Case,所以dp只会产生n个数，不需要n+1个存储空间，像上文的dp二维数组，就存在BaseCase，当有一个为0时，有相应的取值！总而言之，一定要特别注意dp的数组大小以及BaseCase。 滑动窗口 比较简单的思路。就是sum如果大于0了，就移动右指针就行，如果是小于0了，就比较sum和num[i]，取最大值(相当于移动左指针)，直到循环结束。 代码 dp 12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; //res[i] = Math.max(res[i-1] + nums[i],nums[i]) int[] res = new int[nums.length]; res[0] = nums[0]; int max = res[0]; for(int i = 1;i &lt; nums.length;i++)&#123; res[i] = Math.max(res[i-1] + nums[i],nums[i]); max = Math.max(res[i],max); &#125; return max; &#125;&#125; 滑动窗口 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = nums[0]; int sum = 0; for(int num:nums)&#123; if(sum &gt; 0) sum += num; else sum = num; res = Math.max(sum,res); &#125; return res; &#125;&#125; 打家劫舍 I、II、III (LeetCode第198、213、337)文章链接打家劫舍系列 I 的代码 自己写的(感觉写的有点啰嗦~) 123456789101112131415161718192021222324252627class Solution &#123; public int rob(int[] nums) &#123; int[] dp = new int[nums.length]; int res = 0; if(nums.length == 0 )&#123; return 0; &#125; if(nums.length == 1)&#123; dp[0] = nums[0]; res = dp[0]; return res; &#125; if(nums.length == 2)&#123; dp[1] = Math.max(nums[1],nums[0]); res = dp[1]; return res; &#125; dp[0] = nums[0]; dp[1] = Math.max(nums[1],nums[0]); for(int i = 2;i &lt; nums.length;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; res = Math.max(dp[nums.length-1],res) return res; &#125;&#125; 高分题解 123456789101112class Solution &#123; public int rob(int[] nums) &#123; int n = nums.length; if (n &lt;= 1) return n == 0 ? 0 : nums[0]; int[] memo = new int[n]; memo[0] = nums[0]; memo[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; n; i++) memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]); return memo[n - 1]; &#125;&#125; II 的代码分两次dp就好了，一次[0,nums.length-2]，一次[1,nums.length-1]，取最大值就好~ 12345678910111213141516171819202122232425262728293031class Solution &#123; public int rob(int[] nums) &#123; int[] dp = new int[nums.length]; int res = 0; if(nums.length == 0 )&#123; return 0; &#125; if(nums.length == 1)&#123; dp[0] = nums[0]; res = dp[0]; return res; &#125; if(nums.length == 2)&#123; dp[1] = Math.max(nums[1],nums[0]); res = dp[1]; return res; &#125; dp[0] = nums[0]; dp[1] = Math.max(nums[1],nums[0]); for(int i = 2;i &lt; nums.length-1;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; dp[1] = nums[1]; dp[2] = Math.max(nums[1],nums[2]); for(int i = 3;i &lt; nums.length;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; res = Math.max(dp[nums.length-1],dp[nums.length-2]); return res; &#125;&#125; III 的代码这是一个树形的dp问题，解决方法是采用一个一维数组，之前的I II只用到了dp[nums.length-1]，这里用到了两个,而且这里的dp竟然用了递归哟… Tip:特殊做法记忆记忆记忆！！！ 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robIn(root); return Math.max(res[0],res[1]); &#125; private static int[] robIn(TreeNode root)&#123; //用一个数组记录偷根节点和不偷根节点两种情况，这里很特殊用了dp同时还搭配了递归 //这就是自底向上的递归，详情可以见LeetCode递归专题 int[] res = new int[2]; if(root == null)&#123; return res; &#125; int[] left = robIn(root.left); int[] right = robIn(root.right); //偷根节点 res[0] = root.val + left[1] + right[1]; //不偷根节点 res[1] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]); return res; &#125;&#125;]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>LeetCode</tag>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode学习]]></title>
    <url>%2F2019%2F12%2F21%2Fleetcode%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[第1题：两数之和题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的思路 先排序 排除比target大的数 从最靠近target的数开始遍历 记录找到的数的下标输出即可 我的代码（未AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Arrays;public class twoNumbersSum &#123; public int[] twoSum(int[] nums, int target) &#123; //先排序 int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.sort(nums_copy); int i; //排除比target大的数 //从最靠近target的数开始遍历 //记录找到的数的下标，输出即可 int t; int k; for(i = nums_copy.length-1; i &gt; 0 ;i--)&#123; if(nums_copy[i] &lt;= target)&#123; if(Arrays.binarySearch(nums_copy,0,i,target-nums_copy[i]) &gt;= 0)&#123; if(nums_copy[i] * 2 == target) &#123; int[] twobro = new int[2]; int d=0; for(int h=0;h&lt;nums.length;h++)&#123; if(nums[h] == nums_copy[i])&#123; twobro[d] = h; d++; &#125; &#125; return twobro; &#125; else&#123; for(int m=0;m &lt; nums.length;m++)&#123; if(nums[m] == nums_copy[i])&#123; t = m; &#125; if(nums[m] == (target-nums_copy[i]))&#123; k = m; &#125; &#125; k = Arrays.binarySearch(nums,target-nums_copy[i]); t = Arrays.binarySearch(nums,nums_copy[i]); &#125; return new int[]&#123;k,t&#125;; &#125; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; twoNumbersSum tws = new twoNumbersSum(); int[] receive = new int[20]; receive = tws.twoSum(new int[]&#123;0,4,3,0&#125;,0); if(receive == null) &#123; System.out.println("不存在"); &#125; else&#123; System.out.println(receive[0] + "\n" + receive[1]); &#125; &#125;&#125; 正确思路利用 HashMap 记录数组元素值和对应的下标，对于一个数 nums[i]，判断 target - nums[i] 是否存在 HashMap 中，存在的话，返回两个下标组成的数组。注意，已存在的元素下标在前，当前元素下标在后。 正确代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) &#123; return new int[] &#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125;&#125; 涉及的知识点数组内容 一维和二维数组一维数组：int[] a = new int[4];二维数组： 1234//第一行4个元素，第二行5个元素int[][] a = new int[2][];a[0] = new int[4];a[1] = new int[5]; Arrays类java.util.Arrays类能够方便的操作数组，提供的所有方法都是静态的： 12345678910import java.util.Arrays;public int[] twoSum(int[] nums, int target) &#123; int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.fill(nums,2); Integer index = Arrays.binarySearch(nums,target); Arrays.equals(nums,nums_copy); Arrays.sort(nums); return new int[]&#123;0,0,0&#125;;&#125; 总共5个方法，分别是copyOf,fill,binarySearch,equals,sort。第一个用来复制原始数组，方便后续排序的操作，fill是用来初始化数组比较方便，可以将所有数组中的值全部初始化为同一个值，binarySearch是二分查找，返回的是该数的索引值，sort是用来排序的。 binarySearch()自己写代码的时候用到了这个方法，首先该方法需要数组排好序才能调用，其次很特别的是，如果要找的值在数组中，则会返回搜索键的索引，但是，注意：值不存在于数组的话会返回-1或者是目标值需要插入的位置，从1开始数起，不是0哦！！！这个写的贼好哈哈哈哈：数组查询Arrays类的binarySearch()方法详解 map.containsKey和map.get()区别hashmap判断是否存在key时，使用get(key)==null判断还是containsKey？key值可能为null，若此时Map集合值对象为null，并且没有个数限制，所以当get()方法的返回值为null时，可能有两种情况，一种是在集合中没有该键对象，另一种是该键对象没有映射任何值对象，即值对象为null。因此，在Map集合中不应该利用get(Object key)方法来判断是否存在某个键，而应该利用containsKey()方法来判断,containsKey方法用来判断Map集合对象中是否包含指定的键名。一句话概括:get()如果得到null，可能这是键对应的值对象为null也可能是不存在该键，而containsKey则是false或true，不存在这种疑问。 扩充:map.containsKey()、map.containsValue()、map.get() get的过程是先计算hash，然后通过hash与table.length取摸计算index值，然后遍历table[index]上的链表，直到找到key，然后返回； 1234567891011121314public V get(Object key) &#123; if (key == null) return getForNullKey();//处理null值 int hash = hash(key.hashCode());//计算hash //在table[index]遍历查找key，若找到则返回value，找不到返回null for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; containsKey方法也是先计算hash，然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值； 123456789101112131415public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 看代码能看到区别，一个是返回key对应的value值，一个是返回是否有该key的boolean变量。 containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效。 1234567891011public boolean containsValue(Object value) &#123; if (value == null) return containsNullValue(); Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; 知识缺陷 压根没想到用Map去做 自己只考虑到了全是正数的情况，所以用了排序和跟0判断，如果含有负数的话就做不了了…… 收获在遇到数组问题时，可以考虑用map，因为索引和数值就是一个天生的map集合，如果我知道数值，我就可以通过map找到其索引，本题思路就是这样，当已知一个值是我所需要的，直接从map中拿出就行。 插入知识点既然复习到了map，那就给list、set和map来一个全部的复习吧！！！嘿嘿开始吧！！！先来上个链接，主要是看的这个写的：Java集合中List,Set以及Map等集合体系详解(史上最全) collection先上个图：这个图画的好啊哈哈哈哈哈哈哈不瞎的都看得到，Collection这个接口下有三个接口继承，分别是Set、List、Queue(我他妈好像没怎么用过Queue啊，以后要多用点了)，Set有三个实现类，分别是HashSet、LinkedHashSet、TreeSet，List有三个实现类，分别是ArrayList、Vector(感觉现在是不是用的比较少啊…)、LinkedList，咦这个LinkedList牛逼啊，竟然还是Queue的实现类，不过看别人博客好像是说继承Queue部分的LinkedList是被阉割了的实现类，也就是Queue不能访问到LinkedList的所有方法(管它呢我都没用过…)，还有一个PriorityQueue,看名字就知道是优先级队列啦！(妈呀看的资料太多，想单独开一篇来总结集合源码和Map源码了…算了先这样写着吧) ####先列个提纲： 1.先综述一下collection中三个儿子接口得各个实现类的特点，比如底层实现，优缺点等等； 2.分别阐述，分述时记得贴上源码分析 3.面试常问到的点 综述— List 有序,可重复 ArrayList优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高特点: 允许null，不同步Vector优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低tips:所谓的线程安全，是相对的，在vector内部内部内部，其所有方法不会被多线程所访问，单个方法的原子性（注：原子性，程序的原子性即不会被线程调度机制打断），并不能保证复合操作也具有原子性，所以如果是复合操作，同样线程不安全！！如果要保证真正的线程安全，还需要以vector对象为锁，来进行操作，但这样就跟ArrayList没啥区别了…———–&gt; Vector是线程安全吗特点：允许null，不同步LinkedList优点: 底层数据结构是双向链表，查询慢，增删快。故既可以做Queue，又可以做Stack。缺点: 线程不安全，效率高特点：允许null，不同步 —Set 无序,唯一 HashSet（不同步，允许null）底层数据结构是哈希表(无序,唯一)，其实就是HashMap的实例，只不过值是key，value是一个固定的对象。如何来保证元素唯一性?1.依赖两个方法：hashCode()和equals() LinkedHashSet（不同步，允许null）底层数据结构是双向链表和哈希表。(FIFO插入有序,唯一)，实际上依旧是LinkedHashMap的实例，待会源码分析看看1.由链表保证元素有序2.由哈希表保证元素唯一 TreeSet（允许null，不同步）底层数据结构是红黑树。(唯一，有序，这里的有序指的是排序好的，不是说FIFO之类的)，实际上依旧是TreeMap的实例 如何保证元素排序的呢?自然排序(重写):1.Student类中实现 Comparable接口 2.重写Comparable接口中的Comparetor方法比较器排序:1.单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口 2.重写Comparator接口中的Compare方法2.如何保证元素唯一性的呢?根据比较的返回值是否是0来决定 -Queue PriorityQueue：优先级队列，按照大小排序好了的队列，并不遵循先进先出，不允许null元素，头部是最小元素，底层采用的数组和堆。 PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。 不允许插入 null 元素。 PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。 方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。剩余有关Queue队列看—–&gt; Java集合（七） Queue详解 分别阐述这个还是另开一篇吧…内容太多了…够写两星期了！！还是不放在这喧宾夺主了!! map 具体展开见另一篇博客：Map源码分析 第2题：两数相加题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路 先讲输入输出。要输入两个链表，首先就要构造Node实体类，注意构造函数有多个，根据参数的不同进行选择，输出同输入，将组合好的链表的头结点(有数据的)返回后，就可以循环将整个链表打印出来了； 再讲实现。见代码注释。 我的代码（AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package 链表实现_java.leecode第二题;public class leecode_second_Link &#123; public static void main(String[] args) &#123; Node head = new Node(2); Node node1 = new Node(5); Node node2 = new Node(8); Node node3 = new Node(7); head.setNext(node1); node1.setNext(node2); node2.setNext(node3); // 打印链表1 Node temp = head; while (temp != null) &#123; if(temp.next == null) &#123; System.out.println(temp.getData()); &#125; else &#123; System.out.print(temp.getData() + "--&gt;"); &#125; temp = temp.getNext(); &#125; System.out.println("+"); Node head_sec = new Node(2); Node node1_sec = new Node(4); Node node2_sec = new Node(6); Node node3_sec = new Node(7); head_sec.setNext(node1_sec); node1_sec.setNext(node2_sec); node2_sec.setNext(node3_sec); // 打印链表2 Node temp1 = head_sec; while (temp1 != null) &#123; if(temp1.next == null) &#123; System.out.println(temp1.getData()); &#125; else &#123; System.out.print(temp1.getData() + "--&gt;"); &#125; temp1 = temp1.getNext(); &#125; System.out.println("="); Node head3 = new leecode_second_Link().addTwoNums(head,head_sec); //打印总和链表 Node temp3 = head3; while(temp3 != null)&#123; if(temp3.next == null) &#123; System.out.println(temp3.getData()); &#125; else &#123; System.out.print(temp3.getData() + "--&gt;"); &#125; temp3 = temp3.getNext(); &#125; &#125; public Node addTwoNums(Node head1,Node head2)&#123; //没啥用，初始化头结点(可以不带数据) Node res = new Node(0); //temp是后面用来遍历链表的 Node temp = res; //这个是商，用来进位给下一位的 int quo = 0; //循环，只有当第一个链表中的值为空且第二个链表中的值为空且没有了进位，计算才算结束 while(head1 != null || head2 != null || quo != 0)&#123; //t为两链表相同位置的和加上前面一位的进位 int t = (head1 == null ? 0 : head1.data ) + (head2 == null ? 0 : head2.data) + quo; //商 quo = t/10; //新链表在该位的值 Node head3 = new Node(t % 10); //新链表的第一个值 temp.next = head3; //只有这样，才能让链表next下去，这两步要学会，以后链表经常要用 temp = head3; //分别看两个链表是否为空，如果为空说明该位已经没了，否则就next下去 head1 = (head1 == null ? head1 : head1.next); head2 = (head2 == null ? head2 : head2.next); &#125; //返回链表第一个有值的节点，相当于有值的头结点 return res.next; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package 链表实现_java.leecode第二题;public class Node &#123; //数据域 public Integer data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; public void setData(int Data) &#123; this.data = Data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node Next) &#123; this.next = Next; &#125;&#125; 正确思路同时遍历两个链表，对应值相加(还有 quotient)求余数得到值并赋给新创建的结点。而商则用quotient存储，供下次相加。 正确代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//复杂版/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(-1); ListNode cur = res; int quotient = 0; int t = 0; while (l1 != null &amp;&amp; l2 != null) &#123; t = l1.val + l2.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l1 = l1.next; l2 = l2.next; cur = node; &#125; while (l1 != null) &#123; t = l1.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l1 = l1.next; cur = node; &#125; while (l2 != null) &#123; t = l2.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l2 = l2.next; cur = node; &#125; if (quotient != 0) &#123; cur.next = new ListNode(quotient); cur = cur.next; &#125; return res.next; &#125;&#125; 1234567891011121314151617181920212223242526//简化版/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(-1); ListNode cur = res; int quotient = 0; while (l1 != null || l2 != null || quotient != 0) &#123; int t = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; cur = node; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return res.next; &#125;&#125; 涉及的知识点java中的单链表见我写的另外一篇博文 ——&gt; Java实现单向链表 第3题：无重复字符的最长子串题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 我的思路要找到一个最长子串，就必须有一头一尾，所以就必须有两个指针，然后又是字符串对应索引值，所以肯定是需要用map来操作的，key为索引值，value为索引所在位置的值。于是设定两个指针p、q，最开始同时指定在最开始的位置，然后q向后移动，每移动一次，只要q对应的值没有在map中，就将其值放入map，并且记录下串的大小，当碰到了map中相同的值时，就将p向后移到map中出现该值的索引后一位，同时注意！！！此时p可能会回溯，所以此时要用max函数判断一下，然后继续判断串的大小和继续遍历的最长子串的长度，最后返回最长子串长度即可。 我的代码（AC）1234567891011121314151617181920212223242526272829303132package 第三题;import java.util.HashMap;import java.util.Scanner;public class lengthOfLongestSubstring &#123; public static void main(String[] args) &#123; Scanner a = new Scanner(System.in); System.out.println("请输入串: "); String string = a.nextLine(); int num = new lengthOfLongestSubstring().lengthofSubstring(string); System.out.println("最长子串的长度为：" + num); &#125; private int lengthofSubstring(String string) &#123; int max = 0; char[] chars = string.toCharArray(); int p=0,q=0; int len = chars.length; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while(q &lt; len)&#123; if(map.containsKey(chars[q]))&#123; p = Math.max(p,map.get(chars[q])+1); &#125; map.put(chars[q],q); max = Math.max(max,q-p+1); q++; &#125; return max; &#125;&#125; 正确思路利用指针 p, q，初始指向字符串开头。遍历字符串，q 向右移动，若指向的字符在 map 中，说明出现了重复字符，此时，p 要在出现重复字符的下一个位置 map.get(chars[q]) + 1 和当前位置 p 之间取较大值，防止 p 指针回溯。循环的过程中，要将 chars[q] 及对应位置放入 map 中，也需要不断计算出max 与 q - p + 1 的较大值，赋给 max。最后输出 max 即可。 正确代码123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; char[] chars = s.toCharArray(); int len = chars.length; int p = 0, q = 0; int max = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (q &lt; len) &#123; if (map.containsKey(chars[q])) &#123; // 防止p指针回溯，导致计算到重复字符的长度 // eg. abba,当q指向最右的a时，若简单把p赋为map.get(chars[q] + 1)，则出现指针回溯 p = Math.max(p, map.get(chars[q]) + 1); &#125; map.put(chars[q], q); max = Math.max(max, q - p + 1); ++q; &#125; return max; &#125;&#125; 涉及的知识点好像并没有啥新知识点，其实就是用map代替指针的作用。 第237题： 删除链表中的节点题目请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 示例示例 1 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 我的思路本题题干个人觉得没有交代的很清楚，让人感觉有点摸不着头脑，正常来说应该是给定两个参数，但是要写的函数只有一个参数，所以最开始会让人感觉很突兀，但是实际上这道题设计的很巧妙，不需要给定头结点，可以采用替身攻击，给定的node其实就可以当做头结点来处理，因为不可能是最后一个节点，所以后面一定有节点，故可以将node后节点牺牲掉，这样就相当于将node本身干掉了。 个人遇到的困难主要是在输入输出，尤其是构造单链表的过程花费了比较长的时间，总而言之还是对单链表的操作不够熟练，接下来会重点攻克单链表这一块的知识点！ ##我的代码（AC） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package 第237题_删除链表中的节点;import java.util.ArrayList;import java.util.Scanner;public class deleteNode &#123; public static void main(String[] args) &#123; System.out.println("请输入一串数字代表链表："); Scanner sc = new Scanner(System.in); String head = sc.nextLine(); char[] chars = head.toCharArray();// System.out.println(chars); ArrayList list = new ArrayList(); Node head_first = new Node(-1); Node temp = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp.next = new Node(Integer.parseInt(String.valueOf(chars[i]))); temp = temp.next; list.add(chars[i]); &#125; System.out.println("您输入的链表为： "+ list); System.out.println("请您输入要删除的数字："); String data = sc.nextLine(); int data_int = Integer.parseInt(data); Node temp1 = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp1 = temp1.next; if(data_int == temp1.data)&#123; deleteNode(temp1); break; &#125; &#125; System.out.println("删除后的链表为："); Node temp3 = head_first.next; for(int i = 0 ; i &lt; chars.length-1 ; i++) &#123; System.out.print(temp3.data + " "); temp3 = temp3.next; &#125; System.out.println("\n"); &#125; public static void deleteNode(Node node) &#123; Node tmp = node.next; node.data = node.next.data; node.next = node.next.next; tmp = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package 第237题_删除链表中的节点;public class Node &#123; //数据域 public Integer data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; public void setData(int Data) &#123; this.data = Data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node Next) &#123; this.next = Next; &#125;&#125; 正确思路只提供 node 依然可以解决此题。只要把下个结点的 值 &amp; next 赋给当前 node，然后删除下个结点，就可以搞定。 正确代码12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; // 保存下一个结点 ListNode tmp = node.next; // 将下个结点的值赋给当前要删除的结点 node.val = node.next.val; node.next = node.next.next; // tmp 置为空，让 jvm 进行垃圾回收 tmp = null; &#125;&#125; 涉及的知识点 链表的构建 链表删除 不足对链表操作还不是很驾轻就熟，接下来会重点训练链表操作。 第19题：删除链表的倒数第N个节点题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 我的思路删除倒数第n个节点，这个思路比较简单，就是运用两个指针 fast 和 slow ，一个指针比另外一个多n-1步，这样的话当fast指针到最后一个节点的时候，slow指针刚好到达要删除的节点的位置，此时就可以用上题用过的替身牺牲法，牺牲掉要删除节点的下一个节点，只需要将下一个节点的值赋值给当前节点并且将slow.next = slow.next.next即可。但是，有特殊情况 ： 当要删除的节点是最后一个时，无法做到用下一个节点替换，这个时候就要提前预判，不能等到slow到了最后一个节点才考虑删除，要在slow.next.next == null时就考虑！！！ 我的代码（AC）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package 第19题;//import 第237题_删除链表中的节点.Node;import java.util.ArrayList;import java.util.Scanner;public class removeNthFromEnd &#123; public static void main(String[] args) &#123; System.out.println("请输入一串数字代表链表："); Scanner sc = new Scanner(System.in); String head = sc.nextLine(); char[] chars = head.toCharArray();// System.out.println(chars); ArrayList list = new ArrayList(); ListNode head_first = new ListNode(-1); ListNode temp = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp.next = new ListNode(Integer.parseInt(String.valueOf(chars[i]))); temp = temp.next; list.add(chars[i]); &#125; System.out.println("您输入的链表为： "+ list); System.out.print("请您输入要删除的倒数第n个数的节点，n = "); String number = sc.nextLine(); int num = Integer.parseInt(number); ListNode result_node = removeNthFromEnd(head_first.next,num); ListNode temp1 = result_node; while(temp1 != null)&#123;// int data = Integer.parseInt(String.valueOf(temp1.val)); System.out.print(temp1.val); temp1 = temp1.next; &#125; &#125; public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(-1); pre.next = head; ListNode fast = pre; ListNode slow = pre; // 快指针先走 n-1 步 for (int i = 0; i &lt; n-1; ++i) &#123; fast = fast.next; &#125; while (fast.next != null &amp;&amp; slow.next.next != null) &#123; fast = fast.next; slow = slow.next; &#125;// ListNode tmp = slow.next; if(slow.next.next == null &amp;&amp; (n == 1)) &#123; slow.next = null; &#125; else &#123; slow.val = slow.next.val; slow.next = slow.next.next;// tmp = null; &#125; return pre.next; &#125;&#125; 12345678910package 第19题;public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; 正确思路快指针 fast 先走 n 步，接着快指针 fast 与慢指针 slow 同时前进，等到快指针指向链表最后一个结点时，停止前进。然后将 slow 的 next 指向 slow.next.next，即删除了第 n 个结点。最后返回头指针。 这里设置了 pre 虚拟结点(指向 head )是为了方便处理只有一个结点的情况。 正确代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(-1); pre.next = head; ListNode fast = pre; ListNode slow = pre; // 快指针先走 n 步 for (int i = 0; i &lt; n; ++i) &#123; fast = fast.next; &#125; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return pre.next; &#125;&#125; 涉及的知识点单链表的删除…比较简单啦 不足个人感觉其实答案的解法还是要比我的好一些，它是通过直接找到删除节点的前一个，这样就非常好处理了，而且还没有特殊情况…我就很笨了，还自以为是的用了一个替身攻击的方法…学到了！！！要记得用到删除节点的前一个节点，这才是单链表的关键。 第21题：合并两个有序链表题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 我的思路创建一个新链表，然后比较两个链表，哪个小就让新链表的next指向他，如果有一个提前结束了，剩下的链表接上新链表的后半部分。 我的代码（AC）123456789101112131415161718192021public static ListNode merge(ListNode l1, ListNode l2)&#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; // exactly one of l1 and l2 can be non-null at this point, so connect // the non-null list to the end of the merged list. prev.next = l1 == null ? l2 : l1; return prehead.next; &#125; 1234567package 第21题;public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 正确思路利用链表天然的递归性。如果 l1 为空，返回 l2；如果 l2 为空，返回 l1。如果 l1.val &lt; l2.val，返回 l1-&gt;mergeTwoLists(l1.next, l2)；否则返回 l2-&gt;mergeTwoLists(l1, l2.next)。 正确代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 涉及的知识点链表算法题面试必看必看必看！！！！！！！ 第23题：合并K个排序链表题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 我的思路我没做出来，然后看了下讨论区，大概总结出三种思路： * 运用优先级队列，将整个链表扔到优先级队列中，然后一个个取出来就可以了，这种思路代码实现比较简单，但是用了人家封装好的东西，总感觉有点投机取巧的感觉... * 运用分治归并的思想，K个链表两两进行归并。 * 强行归并，两个归并完直接放到后者，然后后者再跟后面的排序，这样复杂度很高。 我的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; int len = lists.length; if (len == 1) &#123; return lists[0]; &#125; // 合并前后两个链表，结果放在后一个链表位置上，依次循环下去 for (int i = 0; i &lt; len - 1; ++i) &#123; lists[i + 1] = mergeTwoLists(lists[i], lists[i + 1]); &#125; return lists[len - 1]; &#125; /** * 合并两个有序链表 * @param l1 * @param l2 * @return listNode */ private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 正确思路 第一种，优先级队列，20ms, 复杂度 时间复杂度： O(N\log k)O(Nlogk) ，其中 \text{k}k 是链表的数目。弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。最后的链表中总共有 N 个节点。 空间复杂度：O(n) 。创造一个新的链表需要 O(n) 的开销。O(k) 。以上代码采用了重复利用原有节点，所以只要 O(1) 的空间。同时优先队列（通常用堆实现）需要 O(k) 的空间（远比大多数情况的 N要小）。 过程： 1.因为链表有序，所以用每个链表的首元素构建初试堆(小顶堆) – 的队列 2.首元素出队，该元素next指向元素入队 第二种，归并分治，典型的归并分治思想，自底向上，依次合并(可结合归并排序理解，将每个链表理解成排序的值)。 复杂度分析 时间复杂度： O(N\log k)O(Nlogk) ，其中 \text{k}k 是链表的数目。 空间复杂度：O(1)O(1) 我们可以用 O(1) 的空间实现两个有序链表的合并。 第三种，强行做。见我的代码，170ms 用第一个链依次和后面的所有链进行双链合并，利用021的双顺序链合并，秒杀！但是效率极低， 时间复杂度是O(x(a+b) + (x-1)(a+b+c) + … + 1 * (a+b+…+z);[a-z]是各链表长度，x表示链表个数-1，可见时间复杂度是极大的。 正确代码 优先级队列 12345678910111213141516171819202122public ListNode mergeKLists(ListNode[] lists) &#123; int len = 0; if((len=lists.length)==0 || lists == null) return null; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(len, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val - o2.val; &#125; &#125;); for (ListNode node : lists) &#123; if(node!=null) queue.add(node); &#125; while(!queue.isEmpty())&#123; ListNode small = queue.poll(); preNode.next = small; if(small.next!=null) queue.add(small.next); //将最小值节点后面的节点添加到队里中 preNode = preNode.next; &#125; return preHead.next; &#125; 归并分治 1234567891011121314151617181920212223242526272829303132333435363738394041/* * @lc app=leetcode.cn id=23 lang=java * * [23] 合并K个排序链表 */// @lc code=start/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return merge(lists, 0, lists.length - 1); &#125; private ListNode merge(ListNode[] lists, int left, int right) &#123; if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l1 = merge(lists, left, mid); ListNode l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125; &#125; 涉及的知识点包括了优先级队列、最小堆、归并以及 分治的思想 优先级队列。java中的优先级队列是PriorityQueue，是通过最小堆实现的 最小堆 归并 分治 第5题 最长回文子串题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例示例 1： 123输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。 示例 2： 12输入: "cbbd"输出: "bb" 我的思路 最开始的想法是将源字符串翻转，然后判断翻转后的字符串和源字符串的最长公共子序列，但是貌似有点问题，例如accbbdcca翻转后变为accdbbcca,最长公共子序列为acc，但是最长回文子串为bb。 但是上面的思路有可取之处，其实遇到回文子串最核心的问题是从中间开始依次比较左右是否相等，直到不相等，返回左右相等的子串，当然还有一个问题，就是该回文子串可能是单数，也可能是双数，单数的话，直接比较该数的左右即可，双数则需要先判断最开始两数是否相等。 时间复杂度是O(n²)，空间复杂度O(1) 我的代码（AC）美其名曰 中心扩展算法 12345678910111213141516171819202122232425262728package Dynamic_Programming.最长回文子串;public class Solution &#123; public static String longestPalindrome(String s) &#123; String res = ""; for(int i = 0;i &lt; s.length(); i++)&#123; String single = palindrome(s,i,i); String dou = palindrome(s,i,i+1); res = res.length() &gt; single.length() ? res : single; res = res.length() &gt; dou.length() ? res : dou; &#125; return res; &#125; private static String palindrome(String s, int left, int right) &#123; char[] s1 = s.toCharArray(); while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s1[left] == s1[right])&#123; left--; right++; &#125; return s.substring(left + 1,right); &#125; public static void main(String[] args) &#123; String res = longestPalindrome("aaabaacc"); System.out.println(res); &#125;&#125; 正确思路和代码dp12345678910111213141516171819202122232425 private static String dp(String s)&#123; //每次都忘记了边界处理 if(s == null || s.length() &lt; 1)&#123; return ""; &#125; char[] s1 = s.toCharArray(); int len = s1.length; int max = 1;// int over = 1; int start = 0; boolean res[][] = new boolean[len][len]; //此时的j是最右边的数 //此时的i是最左边的数 for(int j = 0; j &lt; s1.length; j++)&#123; for(int i = 0; i &lt;= j ;i++ )&#123; res[i][j] = (j &lt;= i + 2) ? s1[i] == s1[j] : res[i+1][j-1] &amp;&amp; s1[i] == s1[j]; if(res[i][j] &amp;&amp; max &lt; j - i + 1)&#123; max = j - i + 1; start = i; &#125; &#125; &#125; return s.substring(start,start + max); &#125; 关键就是暴力法： res[i][j] = (j &lt;= i + 2) ? s1[i] == s1[j] : res[i+1][j-1] &amp;&amp; s1[i] == s1[j]; 上面就是dp最为关键的状态转移递推式，为什么在dp中不用考虑回文串长度的奇偶呢，因为我的方法中是从中间扩散，那么就必然需要分类，而dp是从两边向中间靠，要是回文串首尾必须相同，而当回文串小于等于3时，只要比较的首尾相等，则无需再比较，这样回文串的奇偶就不需要再考虑了。 细细想来，其实dp就是中心扩展方法的逆，一个是从中间向两边发散，一个是两边向中间靠拢！！ Tips： 注意边界处理，因为 str.substring 这个是不允许字符串为 null 的 时间复杂度为O(n²)，空间复杂度为O(n²) 注意二维数组的维度分别是代表首和尾，子串是否为回文串取决于子子串和首尾是否相等，要注意base case是子串为1个字符时，它必为回文子串 最核心的就是状态转移的条件，是分为两种小情况，一种是当源字符串长度&lt;=3时 当源字符串元素个数为3个，若左右边界相等，则去掉他们，只剩一个字符，必为回文串 当源字符串元素个数为2个，若左右边界相等，则必为回文串 此时该串是否为回文串就取决于首尾，另一种情况是当源字符串长度&gt;3时，则需要判断首尾是否相等并且去除首尾后的子串是否为回文串 当发现有回文串时，则判断一下长度是否比之前发现的长，如果是，则记录长度，并且将最长回文串的起始位置拿到，最后全部循环完一遍后截取最长回文串即可 部分知识点补充暂无 第96题 不同的二叉搜索树题目描述给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法原问题可拆解为子问题的求解。 二叉搜索树，可以分别以 1/2/3..n 做为根节点。所有情况累加起来，也就得到了最终结果。 res[n] 表示整数n组成的二叉搜索树个数。它的左子树可以有0/1/2...n-1 个节点，右子树可以有n-1/n-2...0 个节点。res[n] 是所有这些情况的加和。 时间复杂度分析：状态总共有 n 个，状态转移的复杂度是 O(n)，所以总时间复杂度是 O(n²)。 普通的dp 123456789101112class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; for(int i=1;i&lt;=n;i++)&#123; for(int j =1;j&lt;=i;j++)&#123; dp[i] += dp[j-1] * dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; 上面的解法明显还可以得到改进，因为左-右子树的节点个数为0,n-1,和左右子树节点个数为n-1,0。这两者的二叉搜索树的结果肯定是一致的，所以我们就没有必要算两遍。但是同时要考虑到奇偶的问题。 如果n=4，那么G(4) = G(0) G(3) + G(1) G(2) + G(2) G(1) + G(3) G(0) = 2[G(0) G(3) + G(1) G(2)] 如果n=5，那么G(5) = G(0) G(4) + G(1) G(3) + G(2) G(2) + G(3) G(1) + G(4) G(0) = 2[G(0) G(4) + G(1) G(3) ] + G(2) G(2) 12345678910111213141516171819202122232425262728class Solution &#123; public int numsTrees2(int n)&#123; if (n == 0) &#123; return 0; &#125; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; // 长度为 1 到 n for (int i = 2; i &lt;= n; i++) &#123; // 将不同的数字作为根节点，只需要考虑到 len for (int root = 1; root &lt;= i / 2; root++) &#123; int left = root - 1; // 左子树的长度 int right = i - root; // 右子树的长度 dp[i] += dp[left] * dp[right]; &#125; dp[i] *= 2;// 利用对称性乘 2 // 考虑奇数的情况 if ((i &amp; 1) == 1) &#123; int root = (i &gt;&gt; 1) + 1; int left = root - 1; // 左子树的长度 int right = i - root; // 右子树的长度 dp[i] += dp[left] * dp[right]; &#125; &#125; return dp[n]; &#125;&#125; 知识点补充 LeetCode二叉树专题——&gt;DFS和BFS 第95题 不同的二叉搜索树II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例123456789输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]] 解释1234567以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法这题就是典型的运用递归去做，明确三个点： 递归出口 递归返回值 一级递归需要做什么 递归出口当树没有节点了，递归结束，怎么表示树没有节点呢，所以就需新建一个函数，参数包括节点的起始和终止。 递归返回值返回值很明显就是符合条件的各种二叉树,是一个含根节点的列表(根据题目最终需要得到的)。 一级递归需要做什么这个是比较难的地方，我们来缕缕现在有什么，我们现在有三个节点，根节点，左子树根节点，右子树根节点，这三个节点我们可以随意将任意一个节点当做根节点，然后去组合得到新的搜索二叉树。注意！！！我们只需要关注一级递归就可以了，无需关注太多，我们现在手上假设就三个节点分别是1,2,3，首先要做的就是遍历1，2，3，分别将其作为根节点，假设以2为根节点，1代表就是左子树返回的根节点列表，3代表的是右子树返回的根节点列表，我们要做的就是遍历左右子树的根节点列表，分别将其添加到根节点的左右子树，然后将该根节点添加至列表，返回列表即可。 代码12 部分知识点补充明天继续进军二叉树部分 同时复习并且捡回来原先要完成的集合那部分的源码分析！（2020.1.1） 杨辉三角(118)Tip:今天第一次写题解，还是非常开心的！！！！！ 今天重点就是掌握了一下递归的思想，最重要的三点！！！！！ 递归思想 找整个递归的终止条件 找返回值 本地递归需要如何操作 主要参考：递归 题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 思路方法一：递归递归方法总而言之就是抓住三点： 找整个递归的终止条件 找返回值 一次递归需要如何操作 找整个递归的终止条件咱来分析一下题目，递归到numRows = 0 时或者numRows = 1时都可以终止，因为第一行比较特殊，只有一个1,所以我们可以将其当成整个递归的终止条件，当numRows = 1时，我们就可以终止递归向下返回值了。 找返回值找返回值，我们也需要分析下，题目要我们求的是整个杨辉三角的所有数，那最后递归得到的应该就是 List&lt;List&lt;Integer&gt;&gt; (题目给定)，也就是每递归完一层，我们就更新完List并返回即可，最后递归完成就是我们要的答案。 一次递归需要如何操作递归的难点就在这里，很多童靴刚学递归时，总是在这里搞晕，其实我们只需要关注一次递归即可，因为每一层递归的过程都是一样的，我们只需要找到最上层的递归的规律，就可以了。 如图所示，我们只需要分析第二行到第三行这级递归即可！先上代码！ 递归 代码12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; //存储要返回的杨辉三角 List&lt;List&lt;Integer&gt;&gt; dg = new ArrayList&lt;&gt;(); //若0行，则返回空 if(numRows == 0)&#123; return dg; &#125; //递归出口，这是第一步！找到出口 if(numRows == 1)&#123; dg.add(new ArrayList&lt;&gt;()); dg.get(0).add(1); return dg; &#125; //递归，注意返回值！！！这是第二步 dg = generate(numRows-1); //一级递归要做啥，我们可以看第二行到第三行需要做啥 //首先是要申请一个list来存储第三行，然后通过第二行得到第三行 //第三行的首尾为1是确定了的，然后就是中间的数如何得到 //通过观察很容易拿到for循环里面的式子 //最后别忘了返回值！！！ List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); for(int j = 1;j &lt; numRows - 1;j++)&#123; row.add(dg.get(numRows-2).get(j-1) + dg.get(numRows-2).get(j)); &#125; row.add(1); dg.add(row); return dg; &#125;&#125; 方法二：动态规划思路其实差不多，只是一个递归，一个变成了迭代而，仅此而已！ 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; dp = new ArrayList&lt;&gt;(); if(numRows == 0)&#123; return dp; &#125; dp.add(new ArrayList&lt;&gt;()); dp.get(0).add(1); //注意这里的 i 是指行数，但是dp是从0开始的 //所以preRow是i-2 for(int i = 2;i &lt;= numRows;i++)&#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;Integer&gt; preRow = dp.get(i-2); row.add(1); for(int j = 1;j &lt; i-1;j++)&#123; row.add(preRow.get(j) + preRow.get(j-1)); &#125; row.add(1); dp.add(row); &#125; return dp; &#125;&#125; 单词拆分(139)123456789101112131415class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] dp = new boolean[s.length()+1]; dp[0] = true; for(int i = 1;i &lt;= s.length();i++)&#123; for(int j = 0;j &lt; i;j++)&#123; if(dp[j] == true &amp;&amp; wordDict.contains(s.substring(j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 解码方法(91)题目描述1234567一条包含字母 A-Z 的消息通过以下方式进行了编码：'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例1234567891011示例 1:输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。示例 2:输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 思路所有可以用dp的，基本都有三个方法： 递归 ——-&gt; 带备忘录的自顶向下 ——-&gt; dp 递归1234567891011121314151617181920212223242526272829class Solution &#123; public int numDecodings(String s) &#123; if(s.length() == 0 || s == null)&#123; return 0; &#125; return numDecodingsByRecrusion(s,0,s.length()-1); &#125; private int numDecodingsByRecrusion(String s,int start,int end)&#123; //1.递归出口：数字为最后一个数字时即结束递归 //2.返回值：返回解码方法数 //3.一次递归的过程 if(start &gt; end)&#123; return 1; &#125; if(s.charAt(start) == '0')&#123; return 0; &#125; if(start == end)&#123; return 1; &#125; int num1 = numDecodingsByRecrusion(s,start+1,end); int num2 = 0; if((s.charAt(start) - '0') * 10 + (s.charAt(start+1)-'0') &lt;= 26)&#123; num2 = numDecodingsByRecrusion(s,start+2,end); &#125; return num1+num2; &#125;&#125; 带备忘录的自顶向下123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numDecodings(String s) &#123; if(s.length() == 0 || s == null)&#123; return 0; &#125; // int res = numDecodingsByRecrusion(s,0,s.length()-1); // int res = numDecodingsByDp(s); HashMap&lt;Integer,Integer&gt; memo = new HashMap&lt;&gt;(); return numDecodingsByMemo(s,0,s.length()-1,memo); &#125; private int numDecodingsByMemo(String s, int start, int end, HashMap&lt;Integer, Integer&gt; memo)&#123; //1.递归出口：数字为最后一个数字时即结束递归 //2.返回值：返回解码方法数 //3.一次递归的过程 if(start &gt; end)&#123; return 1; &#125; if(s.charAt(start) == '0')&#123; return 0; &#125; if(start == end)&#123; return 1; &#125; if(memo.containsKey(start))&#123; return memo.get(start); &#125; int num1 = numDecodingsByMemo(s,start+1,end,memo); int num2 = 0; if((s.charAt(start) - '0') * 10 + (s.charAt(start+1)-'0') &lt;= 26)&#123; num2 = numDecodingsByMemo(s,start+2,end,memo); &#125; memo.put(start,num1+num2); return num1+num2; &#125;&#125; dp注意：难点在处理&#39;0&#39;,&#39;00&#39;等边界问题！尤其是在dp[n]、dp[n-1]的赋值问题上有一点难度，而且，这个由于是倒序的，跟平时处理的dp问题略微有些许不同，以前是dp[1]对应第一个字符，而这里是dp[0]对应第一个字符。 123456789101112131415161718192021222324252627class Solution &#123; public int numDecodings(String s) &#123; int len = s.length(); int[] dp = new int[len + 1]; dp[len] = 1; //将递归法的结束条件初始化为 1 //最后一个数字不等于 0 就初始化为 1 if (s.charAt(len - 1) != '0') &#123; dp[len - 1] = 1; &#125; for (int i = len - 2; i &gt;= 0; i--) &#123; //当前数字时 0 ，直接跳过，0 不代表任何字母 if (s.charAt(i) == '0') &#123; continue; &#125; int ans1 = dp[i + 1]; //判断两个字母组成的数字是否小于等于 26 int ans2 = 0; int ten = (s.charAt(i) - '0') * 10; int one = s.charAt(i + 1) - '0'; if (ten + one &lt;= 26) &#123; ans2 = dp[i + 2]; &#125; dp[i] = ans1 + ans2; &#125; return dp[0]; &#125;&#125; 零钱兑换(322)一维dp数组，简单的一批… 12345678910111213141516class Solution &#123; public int coinChange(int[] coins, int amount) &#123; //非常明显的使用dp int[] dp = new int[amount+1]; //代表的是对应钱数所需的最少的硬币个数 Arrays.fill(dp,amount+1); dp[0] = 0; for(int i = 0;i &lt;= amount;i++)&#123; for(int j = 0;j &lt; coins.length;j++)&#123; if(coins[j] &lt;= i)&#123; dp[i] = Math.min(dp[(i-coins[j])]+1,dp[i]); &#125; &#125; &#125; return dp[amount] == amount+1 ? -1:dp[amount]; &#125;&#125; 回文子串(647)思路同第5题！！！！ 12345678910111213141516class Solution &#123; public int countSubstrings(String s) &#123; int res = 0; boolean dp[][] = new boolean[s.length()][s.length()]; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt;= i; j++) &#123; //dp的出口就是长度在3以内(包括3),注意j为开始，i为结束 if (s.charAt(j) == s.charAt(i) &amp;&amp; ((i - j &lt;= 2) || dp[j + 1][i - 1])) &#123; dp[j][i] = true; res++; &#125; &#125; &#125; return res; &#125;&#125; 环形链表I(141)题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 思路 方法一：使用Set集合存储已经出现过的节点，如果再次出现，则直接返回true，如果没有再出现，则一定会有null节点的出现。 方法二：运用快慢指针的方法，快指针走得快，如果遍历到null节点，则说明不存在环，如果快指针和慢指针会相遇，则说明存在环。 代码 方法一 123456789101112131415public class Solution &#123; public boolean hasCycle(ListNode head) &#123; HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while(head != null)&#123; if(!set.contains(head))&#123; set.add(head); &#125; else&#123; return true; &#125; head = head.next; &#125; return false; &#125;&#125; 方法二 1234567891011121314151617public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head == null || head.next == null)&#123; return false; &#125; ListNode slow = head.next; ListNode fast = head.next.next; while(slow != fast)&#123; if(fast == null || fast.next == null)&#123; return false; &#125; slow = slow.next; fast = fast.next.next; &#125; return true; &#125;&#125; 环形链表 II(142)这个题翻译的一坨屎…题目整来整去不知道在说什么，真的是服了耶！ 其实题目就一个意思，给定一个有环链表，要你返回环的入口！ 思路这种思路都要讲烂了吧..就是使用快慢指针，第一次相遇后，快指针继续走，慢指针回到起点，第二次相遇的地方就是环的起点。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fast = head, slow = head; while (true) &#123; if (fast == null || fast.next == null) return null; fast = fast.next.next; slow = slow.next; if (fast == slow) break; &#125; fast = head; while (slow != fast) &#123; slow = slow.next; fast = fast.next; &#125; return fast; &#125;&#125; 4. 寻找两个有序数组的中位数题目给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 思路 如果没有时间复杂度的话，那这道题有非常多的思路可以做，可以先排序再取中位数，可以采用两个有序数组进行归并排序，这样的时间复杂度为 O(m+n) ,达不到 O(log(m+n)) 看到log(m+n)，就应该想到二分查找，这道题也的确可以用二分去做。首先我们明确一下这里的中位数是什么意思？这里说的是求两个有序数组(m + n)的中位数，如果 m + n 为奇数，则中位数的下标为 (m + n + 1)/2 [下标从1开始！]，如果 m + n 为偶数，则中位数的值为下标为 (m + n + 1)/2 、(m + n + 2)/2的数的平均值，所以其实可以统一一下，也就是不论奇数还是偶数，中位数的值 = 下标为 (m + n + 1)/2 、(m + n + 2)/2的数的平均值！！！所以问题就转换为求第 (m + n +1)/2、 (m + n + 2)/2大的数了，至于求第K大的数问题，这个方法就很多了，从远古的快排到堆排序，待会会拓展一下！回到正题，如何在两个有序数组中间取到第K大的数还必须是log级别的时间复杂度，那只能选择二分了，这里的二分比较特殊，是对两个数组取第K/2大的数，有人会问了，为何是这样取呢？因为在每次划分的时候，我们都要确保第K大的数未被去除，所以两个数组分别取K/2，这样能确保有 m + n - k个数是一定大于我们要取的数的，也就是说，我们的二分，就是一步步去除比中位数小的数，直到遍历到中位数为止，而什么时候能遍历到中位数呢？难点就在于边界比较复杂，比如：数组长度过短导致取不到K/2、K如果为1的话是不能取K/2的(下标从1开始，这样会越界)、单个数组可能已经遍历完另外一个还没遍历完等等。 代码实现方法一见归并排序的做法(时间复杂度其实是不符合要求的) 方法二123456789101112131415161718192021222324252627282930313233343536/** * 方法二 * @param nums1 * @param nums2 * @return */public static double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; return (findMedianSortedArraysByRecursion(nums1,0,nums2,0,(nums1.length + nums2.length + 1)/2) + findMedianSortedArraysByRecursion(nums1,0,nums2,0,(nums1.length + nums2.length + 2)/2))/2.0;&#125;/** * 递归三部曲 * 1、找到递归出口，当遍历的数的下标大于等于数组本身长度，说明可以结束了，注意这里是大于等于哦，因为下标是从0开始的！ * 还要一个递归出口就是，当k为1时，即找最小的那个数，则直接比较数组第一个元素即可 * 2、找到返回值，返回第K大的数的值即可 * 3、每一轮递归需要做的事情，我们需要从起始点开始，寻找第K大的数，即分别在两个数组中找到第K/2大的数 * 若一个数组中找不到第K/2个数，则说明另外一个数组的前K/2的数对我们没有意义 * @param nums1 * @param nums1_start * @param nums2 * @param nums2_start * @param k * @return */private static double findMedianSortedArraysByRecursion(int[] nums1, int nums1_start, int[] nums2, int nums2_start, int k) &#123; if(nums1_start &gt;= nums1.length) return nums2[nums2_start+k-1]; if(nums2_start &gt;= nums2.length) return nums1[nums1_start+k-1]; if(k == 1)&#123; return Math.min(nums1[nums1_start],nums2[nums2_start]); &#125; int mid_num1 = (nums1_start + k/2 - 1) &lt; nums1.length ? nums1[nums1_start + k/2 -1] : Integer.MAX_VALUE; int mid_num2 = (nums2_start + k/2 - 1) &lt; nums2.length ? nums2[nums2_start + k/2 -1] : Integer.MAX_VALUE; return mid_num1 &gt; mid_num2 ? findMedianSortedArraysByRecursion(nums1,nums1_start,nums2,nums2_start+k/2,k-k/2) : findMedianSortedArraysByRecursion(nums1,nums1_start+k/2,nums2,nums2_start,k-k/2);&#125; 17. 电话号码的字母组合题目给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入："23"输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 思路队列先定义一个String字符串数组，然后遍历输入的数字，拿到每一个数字，然后利用队列，先将前一次循环的字符串遍历(这里非常巧妙，因为 i 从 0 开始，那么第 n 次循环的 i 为 n-1 ,即是前一次循环的字符串的长度)，每次遍历前一次循环的字符串，就将其出队列，然后将新的字符串拼接好直接放入队列，类似于树的层序遍历，只是这里非常巧妙地运用了队头元素的长度和 i 的关系。 回溯回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。 给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。 如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。如果还有数字需要被输入：遍历下一个数字所对应的所有映射的字母。将当前的字母添加到组合最后，也就是 combination = combination + letter。重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:])。 代码实现队列实现1234567891011121314151617class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; LinkedList&lt;String&gt; ans = new LinkedList&lt;String&gt;(); if(digits.isEmpty()) return ans; String[] mapping = new String[] &#123;"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; ans.add(""); for(int i =0; i&lt;digits.length();i++)&#123; int x = Character.getNumericValue(digits.charAt(i)); while(ans.peek().length()==i)&#123; String t = ans.remove(); for(char s : mapping[x].toCharArray()) ans.add(t+s); &#125; &#125; return ans; &#125;&#125; 回溯实现1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() &#123;&#123; put("2", "abc"); put("3", "def"); put("4", "ghi"); put("5", "jkl"); put("6", "mno"); put("7", "pqrs"); put("8", "tuv"); put("9", "wxyz"); &#125;&#125;; List&lt;String&gt; output = new ArrayList&lt;String&gt;(); public void backtrack(String combination, String next_digits) &#123; // if there is no more digits to check if (next_digits.length() == 0) &#123; // the combination is done output.add(combination); &#125; // if there are still digits to check else &#123; // iterate over all letters which map // the next available digit String digit = next_digits.substring(0, 1); String letters = phone.get(digit); for (int i = 0; i &lt; letters.length(); i++) &#123; String letter = phone.get(digit).substring(i, i + 1); // append the current letter to the combination // and proceed to the next digits backtrack(combination + letter, next_digits.substring(1)); &#125; &#125; &#125; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() != 0) backtrack("", digits); return output; &#125;&#125; 22. 括号生成##题目 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 思路dp简单来说，在求N个括号的排列组合时，把第N种情况（也就是N个括号排列组合）视为单独拿一个括号E出来，剩下的N-1个括号分为两部分，P个括号和Q个括号，P+Q=N-1，然后这两部分分别处于括号E内和括号E的右边，各自进行括号的排列组合。由于我们是一步步计算得到N个括号的情况的，所以小于等于N-1个括号的排列组合方式我们是已知的（用合适的数据结构存储，方便后续调用，且在存储时可利用特定数据结构实现题目某些要求，如排序，去重等），且P+Q=N-1，P和Q是小于等于N-1的，所以我们能直接得到P个和Q个括号的情况，进而得到N个括号的结果！ 这个算法主要的基点就是将排列组合的情况分为了括号内和括号外这两种情况，且仅存在两种情况！至于为什么，原因在于楼主的算法的前提是单独拿出来的括号E的左边在N个括号所有排列组合情况中都是处于最左边，所以不存在括号位于括号E的左边的情况。因此，N-1个括号（拿出了括号E）仅可能分布于括号E内和括号E外，分为两种子情况讨论！ 这种思想还可以应用于其他类似的题的求解中，即怎样合理高效的利用前面步骤的计算结果得出当前步骤结果，从而得出最终结果。 递归只有在我们知道序列仍然保持有效时才添加 ‘(‘ or ‘)’，我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。 代码实现dp123456789101112131415161718192021222324252627class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; // dp.get(i)表示我们要求的List，dp.get(0)即表示由0个括号组成的字符串的列表 List&lt;LinkedList&lt;String&gt;&gt; dp = new LinkedList&lt;&gt;(); if( n == 0) return dp.get(0); LinkedList&lt;String&gt; zero = new LinkedList&lt;&gt;(); zero.add(""); dp.add(zero); //计算dp数组的值 for(int i = 1;i &lt;= n;i++)&#123; LinkedList&lt;String&gt; single = new LinkedList&lt;&gt;(); //每个dp的值都是由两部分组成的 for(int j = 0;j &lt; i;j++)&#123; LinkedList&lt;String&gt; str1 = dp.get(j); LinkedList&lt;String&gt; str2 = dp.get(i-j-1); for(String s1:str1)&#123; for(String s2:str2)&#123; String str = "(" + s1 + ")" + s2; single.add(str); &#125; &#125; &#125; dp.add(single); &#125; return dp.get(n); &#125;&#125; 递归1234567891011121314151617181920212223/** * 剪枝 + 回溯 * 递归三部曲 * 1、找到递归出口，当当前字符串的长度为2n时，即该字符串添加完成 * 2、返回值，无需返回任何东西，只需要在每次递归完成时将拼接好的字符串加到要返回的列表即可 * 3、一次递归需要做的事：如果左括号，小于n，则需要open+1，如果右括号小于左括号，则需要添加右括号 * @param n * @return */public static List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new LinkedList&lt;&gt;(); backtrack(res,"",0,0, n); return res;&#125;public static void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max)&#123; if (cur.length() == max * 2) &#123; ans.add(cur); return; &#125; if (open &lt; max) backtrack(ans, cur+"(", open+1, close, max); if (close &lt; open) backtrack(ans, cur+")", open, close+1, max);&#125; 31. 下一个排列题目实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须 原地 修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 12341,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1158476531 -&gt; 158513467 思路 从右向左，找到第一个非倒序的数字，例如上面的158476531，从右向左的第一个非倒序的数字是4 然后再从右向左遍历一次，找到第一个比4大的数，这里是右边数第三个 5，交换 4 和 5,数字变为 158576431,这显然不是我们要的答案 然后将 5 后面的数字翻转，也就是将 76431 翻转,于是数字变为 158513467 代码实现12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public void nextPermutation(int[] nums) &#123; int i = nums.length - 2; for(; i &gt;= 0; i--)&#123; if(nums[i] &lt; nums[i+1])&#123; break; &#125; &#125; if(i &gt;= 0)&#123; int j = nums.length -1; for(; j &gt; i; j--)&#123; if(nums[j] &gt; nums[i])&#123; break; &#125; &#125; swap(nums,i,j); &#125; reverse(nums,i+1); System.out.println(Arrays.toString(nums)); &#125; private void reverse(int[] nums, int start) &#123; int i = start, j = nums.length - 1; while (i &lt; j) &#123; swap(nums, i, j); i++; j--; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 32. 最长有效括号题目给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: "(()"输出: 2解释: 最长有效括号子串为 "()" 示例 2: 123输入: ")()())"输出: 4解释: 最长有效括号子串为 "()()" 思路 思路一：栈 + dp 前文第20题 有效的括号 ，就是采用 栈 去做的，那么这个很自然的也同样是采用栈去做，凡是碰到了括号，基本都是用栈去做处理，因为符合后进先出的原则。 然后又是寻找子串长度，那自然是要用到dp，故采用的方法很明显就是栈 + dp。 思路二：栈 与找到每个可能的子字符串后再判断它的有效性不同，我们可以用栈在遍历给定字符串的过程中去判断到目前为止扫描的子字符串的有效性，同时都是最长有效字符串的长度。我们首先将 −1 放入栈顶。对于遇到的每个 ‘(’ ，我们将它的下标放入栈中。对于遇到的每个 ‘)’ ，我们弹出栈顶的元素并将当前元素的下标与弹出元素下标作差，得出当前有效括号字符串的长度。通过这种方法，我们继续计算有效子字符串的长度，并最终返回最长有效子字符串的长度 我认为这种思路最精妙的地方在于他提前压栈了-1，这是这个方法最妙的地方，而在遍历元素时，每次都会有压栈或者弹栈的操作，这样就能知道最长有效字符串的长度，因为一旦不是有效字符串了，栈就会变空，下一个填入的一定是有效字符串的前一位…不过我还是觉得我的方法更容易让人理解，这个方法只能欣赏了。 作者：LeetCode链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码 思路一 1234567891011121314151617181920212223242526272829class Solution &#123; public int longestValidParentheses(String s) &#123; Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); int max = 0; // 保存上一个有效括号的长度 int last_num; int[] num = new int[s.length()+1]; boolean[] dp = new boolean[s.length()+1]; for(int i = 0;i &lt; s.length();i++)&#123; if(s.charAt(i) == '(')&#123; stack.push(i); &#125; else if(!stack.isEmpty() &amp;&amp; s.charAt(i) == ')')&#123; //这里的是i是从0开始的，所以这其实是第 i+1 个数 dp[i+1] = true; //如果取出来的数对应的索引的前一位也是有效括号，注意哦，这里的dp是从1开始的！ // 所以不用减1了，直接就是dp[stack.peek()],num数组同理 // dp数组和num数组，索引值为 i+1 if(dp[stack.peek()] == true)&#123; last_num = num[stack.peek()]; &#125; else last_num = 0; num[i+1] = i - stack.pop() + 1 + last_num; max = Math.max(max,num[i+1]); &#125; &#125; return max; &#125;&#125; 思路二 【精妙无比，适当记忆】 123456789101112131415161718192021public class Solution &#123; public int longestValidParentheses(String s) &#123; int maxans = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; stack.push(i); &#125; else &#123; stack.pop(); if (stack.empty()) &#123; stack.push(i); &#125; else &#123; maxans = Math.max(maxans, i - stack.peek()); &#125; &#125; &#125; return maxans; &#125;&#125; 5152. 将矩阵按对角线排序题目给你一个 m * n 的整数矩阵 mat ，请你将同一条对角线上的元素（从左上到右下）按升序排序后，返回排好序的矩阵。 示例 1： 12输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]] 思路 使用的是 N皇后 问题的编码技巧：主对角线上元素的特点是：纵坐标 - 横坐标 = 定值 【难点】 为了能够放进数组中，加上偏移 m - 1 。【难点】 两次遍历：第一次遍历把数据拷贝到对角线数组中，然后排序；第二次遍历把对角线数组写回原始数组（或者新开一个数组）均可。 作者：liweiwei1419链接：https://leetcode-cn.com/problems/sort-the-matrix-diagonally/solution/bao-li-jie-fa-by-liweiwei1419/来源：力扣（LeetCode） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;public class Solution &#123; public int[][] diagonalSort(int[][] mat) &#123; // 行数 int m = mat.length; // 列数 int n = mat[0].length; // 主对角线的条数 int dLen = m + n - 1; // 每一条对角线都创建一个动态数组 ArrayList&lt;Integer&gt;[] diagonal = new ArrayList[dLen]; for (int i = 0; i &lt; dLen; i++) &#123; diagonal[i] = new ArrayList&lt;&gt;(m); &#125; // 遍历原始矩阵，把原始矩阵中的元素放进对应的动态数组中 // 主对角线上元素的特点是：纵坐标 - 横坐标 = 定值 // 加上偏移 m - 1 是为了能够放进数组中 for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; diagonal[j - i + (m - 1)].add(mat[i][j]); &#125; &#125; // 对每一个对角线上的动态数组分别进行升序排序 for (int i = 0; i &lt; dLen; i++) &#123; Collections.sort(diagonal[i]); &#125; int[][] res = new int[m][n]; // 对角线数组上还未取出的元素的下标，初始化的时候均为 0 int[] next = new int[dLen]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; // 对角线的坐标 int index = j - i + (m - 1); // 记录结果 res[i][j] = diagonal[index].get(next[index]); // 维护 next 数组的值 next[index]++; &#125; &#125; return res; &#125;&#125; 作者：liweiwei1419链接：https://leetcode-cn.com/problems/sort-the-matrix-diagonally/solution/bao-li-jie-fa-by-liweiwei1419/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 51. N皇后回溯算法这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。 废话不多说，直接上回溯算法框架。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 1、路径：也就是已经做出的选择。 2、选择列表：也就是你当前可以做的选择。 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。 代码方面，回溯算法的框架： 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) returnfor 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。 什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！ 一、全排列问题我们在高中的时候就做过排列组合的数学题，我们也知道 n 个不重复的数，全排列共有 n! 个。 PS：为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字。 那么我们当时是怎么穷举全排列的呢？比方说给三个数 [1,2,3]，你肯定不会无规律地乱穷举，一般是这样： 先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位…… 其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树： 只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。 为啥说这是决策树呢，因为你在每个节点上其实都在做决策。比如说你站在下图的红色节点上： 你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。 现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。 如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性： 我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。 再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样： 123456void traverse(TreeNode root) &#123; for (TreeNode child : root.childern) // 前序遍历需要的操作 traverse(child); // 后序遍历需要的操作&#125; 而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了： 前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。 回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作： 现在，你是否理解了回溯算法的这段核心框架？ 12345678for 选择 in 选择列表: # 做选择 将该选择从选择列表移除 路径.add(选择) backtrack(路径, 选择列表) # 撤销选择 路径.remove(选择) 将该选择再加入选择列表 我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。 下面，直接看全排列代码： 1234567891011121314151617181920212223242526272829303132List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();/* 主函数，输入一组不重复的数字，返回它们的全排列 */List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 记录「路径」 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(nums, track); return res;&#125;// 路径：记录在 track 中// 选择列表：nums 中不存在于 track 的那些元素// 结束条件：nums 中的元素全都在 track 中出现void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) &#123; // 触发结束条件 if (track.size() == nums.length) &#123; res.add(new LinkedList(track)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // 排除不合法的选择 if (track.contains(nums[i])) continue; // 做选择 track.add(nums[i]); // 进入下一层决策树 backtrack(nums, track); // 取消选择 track.removeLast(); &#125;&#125; 我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 nums 和 track 推导出当前的选择列表： 至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。 但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。 明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。 二、N 皇后问题这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。 PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。 这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。 直接套用框架: 123456789101112131415161718192021222324252627282930313233vector&lt;vector&lt;string&gt;&gt; res;/* 输入棋盘边长 n，返回所有合法的放置 */vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; // '.' 表示空，'Q' 表示皇后，初始化空棋盘。 vector&lt;string&gt; board(n, string(n, '.')); backtrack(board, 0); return res;&#125;// 路径：board 中小于 row 的那些行都已经成功放置了皇后// 选择列表：第 row 行的所有列都是放置皇后的选择// 结束条件：row 超过 board 的最后一行void backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return; &#125; int n = board[row].size(); for (int col = 0; col &lt; n; col++) &#123; // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = 'Q'; // 进入下一行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.'; &#125;&#125; 这部分主要代码，其实跟全排列问题差不多，isValid 函数的实现也很简单： 12345678910111213141516171819202122/* 是否可以在 board[row][col] 放置皇后？ */bool isValid(vector&lt;string&gt;&amp; board, int row, int col) &#123; int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i &lt; n; i++) &#123; if (board[i][col] == 'Q') return false; &#125; // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123; if (board[i][j] == 'Q') return false; &#125; // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (board[i][j] == 'Q') return false; &#125; return true;&#125; 函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝： 如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。 当 N = 8 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。 不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 isValid 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 N = 10 的时候，计算就已经很耗时了。 有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。 其实特别简单，只要稍微修改一下回溯算法的代码即可： 1234567891011121314151617181920// 函数找到一个答案后就返回 truebool backtrack(vector&lt;string&gt;&amp; board, int row) &#123; // 触发结束条件 if (row == board.size()) &#123; res.push_back(board); return true; &#125; ... for (int col = 0; col &lt; n; col++) &#123; ... board[row][col] = 'Q'; if (backtrack(board, row + 1)) return true; board[row][col] = '.'; &#125; return false;&#125; 这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？ 三、最后总结回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下： 12345def backtrack(...): for 选择 in 选择列表: 做选择 backtrack(...) 撤销选择 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。 其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？ 某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。 作者：labuladong链接：https://leetcode-cn.com/problems/n-queens/solution/hui-su-suan-fa-xiang-jie-by-labuladong/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 Tip: Java写法 【N皇后】 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public List&lt;List&lt;String&gt;&gt; res; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; if (n &lt;= 0) return null; res = new LinkedList&lt;&gt;(); char[][] board = new char[n][n]; for (char[] chars : board) Arrays.fill(chars, '.'); backtrack(board, 0); return res; &#125; private static List&lt;String&gt; charToString(char[][] array) &#123; List&lt;String&gt; result = new LinkedList&lt;&gt;(); for (char[] chars : array) &#123; result.add(String.valueOf(chars)); &#125; return result; &#125; /** * 路径：board中小于row的那些行都已经成功放置了皇后 * 可选择列表: 第row行的所有列都是放置Q的选择 * 结束条件: row超过board的最后一行 * * @param board * @param row */ private void backtrack(char[][] board, int row) &#123; if (row == board.length) &#123; res.add(charToString(board)); return; &#125; int n = board[row].length; for (int col = 0; col &lt; n; col++) &#123; if (!isValid(board, row, col)) continue; board[row][col] = 'Q'; backtrack(board, row + 1); board[row][col] = '.'; &#125; &#125; private boolean isValid(char[][] board, int row, int col) &#123; int rows = board.length; // check is valid in col for (char[] chars : board) if (chars[col] == 'Q') return false; // check is valide upright for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; rows; i--, j++) &#123; if (board[i][j] == 'Q') return false; &#125; // check is valide upleft for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123; if (board[i][j] == 'Q') return false; &#125; return true; &#125;&#125; 代码来自： https://leetcode-cn.com/u/kpcoding/ 42. 接雨水题目给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例: 12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 思路见代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 暴力法 * 就是找左右柱子的最大值的最小值，即Math.min(L_max,R_max),然后减去自身高度就是能接的雨水 * 值得注意的是，求左右柱子最大值时需要把自己计算在内！！！ * @param height * @return */ public int trapByViolence(int[] height)&#123; int res = 0; for(int i = 0;i &lt; height.length;i++)&#123; int L_max = 0; int R_max = 0; for(int j = i;j &gt;= 0;j--)&#123; L_max = Math.max(L_max,height[j]); &#125; for(int j = i;j &lt; height.length;j++)&#123; R_max = Math.max(R_max,height[j]); &#125; res = res + Math.min(L_max,R_max) - height[i]; &#125; return res; &#125; /** * dp大法 * 用空间换时间，把 L_max、R_max 记录下来，就不用重复计算了 * @param height * @return */ public int trapByDp(int[] height)&#123; int res = 0; int len = height.length; if(len == 0) return 0; int[] L_max = new int[len]; int[] R_max = new int[len]; L_max[0] = height[0]; R_max[len-1] = height[len-1]; for(int i = 1;i &lt; len;i++)&#123; L_max[i] = Math.max(L_max[i-1],height[i]); &#125; for(int i = len - 2;i &gt;= 0;i--)&#123; R_max[i] = Math.max(R_max[i+1],height[i]); &#125; for(int i = 0;i &lt; height.length;i++)&#123; res = res + Math.min(L_max[i],R_max[i]) - height[i]; &#125; return res; &#125; /** * 双指针之固定最高点 * 先找到最高点，然后左边向最高点靠近，右边也向最高点靠近，左边只需要考虑左边，右边只需要考虑右边 * @param height * @return */ public int trapByDouble(int[] height)&#123; int res = 0; int len = height.length; if(len == 0) return 0; int max = 0; int max_index = -1; for(int i = 0;i &lt; len;i++)&#123; if(height[i] &gt; max)&#123; max = height[i]; max_index = i; &#125; &#125; int L_max = height[0]; for(int i = 0;i &lt; max_index;i++)&#123; if(height[i] &gt; L_max) L_max = height[i]; else res = res + L_max - height[i]; &#125; int R_max = height[len-1]; for(int i = len - 1;i &gt; max_index;i--)&#123; if(height[i] &gt; R_max) R_max = height[i]; else res = res + R_max - height[i]; &#125; return res; &#125; /** * 双指针法二 * 整体思路其实是一样的，只是这个更简便一点而已，无需找最高点，只要确保遍历的数只需要考虑一边即可 * @param height * @return */ public int trapByDouble2(int[] height)&#123; int res = 0; int len = height.length; int left = 0; int right = len - 1; if(len == 0) return 0; int L_max = height[0]; int R_max = height[len-1]; //一定在最高点相遇，所以无需 left &lt;= right while(left &lt; right)&#123; L_max = Math.max(L_max, height[left]); R_max = Math.max(R_max, height[right]); if (L_max &lt; R_max) &#123; res = res + L_max - height[left]; left++; &#125; else &#123; res = res + R_max - height[right]; right--; &#125; &#125; return res; &#125; 33. 搜索旋转排序数组题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 123456789示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 思路题目要求 O(logN) 的时间复杂度，基本可以断定本题是需要使用二分查找，怎么分是关键。由于题目说数字了无重复，举个例子：1 2 3 4 5 6 7 可以大致分为两类，第一类 2 3 4 5 6 7 1 这种，也就是 nums[start] &lt;= nums[mid]。此例子中就是 2 &lt;= 5。这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。第二类 6 7 1 2 3 4 5 这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2。这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]，则在后半部分找，否则去前半部分找。 此题有个存在重复数字的变形题，可参考 此题解 。 作者：reedfan链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-bai-liao-9983de-javayong-hu-by-reedfan/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 代码实现123456789101112131415161718192021222324252627282930class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(nums[mid] == target) return mid; //最容易错的点，就是列表只有两个数字时，mid和start是同一个数，此时必须是前半部分有序 if(nums[mid] &gt;= nums[start])&#123; // 说明前半部分有序 if(nums[start] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; end = mid - 1; &#125; else &#123; start = mid + 1; &#125; &#125; else &#123; // 说明后半部分有序 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[end])&#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int search(int[] nums, int target) &#123; int start = 0; int end = nums.length - 1; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(nums[mid] == target) return mid; if (nums[start] == nums[mid]) &#123; start++; continue; &#125; //最容易错的点，就是列表只有两个数字时，mid和start是同一个数，此时必须是前半部分有序 // num[mid] == nums[start] 只会在列表只有两个数时才相等，所以才可以上面那样处理 // 正常其实是不应该那样处理，而应该是当num[mid] == nums[start]，直接start++，然后进行下一次循环 if(nums[mid] &gt; nums[start])&#123; // 说明前半部分有序 if(nums[start] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; end = mid - 1; &#125; else &#123; start = mid + 1; &#125; &#125; else &#123; // 说明后半部分有序 if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[end])&#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; Tip: 81题思路一样 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) &#123; return false; &#125; int start = 0; int end = nums.length - 1; int mid; while (start &lt;= end) &#123; mid = start + (end - start) / 2; if (nums[mid] == target) &#123; return true; &#125; if (nums[start] == nums[mid]) &#123; start++; continue; &#125; // 前半部分有序 // [1,3,1,1,1] if (nums[start] &lt; nums[mid]) &#123; // target在前半部分 if (nums[mid] &gt; target &amp;&amp; nums[start] &lt;= target) &#123; end = mid - 1; &#125; else &#123; // 否则，去后半部分找 start = mid + 1; &#125; &#125; else &#123; // 后半部分有序 // target在后半部分 if (nums[mid] &lt; target &amp;&amp; nums[end] &gt;= target) &#123; start = mid + 1; &#125; else &#123; // 否则，去后半部分找 end = mid - 1; &#125; &#125; &#125; // 一直没找到，返回false return false; &#125;&#125; 34. 在排序数组中查找元素的第一个和最后一个位置题目给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 12345678示例 1:输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]示例 2:输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 思路见 labuladong 公众号笔记 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length == 0) return new int[]&#123;-1,-1&#125;; return new int[]&#123;searchLeft(nums,target),searchRight(nums,target)&#125;; &#125; public int searchLeft(int[] nums,int target)&#123; int left = 0; int right = nums.length - 1; while(left &lt;= right)&#123; // 防止溢出 int mid = left + (right - left)/2; if(nums[mid] &gt;= target) right = mid - 1; else left = mid + 1; &#125; // 上面的while循环后，最后一次循环 left == mid, right = left - 1 = mid - 1 // 若有符合要求的target，则会有两种情况： // 1. left 和 right 在 target 值的最左索引处的前一位相遇，此时 left 会向右一位，到达最左 target 处,而 right 会停在原地，弹出 while // 2. left 和 right 在 target 值的最左索引处相遇，此时 left 不动，到达最左 target 处,而 right 会向左一位，弹出 while // 注意：此时的 left 都是处在 target 最左索引处 // 如果没有符合要求的target，则有三种情况： // 1.所有值均小于target，此时，left会在 nums[nums.length-1]处与right相遇，然后left 加 1，跳出循环，此时left == nums.length // 2.所有值均大于target，此时right会不断向左，直至 left = right = 0 相遇，此时 right 减 1，跳出循环，此时 left == 0 // 3.target位于值的中间，但是没有值取到，此时跟有target情况是类似的，最终 left 会停留在比 target 大的第一个数上 // 总结上面 5 种情况，left 为 nums.length 时，另其为 nums.length - 1,此时直接判断 nums[left] 即可，若为target则直接返回 left // 否则返回 -1 int pos = (left == nums.length) ? nums.length - 1 : left; if(nums[pos] != target) return -1; return left; &#125; public int searchRight(int[] nums,int target)&#123; int left = 0; int right = nums.length - 1; while(left &lt;= right)&#123; // 防止溢出 int mid = left + (right - left)/2; if(nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; &#125; // 同上分析 // 最左和最右只有一个区别，就是 left 换成了 right ，nums.length 换成了 -1 int pos = (right == -1)? 0 : right; if(nums[pos] != target) return -1; return right; &#125;&#125; 39. 组合总和题目给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 思路直接上回溯算法框架。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 1、路径：也就是已经做出的选择。 2、选择列表：也就是你当前可以做的选择。 3、结束条件：也就是到达决策树底层，无法再做选择的条件。 代码方面，回溯算法的框架： 12345678910result = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) returnfor 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。 labuladong 回溯框架！！！老哥写的文章真是干净利落！ demo(全排列)123456789101112131415161718192021222324252627282930313233List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();/* 主函数，输入一组不重复的数字，返回它们的全排列 */List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; // 记录「路径」 // 这里的 选择列表 即包含在nums中 LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); backtrack(nums, track); return res;&#125;// 路径：记录在 track 中// 选择列表：nums 中的元素// 结束条件：nums 中的元素全都在 track 中出现void backtrack(int[] nums, LinkedList&lt;Integer&gt; track) &#123; // 触发结束条件 if (track.size() == nums.length) &#123; res.add(new LinkedList(track)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; // 排除不合法的选择 if (track.contains(nums[i])) continue; // 做选择 track.add(nums[i]); // 进入下一层决策树 backtrack(nums, track); // 取消选择，返回上一层决策树 track.removeLast(); &#125;&#125; 代码实现先按照demo写一个差不多的，这个暂时无法做到去重！ 1234567891011121314151617181920212223242526272829303132333435363738public class combinationSum_39 &#123; public static void main(String[] args) &#123; combinationSum(new int[]&#123;2,3,6,7&#125;,7); System.out.println(res); &#125; public static List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); // 排序的原因是在回溯的时候比较容易剪枝 Arrays.sort(candidates); // 套用上面的公式，candidates是指选择列表，target用来判断是否结束以及用于剪枝 // track则是路径，即已经做出的选择 backtrack(candidates, target, track); return res; &#125; private static void backtrack(int[] candidates, int target, LinkedList&lt;Integer&gt; track) &#123; //先判断结束条件 if (target &lt; 0) return; if (target == 0)&#123; // 当target等于0的时候，将路径加入到结果列表中 res.add(new LinkedList&lt;&gt;(track)); return; &#125; // 遍历选择列表，这里没有去重 //下面会设置start，每次递归的时候只在candidates中当前及之后的数字中选择。 for(int i = 0;i &lt; candidates.length;i++)&#123; // 这就是排序的好处，可以直接这样剪枝，否则还得遍历 if(target &lt; candidates[i]) break; track.add(candidates[i]); backtrack(candidates,target-candidates[i],track); track.removeLast(); &#125; &#125;&#125; 1输出：[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]] 去重之后的代码： 123456789101112131415161718192021222324252627282930public class combinationSum_39 &#123; public static void main(String[] args) &#123; combinationSum(new int[]&#123;2,3,6,7&#125;,7); System.out.println(res); &#125; public static List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); public static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;(); Arrays.sort(candidates); backtrack(candidates, 0, target, track); return res; &#125; private static void backtrack(int[] candidates, int start, int target, LinkedList&lt;Integer&gt; track) &#123; if (target &lt; 0) return; if (target == 0)&#123; res.add(new LinkedList&lt;&gt;(track)); return; &#125; for(int i = start;i &lt; candidates.length;i++)&#123; if(target &lt; candidates[i]) break; track.add(candidates[i]); backtrack(candidates,i,target-candidates[i],track); track.removeLast(); &#125; &#125;&#125; 1输出：[[2, 2, 3], [7]] 146. LRU缓存机制题目运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 相信如果有认真看过 LinkedHashMap 源码的小伙伴，一定会很快的跟官方题解写的一模一样！ 简单介绍LinkedHashMap（跟题目有关的知识点）HashMap 大家都清楚，底层是 数组 + 红黑树 + 链表 （不清楚也没有关系），同时其是无序的，而 LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供 有序，并且，LinkedHashMap的有序可以按两种顺序排列，一种是按照插入的顺序，一种是按照读取的顺序（这个题目的示例就是告诉我们要按照读取的顺序进行排序），而其内部是靠 建立一个双向链表 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准备的来说，是有三个函数来做这件事，这三个函数都统称为 回调函数 ，这三个函数分别是： void afterNodeAccess(Node p) { } 其作用就是在访问元素之后，将该元素放到双向链表的尾巴处(所以这个函数只有在按照读取的顺序的时候才会执行)，之所以提这个，是建议大家去看看，如何优美的实现在双向链表中将指定元素放入链尾！ void afterNodeRemoval(Node p) { } 其作用就是在删除元素之后，将元素从双向链表中删除，还是非常建议大家去看看这个函数的，很优美的方式在双向链表中删除节点！ void afterNodeInsertion(boolean evict) { } 这个才是我们题目中会用到的，在插入新元素之后，需要回调函数判断是否需要移除一直不用的某些元素！ 其次，我再介绍一下 LinkedHashMap 的构造函数！ 其主要是两个构造方法，一个是继承 HashMap ，一个是可以选择 accessOrder 的值(默认 false，代表按照插入顺序排序)来确定是按插入顺序还是读取顺序排序。 1234567891011121314151617181920212223/** //调用父类HashMap的构造方法。 */public LinkedHashMap() &#123; super(); accessOrder = false;&#125;// 这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true// initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 思路 &amp; 代码下面是我自己在分析 LinkedHashMap 源码时做的一些笔记，应该是比较清楚的，主体意思就是我们要继承 LinkedHashMap，然后复写 removeEldestEntry()函数，就能拥有我们自己的缓存策略！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 在插入一个新元素之后，如果是按插入顺序排序，即调用newNode()中的linkNodeLast()完成// 如果是按照读取顺序排序，即调用afterNodeAccess()完成// 那么这个方法是干嘛的呢，这个就是著名的 LRU 算法啦// 在插入完成之后，需要回调函数判断是否需要移除某些元素！// LinkedHashMap 函数部分源码/** \* 插入新节点才会触发该方法，因为只有插入新节点才需要内存 \* 根据 HashMap 的 putVal 方法, evict 一直是 true \* removeEldestEntry 方法表示移除规则, 在 LinkedHashMap 里一直返回 false \* 所以在 LinkedHashMap 里这个方法相当于什么都不做 */void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; // 根据条件判断是否移除最近最少被访问的节点 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;// 移除最近最少被访问条件之一，通过覆盖此方法可实现不同策略的缓存// LinkedHashMap是默认返回false的，我们可以继承LinkedHashMap然后复写该方法即可// 例如 LeetCode 第 146 题就是采用该种方法，直接 return size() &gt; capacity;protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false; 通过上述代码，我们就已经知道了只要复写 removeEldestEntry() 即可，而条件就是 map 的大小不超过 给定的容量，超过了就得使用 LRU 了！然后根据题目给定的语句构造和调用： 123456789101112/** \* LRUCache 对象会以如下语句构造和调用: \* LRUCache obj = new LRUCache(capacity); \* int param_1 = obj.get(key); \* obj.put(key,value); */ 很明显我们只需要直接继承父类的put函数即可，因为题目没有特殊要求，故可以不写！至于 get() 函数，题目是有要求的！ 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 所以我们可以调用 LinkedHashMap 中的 getOrDefault()，完美符合这个要求，即当key不存在时会返回默认值 -1。 至此，我们就基本完成了本题的要求，只要写一个构造函数即可，答案的 super(capacity, 0.75F, true);，没看过源码的小伙伴可能不太清楚这个构造函数，这就是我上文讲的 LinkedHashMap 中的常用的第二个构造方法，具体大家可以看我上面代码的注释！ 至此，大功告成！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123; private int capacity; public LRUCache(int capacity) &#123; super(capacity, 0.75F, true); this.capacity = capacity; &#125; public int get(int key) &#123; return super.getOrDefault(key, -1); &#125; // 这个可不写 public void put(int key, int value) &#123; super.put(key, value); &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123; return size() &gt; capacity; &#125;&#125; 148. 排序链表题目在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 思路 题目要求时间空间复杂度分别为 O(nlogn) 和 O(1)，根据时间复杂度我们自然想到二分法，从而联想到归并排序； 对数组做归并排序的空间复杂度为 O(n) ，分别由新开辟数组 O(n) 和递归函数调用 O(logn) 组成，而根据链表特性： 数组额外空间：链表可以通过修改引用来更改节点顺序，无需像数组一样开辟额外空间； 递归额外空间：递归调用函数将带来 O(logn) 的空间复杂度，因此若希望达到 O(1) 空间复杂度，则不能使用递归。 【这里咱还是用下递归，降低难度！】 通过递归实现链表归并排序，有以下两个环节： 分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）； 我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。 找到中点 slow 后，执行 slow.next = None 将链表切断。 递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。 cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。 合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。 双指针法合并，建立辅助ListNode h 作为头部。 设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。 返回辅助ListNode h 作为头部的下个节点 h.next。 时间复杂度 O(l + r)，l, r 分别代表两个链表长度。 当题目输入的 head == None 时，直接返回None。 代码1234567891011121314151617181920212223242526272829class Solution &#123; public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode fast = head.next, slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; ListNode tmp = slow.next; slow.next = null; ListNode left = sortList(head); ListNode right = sortList(tmp); ListNode h = new ListNode(0); ListNode res = h; while (left != null &amp;&amp; right != null) &#123; if (left.val &lt; right.val) &#123; h.next = left; left = left.next; &#125; else &#123; h.next = right; right = right.next; &#125; h = h.next; &#125; h.next = left != null ? left : right; return res.next; &#125;&#125; 作者：jyd链接：https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 437. 路径总和 III题目给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1返回 3。和等于 8 的路径有:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 思路回溯，只不过这里的选择条件，比较特殊，并且 做选择 和 撤销选择 得稍微注意一下，这里可以直接用 if else。 代码12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int res = 0; public int pathSum(TreeNode root, int sum) &#123; if (root == null) return res; if (root != null) &#123; res = path(root,sum,0) + res; &#125; if(root.left != null) pathSum(root.left,sum); if(root.right != null) pathSum(root.right,sum); return res; &#125; public int path(TreeNode root, int sum,int count) &#123; if (root == null) return count; sum = sum - root.val; if (sum == 0) &#123; count++; &#125; if (root.left != null) &#123; count = path(root.left, sum, count); &#125; if (root.right != null) &#123; count = path(root.right, sum, count); &#125; return count; &#125;&#125; 124. 二叉树中的最大路径和题目给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 / \ 2 3输出: 6 示例 2: 123456789输入: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7输出: 42 思路这题还是挺难的，要求最大路径和，可以采用递归，递归就是三部曲： 1、确定递归出口，这个简单，root == null 即退出 2、确定返回值，这个是本题最难的，返回的是以该节点结尾的最大路径和！！！ 3、一级递归需要做的事，其实就是去算最大的路径和，这个很简单，在二叉树中，一级递归其实也就是三个节点，分别是根节点，左子树节点，右子树节点，既然每个节点返回的是 以该节点结尾的最大路径和，则我们可以在每级递归时去更新一下最大的路径和，即 左子树节点返回来的以其节点结尾的最大路径和 + 根节点的值 + 右子树节点返回的以该节点结尾的最大路径和。 代码1234567891011121314151617181920212223242526class Solution &#123; int max_sum = Integer.MIN_VALUE; public int max_gain(TreeNode node) &#123; if (node == null) return 0; // max sum on the left and right sub-trees of node int left_gain = Math.max(max_gain(node.left), 0); int right_gain = Math.max(max_gain(node.right), 0); // the price to start a new path where `node` is a highest node int price_newpath = node.val + left_gain + right_gain; // update max_sum if it's better to start a new path max_sum = Math.max(max_sum, price_newpath); // for recursion : // return the max gain if continue the same path return node.val + Math.max(left_gain, right_gain); &#125; public int maxPathSum(TreeNode root) &#123; max_gain(root); return max_sum; &#125;&#125; 48. 旋转图像题目给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2: 123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 思路翻转 + 转置 代码12345678910111213141516171819202122232425//1.先转置再翻转，注意这里翻转是 行 翻转，比如 第一行 1 2 3，行翻转变为 3 2 1//2.先翻转再转置，这里的翻转是 列 翻转，比如第一列 1 4 7，翻转为 7 4 1//3.如果是逆时针，则是按照副对角线进行转置class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; // 这里是先转置再翻转 for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int tmp = matrix[j][i]; matrix[j][i] = matrix[i][j]; matrix[i][j] = tmp; &#125; &#125; // 行翻转 1 2 3变为 3 2 1 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n / 2; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[i][n - j - 1]; matrix[i][n - j - 1] = tmp; &#125; &#125; &#125;&#125; 49. 字母异位词分组题目给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 123456输入: ["eat", "tea", "tan", "ate", "nat", "bat"],输出:[ ["ate","eat","tea"], ["nat","tan"], ["bat"] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 思路 每个单词进行字母排序，排完序后存入map中，key相同的存入同一个list中即可。 每个单词都是由 26 个字母组成的，这个方法无需对每个单词的字母进行排序，类似于桶的概念，每个单词不同的字符放入 26 个桶中，字母异位词对应的桶中的数值应该是一样的，将桶中数据相同的字母当成一个key，存入map中，然后key相同的存入同一个list中，我个人认为这种方法对字母很多很多的单词是非常有用的，时间复杂度上更小。 代码思路一 1234567891011121314class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if (strs.length == 0) return new ArrayList(); Map&lt;String, List&gt; ans = new HashMap&lt;String, List&gt;(); for (String s : strs) &#123; char[] ca = s.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); if (!ans.containsKey(key)) ans.put(key, new ArrayList()); ans.get(key).add(s); &#125; return new ArrayList(ans.values()); &#125;&#125; 思路二 123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if (strs.length == 0) return new ArrayList(); Map&lt;String, List&gt; ans = new HashMap&lt;String, List&gt;(); int[] count = new int[26]; for (String s : strs) &#123; Arrays.fill(count, 0); for (char c : s.toCharArray()) count[c - 'a']++; StringBuilder sb = new StringBuilder(""); for (int i = 0; i &lt; 26; i++) &#123; sb.append('#'); sb.append(count[i]); &#125; String key = sb.toString(); if (!ans.containsKey(key)) ans.put(key, new ArrayList()); ans.get(key).add(s); &#125; return new ArrayList(ans.values()); &#125;&#125; 136. 只出现一次的数字题目给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 思路 拿到手，要求时间复杂度在 O( n )，第一反应是使用哈希表 HashMap 来完成，遍历一遍数组，然后找到 value == 1的即可，时间复杂度 O(n)，空间复杂度为O(n)。 但是题目要求不使用额外空间，即空间复杂度 O(1)，这个就很难了，只能暴力法，就是每查一个数字，我们就去剩下的数字中去找，如果找不到，即使我们需要的，但是这个时间复杂度是O(n²)。 最后一个是最骚的，直接异或就行了… 代码123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int a = nums[0]; for(int i = 1;i &lt; nums.length;i++)&#123; a = a ^ nums[i]; &#125; return a; &#125;&#125; 55. 跳跃游戏题目给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 123输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 思路 回溯 贪心算法，每次都找到能跳到的最远距离，然后在原地到最远距离之间遍历，看能否继续跳到更远，如果可以，就更新最远距离值，如果最远距离值能够不小于最后一个位置，说明可以跳到，否则不行。 评论区看到的，其实跟贪心算法思想类似，但是又有点不一样，就是记录每个节点能跳到的最远距离，不断更新最远距离，如果有某个节点的下标比k值大，说明到不了该节点，即有个挡板挡在了这个节点之前，过不来，此时就是无法到达最后一个节点，如果全程都没有被挡板挡住，且挡板的值过了最后一个位置，即可以到达最后一个位置。 代码 回溯【超出时间限制】 123456789101112131415161718192021class Solution &#123; public boolean canJump(int[] nums) &#123; if(nums.length == 0) return true; return canJumpByRecursion_In(0, nums); &#125; private boolean canJumpByRecursion_In(int position,int[] nums) &#123; if (position == nums.length - 1) &#123; return true; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpByRecursion_In(nextPosition, nums)) &#123; return true; &#125; &#125; return false; &#125;&#125; 贪心 12345678910class Solution &#123; public boolean canJump(int[] nums) &#123; int furthest = 0; for(int i = 0;i &lt;= furthest;i++)&#123; if(furthest &gt;= nums.length-1) return true; if(i + nums[i] &gt; furthest) furthest = i + nums[i]; &#125; return false; &#125;&#125; 评论区神仙 1234567891011class Solution &#123; public boolean canJump(int[] nums) &#123; int furthest = 0; for(int i = 0;i &lt;= nums.length-1;i++)&#123; if(furthest &gt;= nums.length-1) break; if(i &gt; furthest) return false; if(i + nums[i] &gt; furthest) furthest = i + nums[i]; &#125; return true; &#125;&#125; 56. 合并区间题目给出一个区间的集合，请合并所有重叠的区间。 示例 1: 123输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 123输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 思路先按首位置进行排序; 接下来,如何判断两个区间是否重叠呢?比如 a = [1,4],b = [2,3] 当 a[1] &gt;= b[0] 说明两个区间有重叠 但是如何把这个区间找出来呢? 左边位置一定是确定，就是 a[0]，而右边位置是 max(a[1], b[1]) 所以,我们就能找出整个区间为:[1,4] 代码12345678910111213141516171819202122232425262728class Solution &#123; public int[][] merge(int[][] intervals) &#123; LinkedList&lt;int[]&gt; res = new LinkedList&lt;&gt;(); if (intervals == null || intervals.length == 0) &#123; return res.toArray(new int[0][]); &#125; // 按数组首元素排序 Arrays.sort(intervals, new Comparator&lt;int[]&gt;() &#123; @Override public int compare(int[] o1, int[] o2) &#123; return o1[0] - o2[0]; &#125; &#125;); // 如果遍历到的数组的初始值 比 res 的最新添加的数组的末尾值还大，说明没有重叠，可以直接添加 // 否则，直接比较两个数组的末尾值就行，因为是按数组首元素排好序的，所以只需要考虑末尾值替换就行 for (int i = 0; i &lt; intervals.length; i++) &#123; if (res.isEmpty() || res.getLast()[1] &lt; intervals[i][0]) &#123; res.add(intervals[i]); &#125; else &#123; res.getLast()[1] = Math.max(res.getLast()[1], intervals[i][1]); &#125; &#125; // list.toArray(new int[0][])，这是数组集体强转类型的方法 // new int[0][]是告诉程序需要转成这样的类型 // 长度多大是无所谓的，因为转换后的长度是按照你的list长度来定的 return res.toArray(new int[0][0]); &#125;&#125; 75. 颜色分类题目给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 12输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 思路三路归并，其实也是 Arrays.sort() 这里采用的方法，也是三色旗的解决方案。 三个指针，分别是 left、cur、right。left指向数组最左侧，right指向数组最右侧，cur代表当前正在遍历的数组元素，当 cur 遍历的元素是 0 时，将 cur 指向的元素 与 p0 指向的元素交换，然后 cur++，p0++。当 cur 遍历的元素是 1 时，cur++。当 cur 遍历的元素是 2 时，将 cur 指向的元素与 p2 指向的元素交换，然后 p2–，cur不动！！！直到 cur &gt; p2 ,循环结束（即全部扫描完毕）。 对于以上，有一个难点！ 为何 cur 在于 p0 交换时需要 p0++，cur++；而在 cur 与 p2 交换时，却只需要 p2++？ 对于上面这个问题，有两种解释思路：1.cur 与 p0 交换需要自加，是因为其左边已经扫描过了，交换过来的值也是之前就扫描过了的，而右边不是， p2 交换过来的值 cur 并没有扫描过；2.当 cur 与 p0 不是一个指向同一个索引值时，那 cur 指向的索引值如果发生交换，那交换过来的一定是 1（原因是只有当遍历过的节点有1，p0 和 cur 才不会同步），而 如果索引是 1 刚好也就不用有任何操作，所以可以直接继续向右扫描，当 cur 和 p0 指向的是同一个索引，那交换就等于没交换，故也是直接可以向右扫描，右边的就不行。 代码12345678910111213141516171819202122class Solution &#123; public void sortColors(int[] nums) &#123; int left = 0, cur = 0; int right = nums.length - 1; while (cur &lt;= right) &#123; if (nums[cur] == 0) &#123; swap(nums, left, cur); left++; cur++; &#125; else if (nums[cur] == 2) &#123; swap(nums, right, cur); right--; &#125; else cur++; &#125; &#125; public void swap(int[] nums, int a, int b) &#123; int temp = nums[a]; nums[a] = nums[b]; nums[b] = temp; &#125;&#125; 78. 子集题目给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 思路很明显，一看就是回溯，思路跟 全排列、N 皇后问题一样 代码1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums)&#123; LinkedList track = new LinkedList(); return subsets_in(nums,0, track); &#125; public List&lt;List&lt;Integer&gt;&gt; subsets_in(int[] nums,int start,LinkedList track) &#123; // 注意，这里必须new一个新的对象，否则的话每次添加都是指向同一个对象 // 最后track会变空，所有的添加的列表都会变空 res.add(new LinkedList(track)); for(int i = start;i &lt; nums.length;i++)&#123; track.add(nums[i]); subsets_in(nums,i+1,track); track.removeLast(); &#125; return res; &#125;&#125; 79. 单词搜索题目给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: 12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = "ABCCED", 返回 true.给定 word = "SEE", 返回 true.给定 word = "ABCB", 返回 false. 思路依旧是… 回溯 代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public boolean exist(char[][] board, String word) &#123; boolean[][] visited = new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if (word.charAt(0) == board[i][j] &amp;&amp; backtrack(i, j, 0, word, visited, board)) return true; &#125; &#125; return false; &#125; private boolean backtrack(int i, int j, int index, String word, boolean[][] visited, char[][] board) &#123; // 触发结束条件 if (index == word.length()) return true; if (i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word.charAt(index) || visited[i][j]) return false; // 做选择 visited[i][j] = true; // 进入下一层决策 if (backtrack(i + 1, j, index + 1, word, visited, board) || backtrack(i - 1, j, index + 1, word, visited, board) || backtrack(i, j + 1, index + 1, word, visited, board) || backtrack(i, j - 1, index + 1, word, visited, board)) return true; // 撤销选择 visited[i][j] = false; // 回溯 return false; &#125;&#125; 84. 柱状图中最大的矩形题目给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 思路 暴力法，每个高度都计算一遍最长的连续的底，然后取最大值。 其实这道题的本质就是转化为求每个高度对应的最长的连续的底，即对两边分别找第一个小于遍历的数的高度的索引值（即求矩形的最长的底），这点和接雨水 有点相似，同时，采用单调递增栈的方法 跟 求最大有效括号 这道题有异曲同工之处，都是采用了栈存取数组索引值的方法！ 为何说单调递增栈（严格递增）能非常轻松的找到 height[i] 的 两边刚好比它的高度小的第一个数 呢？ 这里我们先假设所有的高度都是不会相同的。 首先由于栈是递增的，当 height[i] 比栈顶的索引值对应的高度 大时，直接压入栈即可，否则说明 height[i] 比栈顶的索引值对应的高度小，则栈顶对应的右边第一个小于它的高度的数找到了，就是 height[i]，然后把栈顶元素弹出，新栈顶的元素即是刚才弹栈元素左边第一个小于它的高度的数，这样就很轻松的找到了两边分别小于 栈顶元素的数，这样取更新最大值就行了。 所以，我们现在来考虑一下取消开始那个前提条件，现在有的高度是会相同的，这个条件我们怎么处理呢？当面临栈顶元素和遍历的元素对应的高度相同时，我们只需要更新栈顶元素的值（即将其存入的索引变为新的我们正在遍历的元素的索引值），我举个例子，比如说 2 5 6 7 5 6 3，当遍历到最后一个数 5 时，此时栈顶值为 1（索引 1 对应的高度是 5 ），我们只要把栈顶值变为 4 即可。 当然这样还有一个问题，就是假如是 2 5 6 7，高度一直递增，四个值全部入栈了，此时最后一个元素 7 的 右边第一个小于它的高度其实没有，我们可以令其为 height.length。 代码 暴力法 1234567891011121314151617181920212223242526272829class Solution &#123; public int largestRectangleArea(int[] heights) &#123; HashSet&lt;Integer&gt; heightsSet = new HashSet&lt;Integer&gt;(); //得到所有的高度，也就是去重。 for (int i = 0; i &lt; heights.length; i++) &#123; heightsSet.add(heights[i]); &#125; int maxArea = 0; //遍历每一个高度 for (int h : heightsSet) &#123; int width = 0; int maxWidth = 1; //找出连续的大于等于当前高度的柱形个数的最大值 for (int i = 0; i &lt; heights.length; i++) &#123; if (heights[i] &gt;= h) &#123; width++; //出现小于当前高度的就归零，并且更新最大宽度 &#125; else &#123; maxWidth = Math.max(width, maxWidth); width = 0; &#125; &#125; maxWidth = Math.max(width, maxWidth); //更新最大区域的面积 maxArea = Math.max(maxArea, h * maxWidth); &#125; return maxArea; &#125;&#125; 作者：windliang链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-7/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 单调递增栈法 123456789101112131415161718192021222324class Solution &#123; public int largestRectangleArea(int[] heights)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int max = 0; stack.push(-1); for(int i = 0; i &lt; heights.length; i++)&#123; // 1. 栈中值不等于 -1 且 栈顶元素对应的高度 大于 正在遍历的元素的高度 while(stack.peek() != -1 &amp;&amp; heights[stack.peek()] &gt; heights[i])&#123; max = Math.max(max,heights[stack.pop()] * (i - stack.peek() - 1)); &#125; // 2. 栈中值不等于 -1 且 栈顶元素对应的高度 == 正在遍历的元素的高度 // 直接把当前栈顶弹栈即可 if(stack.peek() != -1 &amp;&amp; heights[stack.peek()] == heights[i])&#123; stack.pop(); &#125; stack.push(i); &#125; // 遍历完了，但是没计算完 while(stack.peek() != -1)&#123; max = Math.max(max,heights[stack.pop()] * (heights.length - stack.peek() - 1)); &#125; return max; &#125;&#125; 85. 最大矩形题目给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例: 12345678输入:[ ["1","0","1","0","0"], ["1","0","1","1","1"], ["1","1","1","1","1"], ["1","0","0","1","0"]]输出: 6 思路思路同84题，每一行都调用84题的算法即可。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix.length == 0) return 0; int maxarea = 0; int[] dp = new int[matrix[0].length]; for(int i = 0; i &lt; matrix.length; i++) &#123; for(int j = 0; j &lt; matrix[0].length; j++) &#123; // update the state of this row's histogram using the last row's histogram // by keeping track of the number of consecutive ones dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0; &#125; // update maxarea with the maximum area from this row's histogram maxarea = Math.max(maxarea, largestRectangleArea(dp)); &#125; return maxarea; &#125; public int largestRectangleArea(int[] heights)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int max = 0; stack.push(-1); for(int i = 0; i &lt; heights.length; i++)&#123; while(stack.peek() != -1 &amp;&amp; heights[stack.peek()] &gt; heights[i])&#123; max = Math.max(max,heights[stack.pop()] * (i - stack.peek() - 1)); &#125; if(stack.peek() != -1 &amp;&amp; heights[stack.peek()] == heights[i])&#123; stack.pop(); &#125; stack.push(i); &#125; while(stack.peek() != -1)&#123; max = Math.max(max,heights[stack.pop()] * (heights.length - stack.peek() - 1)); &#125; return max; &#125;&#125; 121. 买卖股票的最佳时机题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 思路假设当前在第 i 天，令 minPrice 表示前 i-1 天的最低价格；令 maxProfit 表示前 i-1 天的最大收益。那么考虑第 i 天的收益时，存在两种情况： 在第 i 天卖出。很显然，想要获得最大收益，应该在前 i-1 天中价格最低的时候买入，即此时的收益为：prices[i] - minPrice。（可能会出现负数，但是没关系） 不在第 i 天卖出。那么第 i 天的最大收益就等于前 i -1 天中的最大收益 状态转移方程为：第 i 天最大收益 = max( 在第 i 天卖出的所得收益 , 前 i-1 天的最大收益) 代码1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int minPrice = Integer.MAX_VALUE; int maxProfit = 0; for (int i = 0; i &lt; prices.length; i++) &#123; minPrice = Math.min(minPrice, prices[i]); maxProfit = Math.max(maxProfit, prices[i] - minPrice); &#125; return maxProfit; &#125;&#125; 股票问题详解：https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tuan-mie-gu-piao-wen-ti 128. 最长连续序列题目给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 思路 暴力法。从头到尾遍历每个数，然后对每个数去找数组中是否存在下一个数，如果存在，就找是否存在下一个再下一个的数，以此类推。 排序之后再进行判断，这个很简单…不讲了。 用 Set 存储数组，这样查询是否有该数的时候，直接就是 O(1) 的复杂度，同时不需要数组从头到尾遍历，只有在（遍历的元素值 - 1） 不在 Set 中，才开始判断其下一个是否在 Set 中，这样就可以减少遍历的次数。 代码 暴力 12345678910111213141516171819202122232425262728class Solution &#123; private boolean arrayContains(int[] arr, int num) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == num) &#123; return true; &#125; &#125; return false; &#125; public int longestConsecutive(int[] nums) &#123; int longestStreak = 0; for (int num : nums) &#123; int currentNum = num; int currentStreak = 1; while (arrayContains(nums, currentNum + 1)) &#123; currentNum += 1; currentStreak += 1; &#125; longestStreak = Math.max(longestStreak, currentStreak); &#125; return longestStreak; &#125;&#125; 排序 1234567891011121314151617181920212223242526class Solution &#123; public int longestConsecutive(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; Arrays.sort(nums); int longestStreak = 1; int currentStreak = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] != nums[i-1]) &#123; if (nums[i] == nums[i-1]+1) &#123; currentStreak += 1; &#125; else &#123; longestStreak = Math.max(longestStreak, currentStreak); currentStreak = 1; &#125; &#125; &#125; return Math.max(longestStreak, currentStreak); &#125;&#125; Set 1234567891011121314151617181920212223242526class Solution &#123; public int longestConsecutive(int[] nums) &#123; Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums) &#123; num_set.add(num); &#125; int longestStreak = 0; for (int num : num_set) &#123; if (!num_set.contains(num-1)) &#123; int currentNum = num; int currentStreak = 1; while (num_set.contains(currentNum+1)) &#123; currentNum += 1; currentStreak += 1; &#125; longestStreak = Math.max(longestStreak, currentStreak); &#125; &#125; return longestStreak; &#125;&#125; 具体见 官方题解：https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/ 152. 乘积最大子序列题目给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 思路这其实说白了就是子串的题目，所以必须使用动态规划去做。做 dp 的题目，我觉得首先最重要的不是状态转移方程，而是dp数组的含义是什么，只有这个确定对了，状态方程才能很好的列出来！！！ 这里的 dp 数组指的是以第 i 个数 结尾的 连续子序列，由于存在负数，所以必须维护两个 dp 数组，其实这里根本用不到数组，但是为了更加清晰的看到 dp 的思想，我还是用数组来表达吧。 我们先考虑都是正数的情况。dp_max[i] 的含义我们已经讲过了，dp_max[i] = Math.max(nums[i-1],dp_max[i-1]*nums[i-1])，即 dp_max[i] 这个值只会在这两者产生，要么 乘上之前的会更大，要么 舍弃前面的。 接下来考虑负数的情况，所以我们有必要维护一个 dp_min，思路是一模一样的，当遍历的元素为负数时，我们只需要把 dp_max[i-1]，dp_min[i-1]交换即可。 最后，只要找到所有dp_max中的数值最大的那个，就是我们需要的值了。 代码1234567891011121314151617181920212223242526class Solution &#123; public int maxProduct(int[] nums) &#123; int[] dp_max = new int[nums.length+1]; int[] dp_min = new int[nums.length+1]; if(nums.length == 0) return 0; int max = Integer.MIN_VALUE; // 由于存在负数，所以需要维护两个数组 // dp_max[i] 指的是以第 i 个数结尾的 乘积最大 的连续子序列 // dp_min[i] 指的是以第 i 个数结尾的 乘积最小 的连续子序列 dp_max[0] = 1; dp_min[0] = 1; for (int i = 1;i &lt;= nums.length;i++)&#123; // 如果数组的数是负数，那么会导致 max 变成 min，min 变成 max // 故需要交换dp if(nums[i-1] &lt; 0)&#123; int temp = dp_min[i-1]; dp_min[i-1] = dp_max[i-1]; dp_max[i-1] = temp; &#125; dp_min[i] = Math.min(nums[i-1],dp_min[i-1]*nums[i-1]); dp_max[i] = Math.max(nums[i-1],dp_max[i-1]*nums[i-1]); max = Math.max(max,dp_max[i]); &#125; return max; &#125;&#125; 155. 最小栈题目设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。 pop() – 删除栈顶的元素。 top() – 获取栈顶元素。 getMin() – 检索栈中的最小元素。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 思路https://leetcode-cn.com/problems/min-stack/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-38/ 用两个栈，一个栈专门存最小值，主要就是入栈和出栈做到同步就行。存最小值的栈的具体操作流程如下： 将第一个元素入栈。 新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。 新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。 出栈元素不等于栈顶元素，不操作。 出栈元素等于栈顶元素，那么就将栈顶元素出栈。 用一个栈，当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。 栈中存储链表，其中设定一个节点包括其 val，和当前最小值。 代码 两个栈 123456789101112131415161718192021222324252627282930313233343536373839404142class MinStack &#123; /** initialize your data structure here. */ private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (!minStack.isEmpty()) &#123; int top = minStack.peek(); //小于的时候才入栈 if (x &lt;= top) &#123; minStack.push(x); &#125; &#125;else&#123; minStack.push(x); &#125; &#125; public void pop() &#123; int pop = stack.pop(); int top = minStack.peek(); //等于的时候再出栈 if (pop == top) &#123; minStack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; 单个栈 1234567891011121314151617181920212223242526272829class MinStack &#123; int min = Integer.MAX_VALUE; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); public void push(int x) &#123; //当前值更小 if(x &lt;= min)&#123; //将之前的最小值保存 stack.push(min); //更新最小值 min=x; &#125; stack.push(x); &#125; public void pop() &#123; //如果弹出的值是最小值，那么将下一个元素更新为最小值 if(stack.pop() == min) &#123; min=stack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125; 存储链表 123456789101112131415161718192021222324252627282930313233343536373839404142class MinStack &#123; class Node&#123; int value; int min; Node next; Node(int x, int min)&#123; this.value=x; this.min=min; next = null; &#125; &#125; Node head; //每次加入的节点放到头部 public void push(int x) &#123; if(null==head)&#123; head = new Node(x,x); &#125;else&#123; //当前值和之前头结点的最小值较小的做为当前的 min Node n = new Node(x, Math.min(x,head.min)); n.next=head; head=n; &#125; &#125; public void pop() &#123; if(head!=null) head =head.next; &#125; public int top() &#123; if(head!=null) return head.value; return -1; &#125; public int getMin() &#123; if(null!=head) return head.min; return -1; &#125;&#125; 5330. 分裂二叉树的最大乘积题目给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。 示例 1： 123输入：root = [1,2,3,4,5,6]输出：110解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10 示例 2： 123输入：root = [1,null,2,3,4,null,null,5,6]输出：90解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6） 代码123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; private static final long MOD = (long) (1e9 + 7); public int maxProduct(TreeNode root) &#123; Set&lt;Long&gt; ss = new HashSet&lt;&gt;(); long sum = dfs(root, ss); long ans = 0; for (Long s : ss) &#123; ans = Math.max(ans, s * (sum - s)); &#125; return (int) (ans % MOD); &#125; private long dfs(TreeNode root, Set&lt;Long&gt; ss) &#123; if (root == null) &#123; return 0; &#125; long l = dfs(root.left, ss); long r = dfs(root.right, ss); ss.add(l); ss.add(r); return l + r + root.val; &#125;&#125; 206. 反转链表题目反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路迭代设置三个节点pre、cur、next （1）每次查看cur节点是否为NULL，如果是，则结束循环，获得结果 （2）如果cur节点不是为NULL，则先设置临时变量next为cur的下一个节点 （3）让cur的下一个节点变成指向pre，而后pre移动cur，cur移动到next （4）重复（1）（2）（3） 递归拿到手之后，是直接使用的递归的做法，看评论区大家好像对递归的过程都觉得很绕，其实我个人觉得大家把这个想复杂了，下面我来试着帮大家一起理解一下！递归，就是三部曲： 1、找到递归出口 2、确定返回值 3、分析单次递归需要做的事情 下面，我们来具体分析一下： 首先，找到递归出口，这个还是非常简单的，就是当前即将反转的节点为 null 或者是 反转链表 为 null 时（一轮递归其实就只有两个节点，后面会讲），说明已经全部反转完毕了，即递归出口； 其次，确定返回值，我们只需要返回反转链表的头结点即可； 最后，分析单次递归需要做的事情，我觉得大家觉得递归比较难理解的地方就是在这，其实是大家把递归复杂化了，递归其实每一轮做的事情都是一样的，我们不需要去重复考虑，这样反而会很乱，只需要考虑单轮递归需要做什么就可以了。在这里，我们就只有两个节点，一个是即将反转的节点元素，一个是已经反转完毕的链表头结点。 我们要做的一轮递归只是 将当前节点加入到反转链表中，仅此而已。 代码 迭代 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode prev = null; ListNode curr = head; while (curr != null) &#123; ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; &#125; return prev; &#125;&#125; 递归 123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseList(ListNode head) &#123; // 如果当前要反转的节点为 null 或者反转链表为 null // head.next 为 null，即反转链表的尾结点不存在，即反转链表不存在 if (head == null || head.next == null) return head; // 节点 p 其实就是反转链表的头节点 ListNode p = reverseList(head.next); // 我们将反转链表的尾结点（head.next）的 next 指向当前即将反转的节点 head.next.next = head; // 然后让当前节点变成反转链表的尾结点 head.next = null; // 返回反转链表的头结点 return p; &#125;&#125; 160. 相交链表题目编写一个程序，找到两个单链表相交的起始节点。 【注意：这里相交节点并不是看链表的值相等就代表相交，得是两个节点直接相等才代表相交，指向同一块内存。】 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null。 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 思路 最开始的思路就是，找到 长链表和短链表的长度差 c ，这样第二次遍历的时候，长链表从第 c+1 个节点出发，短链表从第一个节点出发，这样最后二者必是同时到达终点的，而二者如果有相交，则在遍历的时候节点必相等，第一个相等的节点就是相交的起始节点。 还有一个思路可以找到相交的起始节点，我们无需去计算长链表和短链表的长度差 c，只需要让两个指针 p1、p2 同时从链表头结点处出发，假设 长链表长度为 a，短链表的长度为 b，当短链表指针p2遍历到 null，即遍历完了短链表，将其移到长链表头结点继续遍历，同时p1也继续向前遍历，当p1遍历到 null 时，将其移到短链表头节点继续遍历，这样 如果长链表和短链表相交，则 p1 和 p2 必会在相交起始处相遇，如果两个链表不相交，p1 和 p2 会在 null 处相遇。 代码 Code I 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode p1 = headA; ListNode p2 = headB; while(p1 != null &amp;&amp; p2 != null)&#123; p1 = p1.next; p2 = p2.next; &#125; // 说明 headA 是短链表 if(p1 == null)&#123; // 计算差值 int difference = 0; while(p2 != null)&#123; p2 = p2.next; difference++; &#125; p1 = headA; p2 = headB; for(int i = 0;i &lt; difference;i++)&#123; p2 = p2.next; &#125; while (p1 != p2)&#123; p1 = p1.next; p2 = p2.next; &#125; return p1; &#125; // 说明 headB 是短链表 else&#123; int difference = 0; while(p1 != null)&#123; p1 = p1.next; difference++; &#125; p1 = headA; p2 = headB; for(int i = 0;i &lt; difference;i++)&#123; p1 = p1.next; &#125; while (p1 != p2)&#123; p1 = p1.next; p2 = p2.next; &#125; return p1; &#125; &#125;&#125; Code II 123456789public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while (pA != pB) &#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA;&#125; 234. 回文链表题目请判断一个链表是否为回文链表。 示例 1: 12输入: 1-&gt;2输出: false 示例 2: 12输入: 1-&gt;2-&gt;2-&gt;1输出: true 思路 链表转列表 1.快慢指针找到链表的中点2.翻转链表前半部分3.回文校验 一边翻转一边快慢指针遍历 代码 Case I 1234567891011121314151617181920212223242526class Solution &#123; public boolean isPalindrome(ListNode head) &#123; List&lt;Integer&gt; vals = new ArrayList&lt;&gt;(); // Convert LinkedList into ArrayList. ListNode currentNode = head; while (currentNode != null) &#123; vals.add(currentNode.val); currentNode = currentNode.next; &#125; // Use two-pointer technique to check for palindrome. int front = 0; int back = vals.size() - 1; while (front &lt; back) &#123; // Note that we must use ! .equals instead of != // because we are comparing Integer, not int. if (!vals.get(front).equals(vals.get(back))) &#123; return false; &#125; front++; back--; &#125; return true; &#125;&#125; Case II 123456789101112131415161718192021222324252627282930313233343536public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) &#123; return true; &#125; //快慢指针找到链表的中点 ListNode fast = head.next.next; ListNode slow = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; //翻转链表前半部分 ListNode pre = null; ListNode next = null; while (head != slow) &#123; next = head.next; head.next = pre; pre = head; head = next; &#125; //如果是奇数个节点，去掉后半部分的第一个节点。 if (fast != null) &#123; slow = slow.next; &#125; //回文校验 while (pre != null) &#123; if (pre.val != slow.val) &#123; return false; &#125; pre = pre.next; slow = slow.next; &#125; return true; &#125; Case III 12345678910111213141516171819202122232425public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) &#123; return true; &#125; ListNode slow = head, fast = head; ListNode pre = head, prepre = null; while(fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; pre.next = prepre; prepre = pre; &#125; if(fast != null) &#123; slow = slow.next; &#125; while(pre != null &amp;&amp; slow != null) &#123; if(pre.val != slow.val) &#123; return false; &#125; pre = pre.next; slow = slow.next; &#125; return true;&#125; 169. 多数元素题目给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 思路 哈希表存储。 投票算法，如果我们把众数记为 +1 ，把其他数记为 −1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。本质上， Boyer-Moore 算法就是找 nums 的一个后缀 suf ，其中 suf[0] 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数。 代码 Case I 123456789101112class Solution &#123; public int majorityElement(int[] nums) &#123; int majority = nums.length / 2; Map&lt;Integer, Integer&gt; numCount = new HashMap&lt;&gt;(); for (int num : nums) &#123; int count = numCount.getOrDefault(num, 0) + 1; if (count &gt; majority) return num; numCount.put(num, count); &#125; return -1; &#125;&#125; Case II 123456789101112131415class Solution &#123; public int majorityElement(int[] nums) &#123; int count = 0; Integer candidate = null; for (int num : nums) &#123; if (count == 0) &#123; candidate = num; &#125; count += (num == candidate) ? 1 : -1; &#125; return candidate; &#125;&#125; 200. 岛屿数量题目给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 思路思路一：深度优先遍历DFS 目标是找到矩阵中 “岛屿的数量” ，上下左右相连的 1 都被认为是连续岛屿。 dfs方法： 设目前指针指向一个岛屿中的某一点 (i, j)，寻找包括此点的岛屿边界。 从 (i, j) 向此点的上下左右 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 做深度搜索。 终止条件： (i, j) 越过矩阵边界; grid[i][j]== 0，代表此分支已越过岛屿边界。 搜索岛屿的同时，执行 grid[i][j] = ‘0’，即将岛屿所有节点删除，以免之后重复搜索相同岛屿。 主循环： 遍历整个矩阵，当遇到 grid[i][j] == ‘1’ 时，从此点开始做深度优先搜索 dfs，岛屿数 count + 1 且在深度优先搜索中删除此岛屿。 最终返回岛屿数 count 即可。 思路二：广度优先遍历BFS 主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。 bfs 方法： 借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1： 若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列； 若不是则跳过此节点； 循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。 代码 Case I 12345678910111213141516171819202122class Solution &#123; public int numIslands(char[][] grid) &#123; int count = 0; for(int i = 0; i &lt; grid.length; i++) &#123; for(int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j] == '1')&#123; dfs(grid, i, j); count++; &#125; &#125; &#125; return count; &#125; private void dfs(char[][] grid, int i, int j)&#123; if(i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] == '0') return; grid[i][j] = '0'; dfs(grid, i + 1, j); dfs(grid, i, j + 1); dfs(grid, i - 1, j); dfs(grid, i, j - 1); &#125;&#125; Case II 1234567891011121314151617181920212223242526272829class Solution &#123; public int numIslands(char[][] grid) &#123; int count = 0; for(int i = 0; i &lt; grid.length; i++) &#123; for(int j = 0; j &lt; grid[0].length; j++) &#123; if(grid[i][j] == '1')&#123; bfs(grid, i, j); count++; &#125; &#125; &#125; return count; &#125; private void bfs(char[][] grid, int i, int j)&#123; Queue&lt;int[]&gt; list = new LinkedList&lt;&gt;(); list.add(new int[] &#123; i, j &#125;); while(!list.isEmpty())&#123; int[] cur = list.remove(); i = cur[0]; j = cur[1]; if(0 &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == '1') &#123; grid[i][j] = '0'; list.add(new int[] &#123; i + 1, j &#125;); list.add(new int[] &#123; i - 1, j &#125;); list.add(new int[] &#123; i, j + 1 &#125;); list.add(new int[] &#123; i, j - 1 &#125;); &#125; &#125; &#125;&#125; 作者：jyd链接：https://leetcode-cn.com/problems/number-of-islands/solution/number-of-islands-shen-du-you-xian-bian-li-dfs-or-/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123; class UnionFind &#123; int count; // # of connected components int[] parent; int[] rank; public UnionFind(char[][] grid) &#123; // for problem 200 count = 0; int m = grid.length; int n = grid[0].length; parent = new int[m * n]; rank = new int[m * n]; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == '1') &#123; parent[i * n + j] = i * n + j; ++count; &#125; rank[i * n + j] = 0; &#125; &#125; &#125; public int find(int i) &#123; // path compression if (parent[i] != i) parent[i] = find(parent[i]); return parent[i]; &#125; public void union(int x, int y) &#123; // union with rank int rootx = find(x); int rooty = find(y); if (rootx != rooty) &#123; if (rank[rootx] &gt; rank[rooty]) &#123; parent[rooty] = rootx; &#125; else if (rank[rootx] &lt; rank[rooty]) &#123; parent[rootx] = rooty; &#125; else &#123; parent[rooty] = rootx; rank[rootx] += 1; &#125; --count; &#125; &#125; public int getCount() &#123; return count; &#125; &#125; public int numIslands(char[][] grid) &#123; if (grid == null || grid.length == 0) &#123; return 0; &#125; int nr = grid.length; int nc = grid[0].length; int num_islands = 0; UnionFind uf = new UnionFind(grid); for (int r = 0; r &lt; nr; ++r) &#123; for (int c = 0; c &lt; nc; ++c) &#123; if (grid[r][c] == '1') &#123; grid[r][c] = '0'; if (r - 1 &gt;= 0 &amp;&amp; grid[r-1][c] == '1') &#123; uf.union(r * nc + c, (r-1) * nc + c); &#125; if (r + 1 &lt; nr &amp;&amp; grid[r+1][c] == '1') &#123; uf.union(r * nc + c, (r+1) * nc + c); &#125; if (c - 1 &gt;= 0 &amp;&amp; grid[r][c-1] == '1') &#123; uf.union(r * nc + c, r * nc + c - 1); &#125; if (c + 1 &lt; nc &amp;&amp; grid[r][c+1] == '1') &#123; uf.union(r * nc + c, r * nc + c + 1); &#125; &#125; &#125; &#125; return uf.getCount(); &#125;&#125; 221. 最大正方形题目在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 思路前面做了一题求 最大长方形的题目，当时的思路是用的第 84 题 柱状图中最大的矩形 ，分别求每一行的最大矩形，最后得到 整个的最大长方形。这里求正方形，就不能用那种方法了，必须得另辟蹊径。 这里采用的是 dp，既然是找最大正方形，其实找对 dp数组代表什么 和 状态转移方程 如何写，就完成了，这里的 dp 数组代表以 该元素为右下角的正方形边长，故 dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1 代码12345678910111213141516public class Solution &#123; public int maximalSquare(char[][] matrix) &#123; int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0; int[][] dp = new int[rows + 1][cols + 1]; int maxsqlen = 0; for (int i = 1; i &lt;= rows; i++) &#123; for (int j = 1; j &lt;= cols; j++) &#123; if (matrix[i-1][j-1] == '1')&#123; dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1; maxsqlen = Math.max(maxsqlen, dp[i][j]); &#125; &#125; &#125; return maxsqlen * maxsqlen; &#125;&#125; 由于当前 dp[i][j] 只用到了左上、左边、上边三个元素，所以不需要建立一个二维数组去操作，只需要用一个一维的数组去存每一行对应的列的数就行了，可以复用，至于 左上角 的数，可以用一个变量单独记录一下（这个是真的牛皮） 1234567891011121314151617181920public class Solution &#123; public int maximalSquare(char[][] matrix) &#123; int rows = matrix.length, cols = rows &gt; 0 ? matrix[0].length : 0; int[] dp = new int[cols + 1]; int maxsqlen = 0, prev = 0; for (int i = 1; i &lt;= rows; i++) &#123; for (int j = 1; j &lt;= cols; j++) &#123; int temp = dp[j]; if (matrix[i - 1][j - 1] == '1') &#123; dp[j] = Math.min(Math.min(dp[j - 1], prev), dp[j]) + 1; maxsqlen = Math.max(maxsqlen, dp[j]); &#125; else &#123; dp[j] = 0; &#125; prev = temp; &#125; &#125; return maxsqlen * maxsqlen; &#125;&#125; 207. 课程表题目现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 思路这题本质就是拓扑排序，解决拓扑排序，一般就是两个方法：BFS 和 DFS。其核心都是能拓扑排序的都是有向无环图。BFS 主要是从 入度出度考虑，而 DFS 主要从有无环考虑。 详细思路见： https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/ 代码 BFS 12345678910111213141516171819202122232425262728293031class Solution &#123; // BFS public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // 记录每个结点的入度，类似于邻接表 int[] indegrees = new int[numCourses]; // 统计每个结点的入度数 // 这个题目的好处是课程是从0开始的，所以我们申请空间很方便 for(int[] cp : prerequisites) indegrees[cp[0]]++; // 队列用来存储入度为0的结点 LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 如果找到入度为0的，放入队尾 for(int i = 0; i &lt; numCourses; i++)&#123; if(indegrees[i] == 0) queue.addLast(i); &#125; // 只要队列不为空，就一直循环 while(!queue.isEmpty()) &#123; // 取出队首元素 Integer pre = queue.removeFirst(); // 相当于删除操作，说明此门课程已经学完 numCourses--; // 然后把这门课程的出度删除 // 并把新的入度为0的课程加入队列 for(int[] req : prerequisites) &#123; if(req[1] != pre) continue; if(--indegrees[req[0]] == 0) queue.add(req[0]); &#125; &#125; // 队列为空，如果能全部学习完，numCourses == 0，否则不能全部学习完 return numCourses == 0; &#125;&#125; DFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; /** * DFS 方法 * @param numCourses * @param prerequisites * @return */ public boolean canFinish(int numCourses, int[][] prerequisites) &#123; // 用来表示节点之间是否有边,类似于 邻接矩阵 int[][] arc = new int[numCourses][numCourses]; for(int[] cp:prerequisites)&#123; arc[cp[1]][cp[0]] = 1; &#125; // 对每个节点分别进行dfs // dfs 主要是判断是否有环的存在，在这里我们引入 flag // flag == 1，代表该节点本轮dfs已经访问过了,即正在访问的节点 // flag == -1，代表以前的dfs访问过了 // flag == 0，代表该节点从未访问过 // 只有当我们访问到了 flag == 1的节点，说明存在环 int[] flag = new int[numCourses]; for(int i = 0;i &lt; numCourses;i++)&#123; if(dfs(arc,i,flag) == false) return false; &#125; return true; &#125; /** * dfs 具体流程 * @param arc * @param i * @param flag * @return */ private boolean dfs(int[][] arc, int i, int[] flag) &#123; // 发现是本轮 dfs 正在访问的节点，故存在环 if(flag[i] == 1) return false; // 是其他结点发起的 dfs，没有关系，不能判断是否有环 if(flag[i] == -1) return true; // 标记一下本轮dfs正在访问该节点 flag[i] = 1; // 进行 dfs，发现有环，返回 false for(int j = 0;j &lt; arc.length;j++)&#123; if(arc[i][j] == 1 &amp;&amp; dfs(arc,j,flag) == false) return false; &#125; // 该节点的 dfs 结束，标志位变为 -1 flag[i] = -1; return true; &#125;&#125; 208. 实现 Trie (前缀树)题目实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: 12345678Trie trie = new Trie();trie.insert("apple");trie.search("apple"); // 返回 truetrie.search("app"); // 返回 falsetrie.startsWith("app"); // 返回 truetrie.insert("app"); trie.search("app"); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 思路 https://blog.csdn.net/qq_43152052/article/details/101109415 大佬对 leetcode 前缀树的习题总结 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package LeetCode_100_hotest;class Trie_208 &#123; public static void main(String[] args) &#123; Trie obj = new Trie(); String word = "apple"; String prefix = "app"; obj.insert(word); boolean param_2 = obj.search(word); boolean param_3 = obj.startsWith(prefix); System.out.println("param_2:" + param_2); System.out.println("param_3:" + param_3); &#125;&#125;class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char currentChar = word.charAt(i); if (!node.containsKey(currentChar)) &#123; node.put(currentChar, new TrieNode()); &#125; node = node.get(currentChar); &#125; node.setEnd(); &#125; private TrieNode searchPrefix(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char curLetter = word.charAt(i); if (node.containsKey(curLetter)) &#123; node = node.get(curLetter); &#125; else &#123; return null; &#125; &#125; return node; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode node = searchPrefix(word); return node != null &amp;&amp; node.isEnd(); &#125; public boolean startsWith(String prefix) &#123; TrieNode node = searchPrefix(prefix); return node != null; &#125;&#125;class TrieNode &#123; // R links to node children // 这里不止是 left、right，所以必须是一个数组组成 private TrieNode[] links; private final int R = 26; private boolean isEnd; public TrieNode() &#123; links = new TrieNode[R]; &#125; public boolean containsKey(char ch) &#123; return links[ch -'a'] != null; &#125; public TrieNode get(char ch) &#123; return links[ch -'a']; &#125; public void put(char ch, TrieNode node) &#123; links[ch -'a'] = node; &#125; public void setEnd() &#123; isEnd = true; &#125; public boolean isEnd() &#123; return isEnd; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ 739. 每日温度题目根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 思路很明显是采用单调栈的方法，具体见 https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-zhan 代码1234567891011121314class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] ans = new int[T.length]; for(int i = T.length - 1; i &gt;= 0;i--)&#123; while(!stack.isEmpty() &amp;&amp; T[i] &gt;= T[stack.peek()])&#123; stack.pop(); &#125; ans[i] = stack.isEmpty() == true ? 0 : (stack.peek() - i); stack.push(i); &#125; return ans; &#125;&#125; 621. 任务调度器题目给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。 你需要计算完成所有任务所需要的最短时间。 示例 1 123输入: tasks = ["A","A","A","B","B","B"], n = 2输出: 8执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B. 思路 桶思想，每个桶固定大小为 n+1（除最后一个桶之外），这样可以确保相同的任务可以分在不同的桶中 当然，每个任务在桶中的次序是固定的，比如说 A 在桶底，那么在每个桶中 A 都在底部，这样可以确保相同任务的间隔时间都不小于 n 桶的数量由 拥有最多任务数的那个任务决定，只要他保证了冷却时间，其他的一定可以 结果就是 (n+1) \ (count - 1) + 最后一个桶的大小*，count 为桶的数量，因为最后一个桶无需固定大小 count 很好求，那最后一个桶大小如何求呢，很明显就是 拥有最多数任务的个数，比如AAABBBCCCDDEE，那最后一个桶的大小就是 3，因为 A B C 都是拥有 3 个任务数 如果冷却时间过短，任务数过多，也就是说桶不够用了，比如说 AAABBBCCCDDEE 且 n = 2 这种情况，此时 桶的大小为 3，桶的数量为 3。第一个桶 ABC ，第二个 ABC，第三个 ABC，此时的 D 和 E 我们可以理解为按照一定次序放在桶之上就行 ，也就是不用放到桶中，这样不会影响桶内元素 由于 D 和 E 的出现次数是一定小于桶的数量的，所以最多每个桶上放一个相同任务，这样 D 和 E 按次序排布是一定符合要求的 此时的答案就是 任务总数 了，因为所有的桶都满了，并且多出来的也是任务，没有待命时间 故答案就是 两个时间 的最大值 代码1234567891011121314151617181920class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; HashMap&lt;Character, Integer&gt; task_map = new HashMap&lt;&gt;(); // 记录 单个任务出现的最多的次数 int max_count = 0; // 记录 有最多任务数的 任务个数 int difference = 0; for (Character task : tasks) &#123; int count = task_map.getOrDefault(task, 0) + 1; task_map.put(task, count); max_count = Math.max(max_count,count); &#125; for(Map.Entry&lt;Character, Integer&gt; entry:task_map.entrySet())&#123; if(entry.getValue() == max_count) difference++; &#125; int number1 = (n + 1) * (max_count - 1) + difference; int number2 = tasks.length; return Math.max(number1,number2); &#125;&#125; 581. 最短无序连续子数组题目给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。 你找到的子数组应是最短的，请输出它的长度。 示例 1: 123输入: [2, 6, 4, 8, 10, 9, 15]输出: 5解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。 思路我采用的是排序 代码12345678910111213141516171819202122232425class Solution &#123; public int findUnsortedSubarray(int[] nums) &#123; int[] copy = Arrays.copyOf(nums,nums.length); Arrays.sort(copy); int start = 0; int end = 0; for(int i = 0;i &lt; nums.length;i++)&#123; if(nums[i] != copy[i])&#123; start = i; break; &#125; &#125; for(int j = nums.length-1;j &gt;= 0;j--)&#123; if(nums[j] != copy[j])&#123; end = j; // 其实这步应该放到最后 end - start + 1 // 但是为了防止num.length == 0 以及 正序的数组 结果正确 // 就放到了这里 end++; break; &#125; &#125; return end - start; &#125;&#125; 560. 和为K的子数组题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 思路 暴力法，两次 for 循环，首先是 start，然后 end 从第一个数开始，当碰到 sum = k 时 count 就 + 1 dp。dp[i] 表示从0到第 i 个数的总和，则 dp[j] - dp[i] = k，这个 dp[i] 的个数就是 连续子数组的个数，这里可以用 HashMap 直接存储 和 以及 和 出现的次数，这样就可以非常方便的求得 dp[i] 的个数。 代码 暴力法 12345678910111213141516class Solution &#123; public int subarraySum(int[] nums, int k) &#123; if (nums.length == 0) return 0; int res = 0; for (int i = 0; i &lt; nums.length; i++) &#123; int sum = 0; for (int j = i; j &lt; nums.length; j++) &#123; sum += nums[j]; if (sum == k) &#123; res++; &#125; &#125; &#125; return res; &#125;&#125; dp 123456789101112131415161718192021222324import java.util.HashMap;class Solution &#123; public static void main(String[] args) &#123; new Solution().subarraySum(new int[]&#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;, 0); &#125; public int subarraySum(int[] nums, int k) &#123; if (nums == null || nums.length == 0) return 0; //dp[i]表示前i个数的和 int[] dp = new int[nums.length + 1]; for (int i = 1; i &lt;= nums.length; i++) &#123; dp[i] = dp[i - 1] + nums[i - 1]; &#125; int ret = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; dp.length; i++) &#123; if (map.containsKey(dp[i] - k)) ret += map.get(dp[i] - k); map.put(dp[i], map.getOrDefault(dp[i], 0) + 1); &#125; return ret; &#125;&#125; dp 优化 123456789101112131415public class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int count = 0, sum = 0; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 和为0的总和，出现了一次 map.put(0, 1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; if (map.containsKey(sum - k)) count += map.get(sum - k); map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return count; &#125;&#125; 238. 除自身以外数组的乘积题目给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 思路 左边乘积 \ 右边乘积*，题目中要求使用 O(1) 的空间复杂度，但是 输出数组 不被视为额外空间，于是可以用左边乘积 * 右边乘积，具体见代码！ 代码123456789101112131415161718class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res = new int[nums.length]; res[0] = 1; for(int i = 1;i &lt; nums.length;i++)&#123; // 此时是计算每个值的左边乘积 res[i] = res[i-1] * nums[i-1]; &#125; // 此时需要一个变量来表示右边乘积 // 但是不需要数组，因为从右边开始算，算完一个就可以清除它 int right = 1; for(int j = nums.length - 1;j &gt;= 0;j--)&#123; res[j] = res[j] * right; right = right * nums[j]; &#125; return res; &#125;&#125; 239. 滑动窗口最大值题目给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回滑动窗口中的最大值。 示例: 123456789101112输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置 最大值--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 提示： 1你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 进阶： 1你能在线性时间复杂度内解决此题吗？ 思路 暴力法 双端队列法。遍历数组，将数存放在双向队列中，并用L,R来标记窗口的左边界和右边界。队列中保存的并不是真的数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L和R都为0，有一个形成窗口的过程，此过程没有最大值，L不动，R向右移。当窗口大小形成时，L和R一起向右移，每次移动时，判断队首的值的数组下标是否在[L,R]中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。 【有点难，适当记忆步骤】 作者：hanyuhuang链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/shuang-xiang-dui-lie-jie-jue-hua-dong-chuang-kou-2/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 dp。这个就更骚了…见官方题解方法三 代码 暴力法 1234567891011121314class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums.length == 0) return new int[]&#123;&#125;; int[] res = new int[nums.length+1-k]; for(int i = 0;i &lt;= nums.length-k;i++)&#123; int max = Integer.MIN_VALUE; for(int j = 0;j &lt; k;j++)&#123; max = Math.max(max,nums[i+j]); &#125; res[i] = max; &#125; return res; &#125;&#125; 双端队列法 123456789101112131415161718192021222324252627class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if(nums == null || nums.length &lt; 2) return nums; // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序 LinkedList&lt;Integer&gt; queue = new LinkedList(); // 结果数组 int[] result = new int[nums.length-k+1]; // 遍历nums数组 for(int i = 0;i &lt; nums.length;i++)&#123; // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求 while(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i])&#123; queue.pollLast(); &#125; // 添加当前值对应的数组下标 queue.addLast(i); // 判断当前队列中队首的值是否有效 if(queue.peek() &lt;= i-k)&#123; queue.poll(); &#125; // 当窗口长度为k时 保存当前窗口中最大值 if(i+1 &gt;= k)&#123; result[i+1-k] = nums[queue.peek()]; &#125; &#125; return result; &#125;&#125; dp 12345678910111213141516171819202122232425262728class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; if (n * k == 0) return new int[0]; if (k == 1) return nums; int [] left = new int[n]; left[0] = nums[0]; int [] right = new int[n]; right[n - 1] = nums[n - 1]; for (int i = 1; i &lt; n; i++) &#123; // from left to right if (i % k == 0) left[i] = nums[i]; // block_start else left[i] = Math.max(left[i - 1], nums[i]); // from right to left int j = n - i - 1; if ((j + 1) % k == 0) right[j] = nums[j]; // block_end else right[j] = Math.max(right[j + 1], nums[j]); &#125; int [] output = new int[n - k + 1]; for (int i = 0; i &lt; n - k + 1; i++) output[i] = Math.max(left[i + k - 1], right[i]); return output; &#125;&#125; 240. 搜索二维矩阵 II题目编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 思路暴力法直接先行后列遍历，遍历到了 target 退出。 二分查找法以对角线为界限，对角线之上的进行 行二分查找，对角线之下的进行 列二分查找。 减治法其实就是选定一个特殊的出发点。 选左上角，往右走和往下走都增大，不能选 选右下角，往上走和往左走都减小，不能选 选左下角，往右走增大，往上走减小，可选 选右上角，往下走增大，往左走减小，可选 这里我们选定左下角元素！！具体操作如下： * 设矩阵左下角元素 matrix\[i][j] ，它是第 i 行最小值，同时也是第 j 列最大值 若 target &lt; matrix[i][j] (小于第 i 行最小值)，则排除第 i 行，令 i– 若 target &gt; matrix[i][j] (大于第 j 列最大值)，则排除第 j 列，令 j++ 循环 2~3 直到找到 target，或所有行列均被排除 代码 暴力法 123456789101112class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == target) &#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) &#123; int lo = start; int hi = vertical ? matrix[0].length-1 : matrix.length-1; while (hi &gt;= lo) &#123; int mid = (lo + hi)/2; if (vertical) &#123; // searching a column if (matrix[start][mid] &lt; target) &#123; lo = mid + 1; &#125; else if (matrix[start][mid] &gt; target) &#123; hi = mid - 1; &#125; else &#123; return true; &#125; &#125; else &#123; // searching a row if (matrix[mid][start] &lt; target) &#123; lo = mid + 1; &#125; else if (matrix[mid][start] &gt; target) &#123; hi = mid - 1; &#125; else &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean searchMatrix(int[][] matrix, int target) &#123; // an empty matrix obviously does not contain `target` if (matrix == null || matrix.length == 0) &#123; return false; &#125; // iterate over matrix diagonals int shorterDim = Math.min(matrix.length, matrix[0].length); for (int i = 0; i &lt; shorterDim; i++) &#123; boolean verticalFound = binarySearch(matrix, target, i, true); boolean horizontalFound = binarySearch(matrix, target, i, false); if (verticalFound || horizontalFound) &#123; return true; &#125; &#125; return false; &#125;&#125; 减治法 12345678910111213141516171819class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; // start our "pointer" in the bottom-left int row = matrix.length-1; int col = 0; while (row &gt;= 0 &amp;&amp; col &lt; matrix[0].length) &#123; if (matrix[row][col] &gt; target) &#123; row--; &#125; else if (matrix[row][col] &lt; target) &#123; col++; &#125; else &#123; // found it return true; &#125; &#125; return false; &#125;&#125; 279. 完全平方数题目给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2: 123输入: n = 13输出: 2解释: 13 = 4 + 9. 思路dp 代码123456789101112class Solution &#123; public int numSquares(int n) &#123; int[] dp = new int[n + 1]; // 默认初始化值都为0 for (int i = 1; i &lt;= n; i++) &#123; dp[i] = i; // 最坏的情况就是每次+1 for (int j = 1; i - j * j &gt;= 0; j++) &#123; dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程 &#125; &#125; return dp[n]; &#125;&#125; 283. 移动零题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 思路先复制后补0 代码1234567891011121314151617class Solution &#123; public void moveZeroes(int[] nums) &#123; int index = 0; for(int i = 0;i &lt; nums.length;i++)&#123; if(nums[i] != 0)&#123; // 先复制 nums[index] = nums[i]; index++; &#125; &#125; // 补0 while(index &lt; nums.length)&#123; nums[index] = 0; index++; &#125; &#125;&#125; 287. 寻找重复数题目给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 12输入: [1,3,4,2,2]输出: 2 示例 2: 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 思路 排序后，相邻元素如果相等，则 return 用 set 存储，一旦发现 key 已经存在，直接返回，否则存入 map 中 其实这是一个链表中非常常见的问题，就是寻找环的入口问题，n 个不同的数，相同的那个数其实就是形成一个环。即元素索引下标为节点 node，而 node 的 next 指针则是 元素值 所对应的索引下标值。 Tip: 例如[2,1,2,3,4]，这个是符合题目要求且符合自循环的情况，在nums[2]处，索引值和元素值相等，在这里的确，快慢指针会在2的位置不停指向自己，但是只要发生这种自循环的情况，那么重复的数字就是这个，我们依旧可以使用快慢指针的方法去做，因为我们的做法就是先求一次相遇，然后慢指针回到原点，第二次相遇就是环的起点，在这里，既然是自循环的，那么当然最后第二次相遇还是在这里，答案是一样的。 二分法 代码 排序 1234567891011class Solution &#123; public int findDuplicate(int[] nums) &#123; Arrays.sort(nums); for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i-1]) &#123; return nums[i]; &#125; &#125; return -1; &#125;&#125; Set 存储 123456789101112class Solution &#123; public int findDuplicate(int[] nums) &#123; Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;(); for (int num : nums) &#123; if (seen.contains(num)) &#123; return num; &#125; seen.add(num); &#125; return -1; &#125;&#125; 快慢指针 12345678910111213141516171819class Solution &#123; public int findDuplicate(int[] nums) &#123; // Find the intersection point of the two runners. int slow = nums[0]; int fast = nums[0]; do &#123; slow = nums[slow]; fast = nums[nums[fast]]; &#125; while (slow != fast); // Find the "entrance" to the cycle. slow = nums[0]; while (fast != slow) &#123; fast = nums[fast]; slow = nums[slow]; &#125; return fast; &#125;&#125; 二分 1234567891011121314151617181920212223class Solution &#123; public int findDuplicate(int[] nums) &#123; int left = 0; int right = nums.length - 1; while(left &lt;= right)&#123; int mid = left + (right - left)/2; int count = 0; int mid_count = 0; for(int i = 0;i &lt; nums.length;i++)&#123; if(nums[i] &lt;= mid) count++; if(nums[i] == mid) mid_count++; &#125; // 如果 [left,mid] 没有出现重复数字，count &lt;= mid // 否则说明在这个区间出现了重复的 // 这里跟常见的 二分有一点点不同，这里 right = mid，不是 right = mid - 1 // 因为我在上面计算 count 的时候 是有计算 mid 的 if(mid_count &gt; 1) return mid; if(count &gt; mid) right = mid - 1; else left = mid + 1; &#125; return -1; &#125;&#125; 301. 删除无效的括号（暂时未做哈~ 先把代码贴一下 第二遍写） 题目删除最小数量的无效括号，使得输入的字符串有效，返回所有可能的结果。 说明: 输入可能包含了除 ( 和 ) 以外的字符。 示例 1: 12输入: "()())()"输出: ["()()()", "(())()"] 示例 2: 12输入: "(a)())()"输出: ["(a)()()", "(a())()"] 示例 3: 12输入: ")("输出: [""] 思路代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; // 统计需要删除的左括号和右括号数量 int left = 0, right = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (c == '(') &#123; left++; &#125; else if (c == ')') &#123; if (left &gt; 0) left--; else right++; &#125; &#125; // 开始删除 List&lt;String&gt; res = new ArrayList&lt;&gt;(); List&lt;String&gt; array = new ArrayList&lt;&gt;(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); array.add(s); // 先删左括号 while (left-- &gt; 0) &#123; List&lt;String&gt; tempArray = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; array.size(); i++) &#123; String ss = array.get(i); for (int j = 0; j &lt; ss.length(); j++) &#123; if (ss.charAt(j) == '(') &#123; String sss = ss.substring(0, j) + ss.substring(j + 1); if (!set.contains(sss)) &#123; set.add(sss); tempArray.add(sss); &#125; &#125; &#125; &#125; array = tempArray; &#125; // 删右括号 while (right-- &gt; 0) &#123; List&lt;String&gt; tempArray = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; array.size(); i++) &#123; String ss = array.get(i); for (int j = 0; j &lt; ss.length(); j++) &#123; if (ss.charAt(j) == ')') &#123; String sss = ss.substring(0, j) + ss.substring(j + 1); if (!set.contains(sss)) &#123; set.add(sss); tempArray.add(sss); &#125; &#125; &#125; &#125; array = tempArray; &#125; // 对删除后字符串进行验证 for (int i = 0; i &lt; array.size(); i++) &#123; String str = array.get(i); if (this.checkVaild(str)) &#123; res.add(str); &#125; &#125; return res; &#125; private boolean checkVaild(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (c == '(' ) &#123; stack.push(c); &#125; else if (c == ')') &#123; if (stack.empty() || stack.peek() == ')') &#123; stack.push(c); &#125; else &#123; stack.pop(); &#125; &#125; &#125; if (stack.empty()) return true; return false; &#125;&#125; 312. 戳气球【跟上面一样，这两题没做呢！】 题目有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球 思路超详细回溯到dp 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public static int maxCoins(int[] nums) &#123; //避免空指针异常 if (nums == null) &#123; return 0; &#125; //创建虚拟边界 int length = nums.length; int[] nums2 = new int[length + 2]; System.arraycopy(nums, 0, nums2, 1, length); nums2[0] = 1; nums2[length + 1] = 1; length = nums2.length; //创建dp表 length = nums2.length; int[][] dp = new int[length][length]; //开始dp：i为begin，j为end，k为在i、j区间划分子问题时的边界 for (int i = length - 2; i &gt; -1; i--) &#123; for (int j = i + 2; j &lt; length; j++) &#123; //维护一个最大值；如果i、j相邻，值为0 int max = 0; for (int k = i + 1; k &lt; j; k++) &#123; int temp = dp[i][k] + dp[k][j] + nums2[i] * nums2[k] * nums2[j]; if (temp &gt; max) &#123; max = temp; &#125; &#125; dp[i][j] = max; &#125; &#125; return dp[0][length-1]; &#125;&#125; 338. 比特位计数题目给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1: 12输入: 2输出: [0,1,1] 示例 2: 12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数来执行此操作。 思路 从 191. 位1的个数 中启发而来，n &amp;（n-1）这种秀的一批的操作 对上述方法有一个改进版，动态规划版本的 代码 Case I 123456789101112131415161718class Solution &#123; public int[] countBits(int num) &#123; int[] res = new int[num+1]; for(int i = 0;i &lt;= num;i++)&#123; res[i] = hammingWeight(i); &#125; return res; &#125; public int hammingWeight(int n) &#123; int sum = 0; while(n != 0)&#123; sum++; n = n &amp; (n-1); &#125; return sum; &#125;&#125; Case II 123456789class Solution &#123; public int[] countBits(int num) &#123; int[] dp = new int[num+1]; for(int i = 1;i &lt;= num;i++)&#123; dp[i] = dp[i&amp;(i-1)] + 1; &#125; return dp; &#125;&#125; 347. 前 K 个高频元素题目给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 思路 借助 2020-02-02 周赛的一道题的思路，将其存入 map，然后用 list 存储 map，然后利用集合的排序方法，对其进行排序，再转成 map，然后用 iterator 遍历即可。 思路基本一致，但是其实这里排序之后根本用不到 value 了，所以根本没必要再转成 map，所以可以不用 list 去存储 entry 对象，直接用 PriorityQueue 去对 value 排序，然后存储 key 值就可以了，因为 PriorityQueue 是最小堆实现的，时间复杂度只有 O(nlogn) 这个方法不用排序，用 map 存储完之后，直接放到桶中（value值作为桶的序号），存入 key。 代码 Case I 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (map.get(nums[i]) != null) &#123; map.put(nums[i], map.get(nums[i]) + 1); &#125; else &#123; map.put(nums[i], 1); &#125; &#125; List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList(map.entrySet()); // 按 value 排序，降序排序 Collections.sort(list, (o1, o2) -&gt; &#123; int compare = (o1.getValue()).compareTo(o2.getValue()); return -compare; &#125;); Map&lt;Integer, Integer&gt; returnMap = new LinkedHashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : list) &#123; returnMap.put(entry.getKey(), entry.getValue()); &#125; int i = 0; List&lt;Integer&gt; res = new ArrayList(); for(Map.Entry&lt;Integer, Integer&gt; entry:returnMap.entrySet())&#123; if(i == k)&#123; break; &#125; else &#123; res.add(entry.getKey()); i++; &#125; &#125; return res; &#125;&#125; Case II 12345678910111213141516171819202122232425262728class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; // build hash map : character and how often it appears HashMap&lt;Integer, Integer&gt; count = new HashMap(); for (int n: nums) &#123; count.put(n, count.getOrDefault(n, 0) + 1); &#125; // init heap 'the less frequent element first' PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2)); // keep k top frequent elements in the heap for (int n: count.keySet()) &#123; heap.add(n); if (heap.size() &gt; k) // 是 堆 实现的，然后上述构造的是升序排列，最小的在第一个，最大的在最后 heap.poll(); &#125; // build output list List&lt;Integer&gt; top_k = new LinkedList(); while (!heap.isEmpty()) top_k.add(heap.poll()); Collections.reverse(top_k); return top_k; &#125;&#125; Case III 12345678910111213141516171819202122232425262728293031323334//基于桶排序求解「前 K 个高频元素」class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; List&lt;Integer&gt; res = new ArrayList(); // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值 HashMap&lt;Integer,Integer&gt; map = new HashMap(); for(int num : nums)&#123; if (map.containsKey(num)) &#123; map.put(num, map.get(num) + 1); &#125; else &#123; map.put(num, 1); &#125; &#125; //桶排序 //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标 List&lt;Integer&gt;[] list = new List[nums.length+1]; for(int key : map.keySet())&#123; // 获取出现的次数作为下标 int i = map.get(key); if(list[i] == null)&#123; list[i] = new ArrayList(); &#125; list[i].add(key); &#125; // 倒序遍历数组获取出现顺序从大到小的排列 for(int i = list.length - 1;i &gt;= 0 &amp;&amp; res.size() &lt; k;i--)&#123; if(list[i] == null) continue; res.addAll(list[i]); &#125; return res; &#125;&#125; 394. 字符串解码题目给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: 123s = "3[a]2[bc]", 返回 "aaabcbc".s = "3[a2[c]]", 返回 "accaccacc".s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef". 思路 栈 递归 代码 栈 12345678910111213141516171819202122232425262728293031public String decodeString(String s) &#123; StringBuilder res = new StringBuilder(); int multi = 0; // 存储数字 Stack&lt;Integer&gt; stack_multi = new Stack&lt;&gt;(); // 存储字符串，字符串分为两类，一类是在'[' 之前的，这个需要压栈，然后拼接的 // 一类是在']'之前的，这类是用来在括号内部乘以倍数的 Stack&lt;String&gt; stack_res = new Stack&lt;&gt;(); for(Character c : s.toCharArray()) &#123; if(c == '[') &#123; // 将倍数压栈 stack_multi.push(multi); // 将左括号之前的字符串压栈，方便后续拼接 stack_res.push(res.toString()); multi = 0; // 清空的原因是因为要便于下一次左括号之前的字母的保存 res = new StringBuilder(); &#125; else if(c == ']') &#123; // 用来 拼接字符串 StringBuilder tmp = new StringBuilder(); int cur_multi = stack_multi.pop(); for(int i = 0; i &lt; cur_multi; i++) tmp.append(res); res = new StringBuilder(stack_res.pop() + tmp); &#125; // 记得处理 multi 可能是多位数的情况！！！ else if(c &gt;= '0' &amp;&amp; c &lt;= '9') multi = multi * 10 + Integer.parseInt(c + ""); else res.append(c); &#125; return res.toString();&#125; 递归 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String decodeString(String s) &#123; return dfs(s, 0)[0]; &#125; /** * 递归三部曲 * 1、递归出口，当遍历完了最后一个字符，递归结束 * 2、递归返回值，返回括号内的字符串，并且为了方便在一轮递归中进行拼接，也将右括号的索引返回 * 3、一轮递归做的事情，就是将返回的字符串进行扩展，然后拼接前者和后者的字符串 * @param s * @param i * @return */ private String[] dfs(String s, int i) &#123; StringBuilder res = new StringBuilder(); int multi = 0; while (i &lt; s.length()) &#123; if (s.charAt(i) &gt;= '0' &amp;&amp; s.charAt(i) &lt;= '9') multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); else if (s.charAt(i) == '[') &#123; String[] tmp = dfs(s, i + 1); i = Integer.parseInt(tmp[0]); while (multi &gt; 0) &#123; res.append(tmp[1]); multi--; &#125; &#125; else if (s.charAt(i) == ']') return new String[]&#123;String.valueOf(i), res.toString()&#125;; else res.append(s.charAt(i)); i++; &#125; return new String[]&#123;res.toString()&#125;; &#125;&#125; 448. 找到所有数组中消失的数字题目给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 思路 https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/ti-jie-bu-shi-yong-e-wai-kong-jian-by-gehui1007/ 就是用正负号去维护一个简易的 map，标记是否出现该数。题目限制是数是在 1 ~ n 之间的，而一共有 n 个数，我们这么想，用数组元素的值代表 数组中出现的数的索引，比如说[4,3,2,7,8,2,3,1]，第一个数是 4，就代表了第 4个数，也就是 7，将其标志位 -1，以此类推，通过这种方式数组变为 [-4,-3,-2,-7,8,2,-3,-1]，故再遍历一遍，为正数的即未出现的数字。 用这种思路还可以解决 442. 数组中重复的数据 ，思路一模一样，当遍历时发现元素（代表数组下标）所指向的数是负数，说明那个数已经出现了一次，此时此数就出现了两次，记录下来即可。 代码1234567891011121314class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList(); for(int num:nums)&#123; num = Math.abs(num); if(nums[num-1] &lt; 0) continue; else nums[num-1] = -nums[num-1]; &#125; for(int i =0;i &lt; nums.length;i++)&#123; if(nums[i] &gt; 0) res.add(i+1); &#125; return res; &#125;&#125; 442题代码 123456789public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList(); for(int num:nums)&#123; num = Math.abs(num); if(nums[num-1] &lt; 0) res.add(num); else nums[num-1] = -nums[num-1]; &#125; return res;&#125; 399. 除法求值【图论知识，暂时不太会，从 leetcode英文版的 高分区 溜了几个高赞答案过来，以后欣赏一下】 题目给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。 示例 : 123给定 a / b = 2.0, b / c = 3.0问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 返回 [6.0, 0.5, -1.0, 1.0, -1.0 ] 123给定 a / b = 2.0, b / c = 3.0问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 返回 [6.0, 0.5, -1.0, 1.0, -1.0 ] 思路 dfs 并查集 代码 dfs 第一个版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; List&lt;String[]&gt; arr = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:equations)&#123; List&lt;String&gt; tmp; tmp = a; arr.add(tmp.toArray(new String[0])); &#125; String[][] eq = arr.toArray(new String[0][0]); List&lt;String[]&gt; arr1 = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:queries)&#123; List&lt;String&gt; tmp; tmp = a; arr1.add(tmp.toArray(new String[0])); &#125; String[][] q = arr1.toArray(new String[0][0]); return calcEquation_dfs(eq,values,q); &#125; public double[] calcEquation_dfs(String[][] eq, double[] vals, String[][] q) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; vals.length; i++) &#123; m.putIfAbsent(eq[i][0], new HashMap&lt;&gt;()); m.putIfAbsent(eq[i][1], new HashMap&lt;&gt;()); m.get(eq[i][0]).put(eq[i][1], vals[i]); m.get(eq[i][1]).put(eq[i][0], 1 / vals[i]); &#125; double[] r = new double[q.length]; for (int i = 0; i &lt; q.length; i++) r[i] = dfs(q[i][0], q[i][1], 1, m, new HashSet&lt;&gt;()); return r; &#125; double dfs(String s, String t, double r, Map&lt;String, Map&lt;String, Double&gt;&gt; m, Set&lt;String&gt; seen) &#123; if (!m.containsKey(s) || !seen.add(s)) return -1; if (s.equals(t)) return r; Map&lt;String, Double&gt; next = m.get(s); for (String c : next.keySet()) &#123; double result = dfs(c, t, r * next.get(c), m, seen); if (result != -1) return result; &#125; return -1; &#125;&#125; dfs 第二个版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; List&lt;String[]&gt; arr = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:equations)&#123; List&lt;String&gt; tmp; tmp = a; arr.add(tmp.toArray(new String[0])); &#125; String[][] eq = arr.toArray(new String[0][0]); List&lt;String[]&gt; arr1 = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:queries)&#123; List&lt;String&gt; tmp; tmp = a; arr1.add(tmp.toArray(new String[0])); &#125; String[][] q = arr1.toArray(new String[0][0]); return calcEquation_dfs(eq,values,q); &#125; HashSet&lt;String&gt; seen = new HashSet&lt;&gt;(); HashMap&lt;String, String&gt; root = new HashMap&lt;&gt;(); HashMap&lt;String, Double&gt; vals = new HashMap&lt;&gt;(); HashMap&lt;String, HashMap&lt;String, Double&gt;&gt; edges = new HashMap&lt;&gt;(); public double[] calcEquation_dfs(String[][] equations, double[] values, String[][] queries) &#123; int n = equations.length, m = queries.length; for (int i = 0; i &lt; n; ++i) &#123; String x = equations[i][0], y = equations[i][1]; if (!edges.containsKey(x)) edges.put(x, new HashMap&lt;String, Double&gt;()); if (!edges.containsKey(y) ) edges.put(y, new HashMap&lt;String, Double&gt;()); edges.get(x).put(y, values[i]); edges.get(y).put(x, 1 / values[i]); &#125; for (String x : edges.keySet()) &#123; if (!seen.contains(x)) dfs(x, x, 1); &#125; double[] res = new double[m]; for (int i = 0; i &lt; m; ++i) &#123; String x = queries[i][0], y = queries[i][1]; String px = root.getOrDefault(x, x), py = root.getOrDefault(y, y); if (px != py) res[i] = -1.0; else res[i] = vals.get(x) / vals.get(y); &#125; return res; &#125; public void dfs(String x, String p, double v) &#123; vals.put(x, v); root.put(x, p); seen.add(x); for (String y : edges.get(x).keySet()) &#123; if (!seen.contains(y)) dfs(y, p, v * edges.get(y).get(x)); &#125; &#125;&#125; Dfs 第三个版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; List&lt;String[]&gt; arr = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:equations)&#123; List&lt;String&gt; tmp; tmp = a; arr.add(tmp.toArray(new String[0])); &#125; String[][] eq = arr.toArray(new String[0][0]); List&lt;String[]&gt; arr1 = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:queries)&#123; List&lt;String&gt; tmp; tmp = a; arr1.add(tmp.toArray(new String[0])); &#125; String[][] q = arr1.toArray(new String[0][0]); return calcEquation_dfs(eq,values,q); &#125; public double[] calcEquation_dfs(String[][] equations, double[] values, String[][] queries) &#123; /* Build graph. */ Map&lt;String, Map&lt;String, Double&gt;&gt; graph = buildGraph(equations, values); double[] result = new double[queries.length]; for (int i = 0; i &lt; queries.length; i++) &#123; result[i] = getPathWeight(queries[i][0], queries[i][1], new HashSet&lt;&gt;(), graph); &#125; return result; &#125; private double getPathWeight(String start, String end, Set&lt;String&gt; visited, Map&lt;String, Map&lt;String, Double&gt;&gt; graph) &#123; /* Rejection case. */ if (!graph.containsKey(start)) return -1.0; /* Accepting case. */ if (graph.get(start).containsKey(end)) return graph.get(start).get(end); visited.add(start); for (Map.Entry&lt;String, Double&gt; neighbour : graph.get(start).entrySet()) &#123; if (!visited.contains(neighbour.getKey())) &#123; double productWeight = getPathWeight(neighbour.getKey(), end, visited, graph); if (productWeight != -1.0) return neighbour.getValue() * productWeight; &#125; &#125; return -1.0; &#125; private Map&lt;String, Map&lt;String, Double&gt;&gt; buildGraph(String[][] equations, double[] values) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;(); String u, v; for (int i = 0; i &lt; equations.length; i++) &#123; u = equations[i][0]; v = equations[i][1]; graph.putIfAbsent(u, new HashMap&lt;&gt;()); graph.get(u).put(v, values[i]); graph.putIfAbsent(v, new HashMap&lt;&gt;()); graph.get(v).put(u, 1 / values[i]); &#125; return graph; &#125;&#125; 并查集 I 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; List&lt;String[]&gt; arr = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:equations)&#123; List&lt;String&gt; tmp; tmp = a; arr.add(tmp.toArray(new String[0])); &#125; String[][] eq = arr.toArray(new String[0][0]); List&lt;String[]&gt; arr1 = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:queries)&#123; List&lt;String&gt; tmp; tmp = a; arr1.add(tmp.toArray(new String[0])); &#125; String[][] q = arr1.toArray(new String[0][0]); return calcEquation_union(eq,values,q); &#125; /** 1. Thoughts - check if we have enough info to get the result - if yes, calculate; if not, return -1.0 - Method: union find - a/b = 2.0 --&gt; b is the root of a; the distance from a to b is 1/2.0 - if two nums have the same root, we can get the result; a/b=2.0, b/c=3.0 index a b c root b c c dist 2 3 1 - if we want to know a/c = ?: a = 2 * b = 2 * 3 * c =&gt; a/c = 6.0 2. Corner case - if any input is null, return null - no enough info, return -1.0 3. Steps - go through equations to union elements with the same root and update root map and distance map - go through each query: check if has the same root; find relative dist*/ public double[] calcEquation_union(String[][] e, double[] values, String[][] q) &#123; double[] res = new double[q.length]; Map&lt;String, String&gt; root = new HashMap&lt;&gt;(); Map&lt;String, Double&gt; dist = new HashMap&lt;&gt;(); for (int i = 0; i &lt; e.length; i++) &#123; String r1 = find(root, dist, e[i][0]); String r2 = find(root, dist, e[i][1]); root.put(r1, r2); dist.put(r1, dist.get(e[i][1]) * values[i] / dist.get(e[i][0])); &#125; for (int i = 0; i &lt; q.length; i++) &#123; if (!root.containsKey(q[i][0]) || !root.containsKey(q[i][1])) &#123; res[i] = -1.0; continue; &#125; String r1 = find(root, dist, q[i][0]); String r2 = find(root, dist, q[i][1]); if (!r1.equals(r2)) &#123; res[i] = -1.0; continue; &#125; res[i] = (double) dist.get(q[i][0]) / dist.get(q[i][1]); &#125; return res; &#125; private String find(Map&lt;String, String&gt; root, Map&lt;String, Double&gt; dist, String s) &#123; if (!root.containsKey(s)) &#123; root.put(s, s); dist.put(s, 1.0); return s; &#125; if (root.get(s).equals(s)) return s; String lastP = root.get(s); String p = find(root, dist, lastP); root.put(s, p); dist.put(s, dist.get(s) * dist.get(lastP)); return p; &#125;&#125; 并查集 ——&gt; 大佬的并查集和DFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123; List&lt;String[]&gt; arr = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:equations)&#123; List&lt;String&gt; tmp; tmp = a; arr.add(tmp.toArray(new String[0])); &#125; String[][] eq = arr.toArray(new String[0][0]); List&lt;String[]&gt; arr1 = new ArrayList&lt;&gt;(); for(List&lt;String&gt; a:queries)&#123; List&lt;String&gt; tmp; tmp = a; arr1.add(tmp.toArray(new String[0])); &#125; String[][] q = arr1.toArray(new String[0][0]); return calcEquation_union(eq,values,q); &#125; Map&lt;String, String&gt;parents = new HashMap&lt;&gt;(); Map&lt;String, Double&gt;vals = new HashMap&lt;&gt;(); public double[] calcEquation_union(String[][] equs, double[] values, String[][] queries) &#123; double[] res = new double[queries.length]; for (int i = 0; i &lt; values.length ; ++i ) union(equs[i][0], equs[i][1], values[i]); for (int i = 0; i &lt; queries.length; ++i) &#123; String x = queries[i][0], y = queries[i][1]; res[i] = (parents.containsKey(x) &amp;&amp; parents.containsKey(y) &amp;&amp; find(x) == find(y)) ? vals.get(x) / vals.get(y) : -1.0; &#125; return res; &#125; public void add(String x) &#123; if (parents.containsKey(x)) return; parents.put(x, x); vals.put(x, 1.0); &#125; public String find(String x) &#123; String p = parents.getOrDefault(x, x); if (x != p) &#123; String pp = find(p); vals.put(x, vals.get(x) * vals.get(p)); parents.put(x, pp); &#125; return parents.getOrDefault(x, x); &#125; public void union(String x, String y, double v) &#123; add(x); add(y); String px = find(x), py = find(y); parents.put(px, py); vals.put(px, v * vals.get(y) / vals.get(x)); &#125;&#125; 406. 根据身高重建队列题目假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 示例 12345输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 思路官方题解讲的不错，高个子的眼中，矮个子相当于不存在，所以高个子先按规矩站好，后面矮个子的插入不会影响其顺序，所以我们先把高个子安排完，矮个子可以直接按 k 值从小到大插入，k 值即他们当时插入的下标值。 代码12345678910111213class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; // 前面身高应该降序，后面的k应该升序排列 Arrays.sort(people, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]); ArrayList&lt;int[]&gt; res = new ArrayList(); for(int[] p:people)&#123; // 高个子无视矮个子，所以矮个子的插入对之前插入的高个子没有影响 // 故矮个子可以直接按 k 当成序号插入 res.add(p[1],p); &#125; return res.toArray(new int[0][0]); &#125;&#125; 416. 分割等和子集题目给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1: 12345输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2: 12345输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 思路见 liwei大佬思路，这个优化的套路，值得学习。 https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/ 代码1234567891011121314151617181920212223242526272829public class Solution &#123; public boolean canPartition(int[] nums) &#123; int len = nums.length; int sum = 0; for (int num : nums) &#123; sum += num; &#125; if ((sum &amp; 1) == 1) &#123; return false; &#125; int target = sum / 2; boolean[] dp = new boolean[target + 1]; dp[0] = true; if (nums[0] &lt;= target) &#123; dp[nums[0]] = true; &#125; for (int i = 1; i &lt; len; i++) &#123; for (int j = target; nums[i] &lt;= j; j--) &#123; if (dp[target]) &#123; return true; &#125; dp[j] = dp[j] || dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 438. 找到字符串中所有字母异位词题目给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100 示例 1: 123456789输入:s: "cbaebabacd" p: "abc"输出:[0, 6]解释:起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。 示例 2: 12345678910输入:s: "abab" p: "ab"输出:[0, 1, 2]解释:起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。 思路滑动窗口算法，见 另外一篇文章：滑动窗口技巧总结（假装有链接） 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; // 用于返回字母异位词的起始索引 List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 用 map 存储目标值中各个单词出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (Character c : p.toCharArray()) map.put(c, map.getOrDefault(c, 0)+1); // 用另外一个 map 存储滑动窗口中有效字符出现的次数 HashMap&lt;Character, Integer&gt; window = new HashMap&lt;&gt;(); int left = 0; // 左指针 int right = 0; // 右指针 int valid = p.length(); // 只有当 valid == 0 时，才说明 window 中包含了目标子串 while (right &lt; s.length()) &#123; // 如果目标子串中包含了该字符，才存入 window 中 if (map.containsKey(s.charAt(right))) &#123; window.put(s.charAt(right), window.getOrDefault(s.charAt(right), 0)+1); // 只有当 window 中该有效字符数量不大于map中该字符数量，才能算一次有效包含 if (window.get(s.charAt(right)) &lt;= map.get(s.charAt(right))) &#123; valid--; &#125; &#125; // 如果 window 符合要求，即两个 map 存储的有效字符相同，就可以移动左指针了 // 但是只有二个map存储的数据完全相同，才可以记录当前的起始索引，也就是left指针所在位置 while (valid == 0) &#123; if (right - left + 1 == p.length()) res.add(left); // 如果左指针指的是有效字符,需要更改 window 中的 key 对应的 value // 如果 有效字符对应的数量比目标子串少，说明无法匹配了 if (map.containsKey(s.charAt(left))) &#123; window.put(s.charAt(left), window.get(s.charAt(left))-1); if (window.get(s.charAt(left)) &lt; map.get(s.charAt(left))) &#123; valid++; &#125; &#125; left++; &#125; right++; &#125; return res; &#125;&#125; 用数组代替 map 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; if(s == null || s.length() == 0) return new ArrayList&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int[] needs = new int[26]; //由于都是小写字母，因此直接用26个长度的数组代替原来的HashMap int[] window = new int[26]; int left = 0, right = 0, total = p.length(); //用total检测窗口中是否已经涵盖了p中的字符 for(char ch : p.toCharArray())&#123; needs[ch - 'a'] ++; &#125; while(right &lt; s.length())&#123; char chr = s.charAt(right); if(needs[chr - 'a'] &gt; 0)&#123; window[chr - 'a'] ++; if(window[chr - 'a'] &lt;= needs[chr - 'a'])&#123; total --; &#125; &#125; while(total == 0)&#123; if(right-left+1 == p.length())&#123; res.add(left); &#125; char chl = s.charAt(left); if(needs[chl - 'a'] &gt; 0)&#123; window[chl - 'a'] --; if(window[chl - 'a'] &lt; needs[chl - 'a'])&#123; total ++; &#125; &#125; left ++; &#125; right ++; &#125; return res; &#125;&#125; 494. 目标和题目给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例 1: 1234567891011输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组非空，且长度不会超过20。 初始的数组的和不会超过1000。 保证返回的最终结果能被32位整数存下。 思路 暴力法 ，见官方题解 https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode/ Dp，我做的时候第一反应是用的 dp，但是这里有个困难，dp不能用二维数组表示，因为可能越界，下标为负数，所以可以用 hashmap，dp[i][j] 转化为 i 当 key，j 当 value。 转化为 0-1 背包问题。 https://leetcode-cn.com/problems/target-sum/solution/python-dfs-xiang-jie-by-jimmy00745/ https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-ji-bai-liao-98de-javayong-hu-by-r/ 代码123456789101112131415161718public class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; int[] dp = new int[2001]; dp[nums[0] + 1000] = 1; dp[-nums[0] + 1000] += 1; for (int i = 1; i &lt; nums.length; i++) &#123; int[] next = new int[2001]; for (int sum = -1000; sum &lt;= 1000; sum++) &#123; if (dp[sum + 1000] &gt; 0) &#123; next[sum + nums[i] + 1000] += dp[sum + 1000]; next[sum - nums[i] + 1000] += dp[sum + 1000]; &#125; &#125; dp = next; &#125; return S &gt; 1000 ? 0 : dp[S + 1000]; &#125;&#125;]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>算法</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想学的东西]]></title>
    <url>%2F2019%2F12%2F20%2F%E6%83%B3%E5%AD%A6%E7%9A%84%E4%B8%9C%E8%A5%BF.html</url>
    <content type="text"><![CDATA[dp 二叉树问题练习 链表问题集中练习 微服务 设计模式 java基础 面经spring常问的问题 并发、JVM]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud 微服务笔记]]></title>
    <url>%2F2019%2F12%2F13%2FSpringCloud%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[微服务架构概述单体架构一个归档包(war格式)包含所有功能的应用程序，通常称为单体应用。 存在的问题： 复杂性高 技术债务(不坏不修) 部署频率低 可靠性差 扩展能力受限，不同模块可能需要的配置不一样，有的需要CPU好一点的，有的需要存储大一点的，不能根据业务模块的需要进行伸缩 阻碍技术创新，单体应用往往使用统一的技术平台或者方案解决所有的问题 微服务微服务架构风格：将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制，可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，不同服务可以采用不同的语言开发，可以使用不同的数据存储技术。 特性 每个微服务可以独立运行在自己的进程中 每个服务为独立的业务开发 微服务通过类似于RESTful API等一些轻量级的通信机制进行通信 全自动的部署机制 优点 易于开发和维护 启动速度快 局部修改易部署 技术栈并不受限 按需伸缩 缺点 运维要求高，因为会有几十甚至上百个服务协作运行 分布式固有的复杂性 接口调整成本高 重复劳动 微服务设计原则 单一职责原则(SOLID原则之一) 服务自治原则。即每个微服务应具备独立的业务能力、依赖与运行环境。 轻量级通信机制。常用的有REST、AMQP、STOMP、MQTT等。 微服务粒度。这个比较难以控制，一般通过领域驱动设计(Domain Driven Design，DDD)中的限定上下文可作为划分微服务边界、确定微服务粒度。 微服务架构技术选型主流的解决方案是 SpringCloud、Dubbo 具体的框架对比：Dubbo VS SpringCloud 微服务开发框架——Spring CloudSpring Cloud 简介 并不是云计算解决方案，是在Spring Boot基础上用于快速构建分布式系统的通用模式的工具集 使用Spring Cloud开发的程序非常适合在Docker或者PaaS上部署,所以又叫云原生应用，云原生可理解为面向云环境的软件架构 云原生架构的方法论和最佳实践：12-factor Apps Tips： 云服务分为三类，分别是 IaaS(基础设施服务)、PaaS(平台服务)、SaaS(软件服务) 传送门：IaaS，PaaS，SaaS 的区别 Spring Cloud 和 Spring Boot 的联系首先，知乎上对这个有比较好的回答：Spring Cloud &amp; Spring Boot 总结一下说的比较好的： spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。 spring boot 的优点是可以快速启动，快速构建应用程序，而不需要太多的配置文件。 spring cloud 是分布式开发的解决方案，基于spring boot,在spring boot做较少的配置，便可成为 spring cloud 中的一个微服务。 最基础的都是spring，然后在这个基础上spring boot做了一些自动配置和实现，然后又在spring boot的基础上加入了分布式负载均衡等功能，这才有了spring cloud。 Spring cloud是微服务开发套件。springboot=spring+springmvc，springcloud=springboot+ribbon+注册中心+熔断器+…等一系列组件。 Spring Cloud 特点 约定优于配置 隐藏了组件复杂性，并且提供声明式的配置方式 轻量级的组件，如Eureka、Zuul等 解耦，灵活 Spring Cloud 版本以SRX形式命名版本号，版本号前面会有一个 release train。 从以往的版本有Dalston、Edgware、Finchley、Greenwich，正在孵化的有SpringCloud Alibaba。 Spring Cloud 实战微服务(Finchley版本)概述Spring Cloud支持的插件众多，先来看一下Spring Cloud中文网提供的比较优秀的插件： Spring Cloud集成的相关优质项目推荐 Eureka：注册中心，云端服务发现，实现云端中间层服务发现和故障转移 Ribbon：负载均衡，可以有多种负载均衡的策略供选择，可配合Eureka和Hystrix使用 Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力 Turbine：Turbine是聚合服务器发送事件流数据的一个工具，用来监控集群下hystrix的metrics情况（可视化） Feign：声明式、模块化的HTTP客户端，集成了负载均衡 Zuul：云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门 Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署 Sleuth：日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案 Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息 Security：基于spring security的安全工具包，为你的应用程序添加安全控制 实例使用服务提供者与服务消费者来描述微服务之间的调用关系。下表解释了服务提供者与服务消费者。 ​ 表-服务提供者与服务消费者 名词 定义 服务提供者 服务的被调用方（即：为其他服务提供服务的服务） 服务消费者 服务的调用方（即：依赖其他服务的服务） 以电影售票系统为例。如图，用户向电影微服务发起了一个购票的请求。在进行购票的业务操作前，电影微服务需要调用用户微服务的接口，查询当前用户的余额是多少、是不是符合购票标准等。在这种场景下，用户微服务就是一个服务提供者，电影微服务则是一个服务消费者。 围绕该场景，先来编写一个用户微服务，然后编写一个电影微服务。 Eureka注册中心，云端服务发现，实现云端中间层服务发现和故障转移 不妨先思考一下，怎样才能让服务消费者总能找到服务提供者呢？或者说，怎样才能让服务消费者感知到服务提供者地址的变化呢？ TIPS 目前市面上把服务消费者找到服务提供者的这种机制称为服务发现，又或者服务注册。下面来探索服务发现究竟是怎么回事。 服务发现原理初探其实，服务发现机制非常简单，不妨用大家熟悉的MySQL来类比——只需一张表（图中的registry表）即可实现服务发现！ 如图，如果我们能在： 应用启动时，自动往registry表中插入一条数据，数据包括服务名称、IP、端口等信息。 应用停止时，自动把自己在registry表中的数据的status设为DOWN 。 这样，服务消费者不就永远都能找到服务提供者了嘛！当服务消费者想调用服务提供者接口时，只需向数据库发送SQL语句 SELECT * FROM registry where service_name = &#39;user&#39; and status = &#39;UP&#39; 即可找到服务提供者的所有实例！IP、端口啥的都有了，自己拼接一下，再去调用就行了！ TIPS 看，服务发现机制是不是很简单？程序猿给图中的”MySQL“的组件起了一个牛叉的名字叫：”注册中心“，也有的书将其称为”服务发现组件“。 但，这毕竟只是一个最简陋的服务发现原理。完整的服务发现要考虑的问题有很多，例如： 当服务抑或所在主机突然崩溃或者进入某种不正常的情况无法提供服务（例如应用的数据库挂了）时，对应的数据理应标记DOWN，或者索性删除； 如果每次调用之前，都得向服务发现组件发送类似SELECT * FROM registry where service_name = &#39;user&#39; and status = &#39;UP&#39; 的语句，那么服务发现组件的压力得有多大？更重要的，这与当下流行的去中心化设计的思想相悖； 服务发现组件即使挂掉，也不应该影响微服务之间的调用。 那么，一个完善的服务发现组件应该具备哪些能力呢？ 服务发现原理深入不妨来看一下使用服务发现组件后的架构图，如图所示。 服务提供者、服务消费者、服务发现组件这三者之间的关系大致如下： 各个微服务在启动时，将自己的网络地址等信息注册到服务发现组件中，服务发现组件会存储这些信息； 服务消费者可从服务发现组件查询服务提供者的网络地址，并使用该地址调用服务提供者的接口； 各个微服务与服务发现组件使用一定机制（例如心跳）通信。服务发现组件如长时间无法与某微服务实例通信，就会自动注销（即：删除）该实例； 当微服务网络地址发生变更（例如实例增减或者IP端口发生变化等）时，会重新注册到服务发现组件； 客户端缓存：各个微服务将需要调用服务的地址缓存在本地，并使用一定机制更新（例如定时任务更新、事件推送更新等）。这样既能降低服务发现组件的压力，同时，即使服务发现组件出问题，也不会影响到服务之间的调用。 综上，服务发现组件应具备以下功能。 服务注册表：服务注册表是服务发现组件的核心（其实就是类似于上面的registry表），它用来记录各个微服务的信息，例如微服务的名称、IP、端口等。服务注册表提供查询API和管理API，查询API用于查询可用的微服务实例，管理API用于服务的注册和注销； 服务注册与服务发现：服务注册是指微服务在启动时，将自己的信息注册到服务发现组件上的过程。服务发现是指查询可用微服务列表及其网络地址的机制； 服务检查：服务发现组件使用一定机制定时检测已注册的服务，如发现某实例长时间无法访问，就会从服务注册表中移除该实例。 用途将微服务的提供者和消费者都注册到Eureka服务器上，由Eureka服务器进行管理 源码分析Eureka原理分析 集成方式编写Eureka Server 加依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 加注解 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 写配置 12345678910server: port: 8761eureka: client: # 是否要注册到其他Eureka Server实例 register-with-eureka: false # 是否要从其他Eureka Server实例获取数据 fetch-registry: false service-url: defaultZone: http://localhost:8761/eureka/ TIPS 这里，大家可先不去探究registerWithEureka 以及fetchRegistry 究竟是什么鬼，笔者将在下一节为大家揭晓。 将应用注册到Eureka Server上 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 加注解 123456@SpringBootApplicationpublic class ProviderUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderUserApplication.class, args); &#125;&#125; 注意：早期的版本（Dalston及更早版本）还需在启动类上添加注解@EnableDiscoveryClient 或@EnableEurekaClient ，从Edgware开始，该注解可省略。 添加配置： 123456789101112spring: application: # 指定注册到eureka server上的服务名称，对于电影微服务，本系列将名称设为microservice-consumer-movie name: microservice-provider-usereureka: client: service-url: # 指定eureka server通信地址，注意/eureka/小尾巴不能少 defaultZone: http://localhost:8761/eureka/ instance: # 是否注册IP到eureka server，如不指定或设为false，那就会注册主机名到eureka server prefer-ip-address: true 测试 依次启动Eureka Server以及用户微服务、电影微服务； 访问http://localhost:8761 可观察到类似如下界面： 将用户微服务停止，可看到Eureka Server首页变成类似如下界面： Ribbon用途一般来说，提到负载均衡，大家一般很容易想到浏览器 -&gt; NGINX -&gt; 反向代理多个Tomcat这样的架构图——业界管这种负载均衡模式叫“服务器端负载均衡”，因为此种模式下，负载均衡算法是NGINX提供的，而NGINX部署在服务器端。 Nginx扫盲 本节所讲的Ribbon则是一个客户端侧负载均衡组件——通俗地说，就是集成在客户端（服务消费者一侧），并提供负载均衡算法的一个组件。 Ribbon默认为我们提供了很多的负载均衡算法，例如轮询、随机、响应时间加权等——当然，为Ribbon自定义负载均衡算法也非常容易，只需实现IRule 接口即可。 内置负载均衡的规则负载均衡规则是Ribbon的核心，下面来看一下Ribbon内置的负载均衡规则。 AvailabilityFilteringRule：过滤掉一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态； BestAvailableRule：选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。 RandomRule：随机选择一个Server； ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用一样； RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server； RoundRobinRule：轮询选择， 轮询index，选择index对应位置的Server； WeightedResponseTimeRule：根据响应时间加权，响应时间越长，权重越小，被选中的可能性越低； ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择Server； 如需自定义负载均衡规则，只需实现IRule 接口或继承AbstractLoadBalancerRule 、PredicateBasedRule即可 ，可参考RandomRule 、RoundRobinRule 、ZoneAvoidanceRule 等内置Rule编写自己的负载均衡规则。 引入Ribbon在Spring Cloud中，当Ribbon与Eureka配合使用时，Ribbon可自动从Eureka Server获取服务提供者地址列表，并基于负载均衡算法，选择其中一个服务提供者实例。下图展示了Ribbon与Eureka配合使用时的大致架构。 集成方式代码示例 复制项目microservice-consumer-movie ，将ArtifactId修改为microservice-consumer-movie-ribbon 。 加依赖：由于spring-cloud-starter-netflix-eureka-client 已经包含spring-cloud-starter-netfilx-ribbon ，故而无需额外添加依赖。 写代码： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 如代码所示，只需在RestTemplate 上添加LoadBalanced 注解，即可让RestTemplate整合Ribbon！ 调用： 1234567891011@GetMapping("/users/&#123;id&#125;")public User findById(@PathVariable Long id) &#123; // 这里用到了RestTemplate的占位符能力 User user = this.restTemplate.getForObject( "http://microservice-provider-user/users/&#123;id&#125;", User.class, id ); // ...电影微服务的业务... return user;&#125; 由代码可知，我们将请求的目标服务改成了http://microservice-provider-user/users/{id} ，也就是http://{目标服务名称}/{目标服务端点} 的形式，Ribbon会自动在实际调用时，将目标服务名替换为该服务的IP和端口。 测试 依次启动microservice-discovery-eureka 、microservice-provider-user 两个实例、microservice-consumer-movie-ribbon 访问http://localhost:8010/movies/users/1 多次，会发现两个user服务实例都会打印日志。 Feign简介Feign是Netflix开发的声明式、模板化的HTTP客户端，集成了 RestTemplate + Eureka + Ribbon + Hystrix 集成方式下面来将前面的例子用Feign改写，让其达到与Ribbon + RestTemplate相同的效果。 复制项目microservice-consumer-movie，将ArtifactId修改为microservice-consumer-movie-feign ； 加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：启动类上添加@EnableFeignClients ； 编写Feign Client： 12345@FeignClient(name = "microservice-provider-user")public interface UserFeignClient &#123; @GetMapping("/users/&#123;id&#125;") User findById(@PathVariable("id") Long id);&#125; 这样一个Feign Client就写完啦！其中，@FeignClient 注解中的microservice-provider-user是想要请求服务的名称，这是用来创建Ribbon Client的（Feign整合了Ribbon）。在本例中，由于使用了Eureka，所以Ribbon会把microservice-provider-user 解析成Eureka Server中的服务。 除此之外，还可使用url属性指定请求的URL（URL可以是完整的URL或主机名），例如@FeignClient(name = &quot;abcde&quot;, url = &quot;http://localhost:8000/&quot;) 。此时，name可以是任意值，但不可省略，否则应用将无法启动！ Controller： 1234567891011@RequestMapping("/movies")@RestControllerpublic class MovieController &#123; @Autowired private UserFeignClient userFeignClient; @GetMapping("/users/&#123;id&#125;") public User findById(@PathVariable Long id) &#123; return this.userFeignClient.findById(id); &#125;&#125; 只需使用@Autowire注解，即可注入上面编写的Feign Client。 RestTemplate与Feign对比相信通过本文的例子，聪明的你对如何使用Feign已经了然于心了。文章的最后，对比一下RestTemplate + Ribbon与Feign。 角度 RestTemplate + Ribbon Feign（自带Ribbon） 可读性、可维护性 欠佳（无法从URL直观了解这个远程调用是干什么的） 极佳（能在接口上写注释，方法名称也是可读的，能一眼看出这个远程调用是干什么的） 开发体验 欠佳（需要拼凑URL） 极佳（无需拼凑url，自动集合Eureka和Ribbon） 风格一致性 欠佳（本地API调用和RestTemplate调用的代码风格截然不同） 极佳（完全一致，不点开Feign的接口，根本不会察觉这是一个远程调用而非本地API调用） 性能 较好 中等（性能是RestTemplate的50%左右；如果为Feign配置连接池，性能可提升15%左右） 灵活性 极佳 中等（内置功能能满足大多数项目的需求） Hystrix容错技术的引入至此，我们已实现服务发现、负载均衡，同时，使用Feign也实现了良好的远程调用——我们的代码是可读、可维护的。理论上，我们现在已经能构建一个不错的分布式应用了，但微服务之间是通过网络通信的，网络可能出问题；微服务本身也不可能100%可用。 如何提升应用的可用性呢？这是我们必须考虑的问题—— 举个例子：某大型系统中，服务A调用服务B，某个时刻，微服务B突然崩溃了。微服务A中，依然有大量请求在请求B，如果没有任何措施，微服务A很可能很快就会被拖死——因为在Java中，一次请求往往对应着一个线程，如果不做任何措施，那意味着微服务A请求B的线程要等Feign Client/RestTemplate超时才会释放（这个时间一般非常长，长达几十秒），于是就会有大量的线程被阻塞，而线程又对应着计算资源（CPU/内存），于是乎，大量的资源被浪费，并且越积越多，最终服务器终于没有资源给微服务A浪费了，微服务A也挂了。 因此，在大型应用中，微服务之间的容错必不可少，下面来讨论如何实现微服务的容错。 容错三板斧 超时机制：一旦超时，就释放资源。由于释放资源速度较快，应用就不会那么容易被拖死。 舱壁模式：不把鸡蛋放在一个篮子里。你有你的线程池，我有我的线程池，你的线程池满了和我没关系，你挂了也和我没关系。 断路器：实时监测应用，如果发现在一定时间内失败次数/失败率达到一定阈值，就“跳闸”，断路器打开——此时，请求直接返回，而不去调用原本调用的逻辑。 跳闸一段时间后（例如15秒），断路器会进入半开状态，这是一个瞬间态，此时允许一次请求调用该调的逻辑，如果成功，则断路器关闭，应用正常调用；如果调用依然不成功，断路器继续回到打开状态，过段时间再进入半开状态尝试——通过”跳闸“，应用可以保护自己，而且避免浪费资源；而通过半开的设计，可实现应用的“自我修复“。 断路器状态转换 引入HystrixHystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。Hystrix主要通过以下几点实现延迟和容错。 包裹请求 使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用到了设计模式中的“ 命令模式 ”。 跳闸机制（断路器的应用） 当某服务的错误率超过一定阈值时，Hystrix可以自动或者手动跳闸，停止请求该服务一段时间。 资源隔离（舱壁模式的应用） Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判定。 监控（超时模式的应用） Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。 回退机制 当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑可由开发人员自行提供，例如返回一个缺省值。 自我修复 断路器打开一段时间后，会自动进入“半开”状态。断路器打开、关闭、半开的逻辑转换，前面我们已经详细探讨过了，不再赘述。 通用方式使用Hystrix服务降级 加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：在启动类上添加@EnableCircuitBreaker 注解。 使用： 12345678910111213141516@HystrixCommand(fallbackMethod = "findByIdFallback")@GetMapping("/users/&#123;id&#125;")public User findById(@PathVariable Long id) &#123; // 这里用到了RestTemplate的占位符能力 User user = this.restTemplate.getForObject( "http://microservice-provider-user/users/&#123;id&#125;", User.class, id ); // ...电影微服务的业务... return user;&#125;public User findByIdFallback(Long id) &#123; return new User(id, "默认用户", "默认用户", 0, new BigDecimal(1));&#125; 由代码可知，只需使用@HystrixCommand 注解，就可保护该API。这里的”保护“，其实带有三层含义——”超时机制“、”仓壁模式“、”断路器“！ TIPS 本例使用了fallbackMethod 属性，指定了一个降级方法，如不指定，Hystrix会有一个默认的降级方案，那就是抛异常，哈哈哈。 如何知道断路器打开还是关闭呢？只需访问应用的/actuator/health 端点，即可查看！断路器的状态——当然，你必须添加如下配置： 1234management: endpoint: health: show-details: always 测试 启动microservice-discovery-eureka 启动microservice-provider-user 启动microservice-consumer-movie-ribbon-hystrix-common 访问http://localhost:8010/movies/users/1 ，能正常返回结果 关闭microservice-provider-user ，再次访问http://localhost:8010/movies/users/1 ，可返回类似如下结果，说明当服务提供者时，服务消费者进入了回退方法。 1&#123;"id":1,"username":"默认用户","name":"默认用户","age":0,"balance":1&#125; 访问http://localhost:8010/actuator/health ，可获得类似如下结果： 1234567891011&#123; "status": "UP", "details": &#123; "diskSpace": ..., "refreshScope": ..., "discoveryComposite": ..., "hystrix": &#123; "status": "UP" &#125; &#125;&#125; 由结果不难发现，此时断路器并未打开！这是为什么呢？ 原因是：此时只请求了一次，没有达到Hystrix的阈值——Hystrix设计来保护高并发应用的，它要求10秒（可用hystrix.command.default.metrics.rollingStats.timeInMilliseconds 自定义）以内API错误次数超过20次（用circuitBreaker.requestVolumeThreshold 自定义），此时才可能触发断路器。 持续不断地访问http://localhost:8010/movies/users/1 多次（至少20次） 再次访问http://localhost:8010/actuator/health ，可获得类似如下结果： 1234567891011121314&#123; "status": "UP", "details": &#123; "diskSpace": ..., "refreshScope": ..., "discoveryComposite": ..., "hystrix": &#123; "status": "CIRCUIT_OPEN", "details": &#123; "openCircuitBreakers": ["MovieController::findById"] &#125; &#125; &#125;&#125; 由结果可知，此时断路器已经打开，并且列出了是哪个API的断路器被打开了。 获得造成fallback的原因在实际项目中，很可能需要获得造成fallback的原因，此时可将代码修改为如下： 1234567891011121314151617@HystrixCommand(fallbackMethod = "findByIdFallback")@GetMapping("/users/&#123;id&#125;")public User findById(@PathVariable Long id) &#123; // 这里用到了RestTemplate的占位符能力 User user = this.restTemplate.getForObject( "http://microservice-provider-user/users/&#123;id&#125;", User.class, id ); // ...电影微服务的业务... return user;&#125;public User findByIdFallback(Long id, Throwable throwable) &#123; log.error("进入回退方法", throwable); return new User(id, "默认用户", "默认用户", 0, new BigDecimal(1));&#125; Feign 整合 Hystrix默认Feign是不启用Hystrix的，如果需要启用，只需要在配置文件中配置即可： 123feign: hystrix: enabled: true Hystrix Command 详解监控端点与数据应用整合Hystrix，同时应用包含spring-boot-starter-actuator 依赖，就会存在一个/actuator/hystrix.stream 端点，用来监控Hystrix Command。当被@HystrixCommand 注解了的方法被调用时，就会产生监控信息，并暴露到该端点中。当然，该端点默认是不会暴露的，需使用如下配置将其暴露。 12345management: endpoints: web: exposure: include: 'hystrix.stream' 此时，访问/actuator/hystrix.stream 可返回如下结果： 1&#123;"type":"HystrixCommand","name":"findById","group":"MovieController","currentTime":1547905939151,"isCircuitBreakerOpen":false,"errorPercentage":0,"errorCount":0,"requestCount":0,"rollingCountBadRequests":0,"rollingCountCollapsedRequests":0,"rollingCountEmit":0,"rollingCountExceptionsThrown":0,"rollingCountFailure":0,"rollingCountFallbackEmit":0,"rollingCountFallbackFailure":0,"rollingCountFallbackMissing":0,"rollingCountFallbackRejection":0,"rollingCountFallbackSuccess":0,"rollingCountResponsesFromCache":0,"rollingCountSemaphoreRejected":0,"rollingCountShortCircuited":0,"rollingCountSuccess":0,"rollingCountThreadPoolRejected":0,"rollingCountTimeout":0,"currentConcurrentExecutionCount":0,"rollingMaxConcurrentExecutionCount":0,"latencyExecute_mean":0,"latencyExecute":&#123;"0":0,"25":0,"50":0,"75":0,"90":0,"95":0,"99":0,"99.5":0,"100":0&#125;,"latencyTotal_mean":0,"latencyTotal":&#123;"0":0,"25":0,"50":0,"75":0,"90":0,"95":0,"99":0,"99.5":0,"100":0&#125;,"propertyValue_circuitBreakerRequestVolumeThreshold":20,"propertyValue_circuitBreakerSleepWindowInMilliseconds":5000,"propertyValue_circuitBreakerErrorThresholdPercentage":50,"propertyValue_circuitBreakerForceOpen":false,"propertyValue_circuitBreakerForceClosed":false,"propertyValue_circuitBreakerEnabled":true,"propertyValue_executionIsolationStrategy":"THREAD","propertyValue_executionIsolationThreadTimeoutInMilliseconds":1000,"propertyValue_executionTimeoutInMilliseconds":1000,"propertyValue_executionIsolationThreadInterruptOnTimeout":true,"propertyValue_executionIsolationThreadPoolKeyOverride":null,"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests":10,"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests":10,"propertyValue_metricsRollingStatisticalWindowInMilliseconds":10000,"propertyValue_requestCacheEnabled":true,"propertyValue_requestLogEnabled":true,"reportingHosts":1,"threadPool":"MovieController"&#125; 对于Feign前面讲过Feign默认已经整合了Hystrix，但这个整合其实是“不完整”，因为它默认不带有监控端点，如果你在使用Feign的同时，也想使用监控端点，需按照如下步骤操作： 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上添加注解@EnableCircuitBreaker 在application.yml 中添加如下配置： 12345management: endpoints: web: exposure: include: 'hystrix.stream' 可视化监控数据至此，我们已可通过/actuator/hystrix.strem 端点观察Hystrix运行情况，但文字形式的监控数据很不直观。现实项目中一般都需要一个可视化的界面，这样才能迅速了解系统的运行情况。Hystrix提供了一个轮子——Hystrix Dashboard，它的作用只有一个，那就是将文字形式的监控数据转换成图表展示。 编写Hystrix Dashboard 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：@EnableHystrixDashboard 写配置： 123# 端口随便写，这里只是表明下自己的端口规划而已server: port: 8030 启动后，访问http://localhost:8030/hystrix 即可看到类似如下的界面： 将上文的/actuator/hystrix.stream 端点的地址贴到图中，并指定Title，然后点击Monitor Stream 按钮，即可看到类似如下的图表： 图表解读Turbine Turbine上文的Hystrix Dashboard只支持一次监控一个微服务实例，显然是不能满足需求的，所以为了能监控多个微服务，Netflix官方再次发挥造轮子的精神——它们又编写了一个组件，Turbine。 不过这个项目刚出生就死了，14年发布后就再也没有进行更新维护。 简介Turbine是一个聚合Hystrix监控数据的工具，它可将所有相关/hystrix.stream端点的数据聚合到一个组合的/turbine.stream中，从而让集群的监控更加方便。 引入Turbine后，架构图如下： 引入Turbine编写Turbine Server 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：@EnableTurbine 写配置： 123456789101112131415server: port: 8031spring: application: name: microservice-hystrix-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: trueturbine: # 要监控的微服务列表，多个用,分隔 appConfig: microservice-consumer-movie,microservice-consumer-movie-feign clusterNameExpression: "'default'" 测试这样，Tubine即可聚合microservice-consumer-movie,microservice-consumer-movie-feign两个服务的/actuator/hystrix.stream 信息，并暴露在http://localhost:8031/turbine.stream ，将该地址贴到Hystrix Dashboard上，即可看到类似如下的图表： Zuul]]></content>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划笔记]]></title>
    <url>%2F2019%2F12%2F09%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[递归、递推 递归 自顶向下 递推 自底向上 动态规划题的一般思路 先写出递归思路 然后剪枝(前面二者都是自上而下) 然后写出dp(不同于剪枝的是 dp是自底向上) dp问题核心是穷举，dp特点是存在 重叠子问题 最优子结构 然后只要在此基础上列出 状态转移方程 即可 动态规划的三要素： 重叠子问题 最优子结构 状态转移方程 思维框架： 明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jvm笔记]]></title>
    <url>%2F2019%2F12%2F04%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常OutOfMemoryError异常包括 Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、本地直接内存溢出。 运行时数据区域包括 方法区、堆（前两者都是共享的）、虚拟机栈、本地方法栈、程序计数器（三者是线程私有）。 方法区：与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量，别名称为Non-Heap。 堆：Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，此内存区域的唯一目的是存放对象实例，同时Java堆是垃圾收集管理的主要区域，很多时候也被称为GC堆。 虚拟机栈：描述的是Java方法执行的内存模型，即每个方法会在执行的同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。经常有人把Java内存分为堆内存和栈内存，这里的栈内存就是指的虚拟机栈。 本地方法栈：与虚拟机栈发挥的功能基本一致，区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。 程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 运行时常量池：方法区的一部分。常量池（用于存放编译期生成的各种字面量和符号引用）。 直接内存：并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 Xms Xmx PermSize MaxPermSize 区别1.参数的含义-vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M-vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了-Xms128m JVM初始分配的堆内存-Xmx512m JVM最大允许分配的堆内存，按需分配-XX:PermSize=64M JVM初始分配的非堆内存-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配 我们首先了解一下JVM内存管理的机制，然后再解释每个参数代表的含义。 1)堆(Heap)和非堆(Non-heap)内存 按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。 可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的， 所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 堆内存分配 JVM初始分配的堆内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的堆内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制； 空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。 说明：如果-Xmx 不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误，此错误来自JVM，不是Throwable的，无法用try…catch捕捉。 非堆内存分配 JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。（还有一说：MaxPermSize缺省值和-server -client选项相关， -server选项下默认MaxPermSize为64m，-client选项下默认MaxPermSize为32m。这个我没有实验。） 上面错误信息中的PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。还没有弄明白PermGen space是属于非堆内存，还是就是非堆内存，但至少是属于了。XX:MaxPermSize设置过小会导致java.lang.OutOfMemoryError: PermGen space 就是内存益出。说说为什么会内存益出：（1）这一部分内存用于存放Class和Meta的信息，Class在被 Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同。（2）GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS 的话,就很可能出现PermGen space错误。 这种错误常见在web服务器对JSP进行pre compile的时候。 补充： 如果你的WEB APP下都用了大量的第三方jar，其大小超过了服务器jvm默认的大小，那么就会产生内存益出问题了。解决方法： 设置MaxPermSize大小可以在myelipse里选中相应的服务器比如tomcat5，展开里面的JDK子项页面，来增加服务器启动的JVM参数设置：-Xms128m-Xmx256m-XX:PermSize=128M-XX:MaxNewSize=256m-XX:MaxPermSize=256m或者手动设置MaxPermSize大小,比如tomcat，修改TOMCAT_HOME/bin/catalina.bat，在echo “Using CATALINA_BASE: $CATALINA_BASE”上面加入以下行：JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大内部排序]]></title>
    <url>%2F2019%2F10%2F27%2F%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[前言最近一直比较忙，马上就要考试了，所以LeetCode稍微暂时放了放，集中精力回顾了下内部排序算法，本篇文章会对常见的十大内部排序算法进行系统的回顾。 概述算法分类常见排序算法可以分为两大类： 比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法复杂度 部分补充 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 不稳定排序算法：谐音记忆法：快（快排） 些（希尔）选（选择）对（堆）。 总共4个不稳定，6个稳定。 冒泡排序基本思想冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 一次比较两个数字，两两比较，如果前者比后者大，则交换，以此类推，一轮下来，就会产生一个最大的数； 当某一轮没有产生任何一次交换，则说明冒泡完成。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344package 排序;import JAVA_I_O.Buffer.BufferedInputStream;import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;//测试类public class SortTest &#123; public static void main(String[] args) throws Exception &#123; System.out.println("请输入一个数组，用逗号分隔："); Scanner sc = new Scanner(System.in); String next = sc.nextLine(); String[] net = next.split(",");// String[] arr = Arrays.copyOf(net,net.length);// int[] arr = new int[0]; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int i = 0 ; i &lt; net.length ; i++) &#123; arrayList.add(Integer.parseInt(net[i]));// System.out.println(arr[i]); &#125; int size = arrayList.size(); Integer[] arrInt = arrayList.toArray(new Integer[size]); int[] arr = new int[size]; for(int i = 0 ; i &lt; arrInt.length;i++)&#123; arr[i] = arrInt[i]; &#125;// System.out.println(arr[i]);// int[] InsertSortArray = Sort.InsertSort(arr);// int[] SelectSortArray = Sort.SelectSort(arr); Sort.BubbleSort(arr);// int[] ShellSortArray = Sort.ShellSort2(arr);// Sort.quickSort(arr,0,arr.length-1);// Sort.heapSort(arr,arr.length-1);// Sort.courtSort(arr);// Sort.BucketSort(arr);// Sort.radixSort(arr);// for (int i = 0 ; i &lt; ShellSortArray.length ; i++) &#123;// System.out.print(ShellSortArray[i] + " ");// &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829 /** * 冒泡 * * @param sortArray 原始数组 * @return 排序数组 */public static void BubbleSort(int[] sortArray) &#123; //复制一份原始数组，用于排序操作 int[] arr = Arrays.copyOf(sortArray, sortArray.length); //循环n-1轮，剩最后一个就不需要交换了 for (int i = 1; i &lt; arr.length; i++) &#123; //标志位，当一轮下来没有任何变化时，说明冒泡结束，需要结束循环 boolean flag = true; //每一轮都要两两比较，注意每一轮结束都会确认一个值在正确的位置上，所以j的遍历次数得稍加注意 for (int j = 0; j &lt; arr.length - i; j++) &#123; //位置变化的同时说明冒泡没有结束 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 算法效率 时间复杂度：很明显，看代码就知道，冒泡有两个for循环，所以一般情况下和最坏情况下的复杂度都为O(n²)，最好的时间复杂度就是一次冒泡就完成了，即为O(n); 空间复杂度：在冒泡中，只用了temp来存储中间变量交换，没有用到其他空间(我的代码中的复制初始数组的容量其实可以省去)，所以空间复杂度是O(1); 稳定性：交换过程中，如果相邻两者的值一样，则不会交换，所以明显冒泡排序是稳定的。 tips 外循环 n-1次； 注意添加标志位，判断冒泡是否结束； 注意内部循环的次数，每外部循环结束一次，就确定一个数的最终位置。 快速排序基本思想快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法描述 首先选定一个基准值（pivot），我一般的做法是选定最左边的作为基准； 定义两个指针，一个指向最右边，一个指向最左边，然后注意让右边的先动，等右边指针所指的数值小于pivot时，右边指针不再往左走，不准动了，然后移动左边指针，等左边指针所指向的数值大于pivot时，左边指针停下，不再向右移动，然后二者交换； 交换完毕后，重复第二步，右边指针继续向左，重复； 直到左右两个指针相遇，两个都停下，将指向的数值和pivot交换，至此数组就分成了两个子数组，pivot左侧比其小，右边比其大； 然后递归子数组，直到子数组为0（low &gt; high）。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 快速排序 * 后续所有测试都跟冒泡那章写的一样 * @param sortArray 原始数组 * @param low 最左侧 * @param high 最右侧 */public static void quickSort(int[] sortArray, int low, int high) &#123; //当low = high 时，说明子数组只剩一个数了，还排个锤子啊 if (low &lt; high) &#123; //拿到基准值，这样就可以愉快的递归了 int pivot = partition(sortArray, low, high); //注意哦，递归时可没有把pivot放入其中 quickSort(sortArray, low, pivot - 1); quickSort(sortArray, pivot + 1, high); System.out.println(Arrays.toString(sortArray)); &#125;&#125;/** * 快排主思路 * @param sortArray * @param low * @param high * @return */private static int partition(int[] sortArray, int low, int high) &#123; //我个人习惯是把最左边定为基准值，具体方法有很多啦，随便你，爱咋咋的 int pivot = low; //定义左右两指针 int p = low; int q = high; //相遇就结束了哈，然后直接交换基准和指向的数值就行咯 while (p &lt; q) &#123; //没相遇并且右指针指向的值比基准值大，就向左移动，若比基准值小，那就得停下 while (p &lt; q &amp;&amp; sortArray[pivot] &lt;= sortArray[q]) q--; while (p &lt; q &amp;&amp; sortArray[pivot] &gt;= sortArray[p]) p++; //都停下了就交换叭！ swap(sortArray, p, q); &#125; swap(sortArray, pivot, p); //不要忘记最后要返回这个基准值 return p;&#125;public static void swap(int[] sum, int i, int j) &#123; int temp = sum[i]; sum[i] = sum[j]; sum[j] = temp;&#125; 算法效率快排嘛，用了分治的思想咯，所以复杂度肯定是比冒泡低的，至于是多少，我们稍加分析一下： 时间复杂度：分治思想，但是绝壁不是线性的，因为它一轮下来搞来搞去，交换这交换那的，所以一轮是logN,n轮下来就是nlogN了。我说的是最好情况和平均情况哈，最坏那肯定还是O(n²)，因为可能你很不幸，基准值就是最大的，然后就得疯狂交换。 空间复杂度：不瞎的都看得出来，就用了一个temp中间变量用来存值，所以是O(1) 。 稳定性：哎呀肯定是不稳定的啊，两个指针在那换来换去，能稳定嘛… tips 注意递归时的子串是不包括pivot的，一个是(low,pivot-1)，一个是(pivot+1,high)； 两个指针相遇，不用判断和pivot值的大小，直接交换即可，因为两个指针只会有一个在移动，那么此时此刻另一个指针一定是静止的，假如此时是右边的指针移动，那么相遇的位置即左指针停下的位置，而左指针停下说明之前右边指针也停下来过并且和左边指针指向的数进行了交换(因为只有右边停下，左边才能移动)，那么此时左边指向的数是一定比pivot小的，所以必然可以直接交换，换个角度考虑也是一样的。 还有，我一直强调必须右指针先动(其实只要是和基准相反方向的指针先动就行)，为什么捏，因为嘛，给你举个例子吧，假如有这样一个数组 9,3,4,5,6,7,10 ,左边的先动那就凉了啊，因为最后你都定在10，一叫换就变成了10,3,4,5,6,7,9，这还玩个锤子啊———–&gt; 快排从右边开始的原因 至于快排的优化，网上到处都是，懒得写了… 到时候需要再说。 简单插入排序基本思想看名字叭，插入，还尼玛简单插入，顾名思义，就是把这个待排序数组看成是一步步插好的数组，用的是最简单的方法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 注：啥是in-place知道不：原地算法) 动图演示 代码实现1234567891011121314151617181920212223/** * 直接插入排序 * 我没有in-place哈，但是是可以的 * @param SortArray 原始数组 * @return 排序数组 */ public static void InsertSort(int[] SortArray) &#123; int[] arr = Arrays.copyOf(SortArray, SortArray.length); //从1开始哦，因为第一个数默认是排好序的啦 for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i; for (; (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp); j--) &#123; //这一步最关键，因为要注意每当插入一个数字，其后面都要往后顺移一位，不然的话就空不出要插入的位置！！！ arr[j] = arr[j - 1]; &#125; //如果没有变化，则temp依然等于arr[i],如果变化，则将arr[i]移动过来就行 //注意不能直接arr[j] = arr[i]哦，因为此时的i索引值已经可能变化啦！！！！temp非常的关键！！ arr[j] = temp; &#125; System.out.println(Arrays.toString(arr)); &#125; 算法效率 时间复杂度：这种直接插入麻烦的一笔，如果是原数组是倒序，那每一轮都得疯狂插，毫无疑问最坏情况下的时间复杂度是O(n²)，最好的时间复杂度就是一次都不用给后来者让位，那么就是线性复杂度了O(n)，平均下来依旧是O(²)。 空间复杂度：in-place,O(1) 。 稳定性：当然是稳定的啦！ tips 注意插入的时候是将比插入的数大的已经排序好的数全部后移一位哦！！！给朕让位的赶脚… 用temp来保存当前需要插入的数据是非常重要的，这也是插入排序唯二需要注意的地方，还要一个需要注意的地方就是全部后移一位。 希尔排序基本思想希尔排序又叫缩小增量排序，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。 希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法描述希尔排序有n种步长方式，这里介绍两种，一种是循环折半，另一种是 gap = gap * 3 + 1。 具体：希尔排序增量序列介绍 。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示 代码实现1234567891011121314151617181920212223/*** 其实就是将直接插入排序的间隔1变为更大，也就是其实就多了一个循环，就是多次缩小间隔的循环，其他跟直接插入是一样的** @param sortArray* @return*/ public static int[] ShellSort2(int[] sortArray) &#123; int[] arr = Arrays.copyOf(sortArray, sortArray.length); int size = sortArray.length; for (int increment = size / 2; increment &gt; 0; increment /= 2) &#123; for (int i = increment; i &lt; size; i++) &#123; int temp = arr[i]; int j = i; for (; (j &gt; 0 &amp;&amp; arr[j - increment] &gt; temp); j -= increment) &#123; //这一步最关键，因为要注意每当插入一个数字，其后面都要往后顺移increment位，不然的话就空不出要插入的位置！！！ arr[j] = arr[j - increment]; &#125; //如果没有变化，则temp依然等于arr[i],如果变化，则将arr[i]移动过来就行 arr[j] = temp; &#125; &#125; return arr; &#125; 12345678910111213141516171819202122232425262728293031 /** * 不是我写的 * * @param sourceArray * @return * @throws Exception */public static int[] ShellSort1(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i; for (; j &gt;= 0 &amp;&amp; arr[j - gap] &gt; tmp; j -= gap) &#123; arr[j] = arr[j - gap]; &#125; arr[j] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr;&#125; 算法效率 时间复杂度：最坏和最好我们都知道，这个就跟直接插入没区别，最好最坏都是取决于原数组序列，所以最好的时间复杂度依旧是O(n)，最坏的时间复杂度依旧是O(n²)，平均复杂度？我tm也不知道为啥，记住就是啦，O(n^1.3)。 空间复杂度：这个简单的一批，还不就是O(1)。 稳定性：这种跳跃性的当然是不稳定了。例如arr = {3,2,2}。 tips简单的一批…不就是把直接插入的1变成 increment 嘛 …… 没啥需要注意的！ 啊！！！不对，其实还是有一个需要注意的！！！ 这里是三重循环，因为那个步长要变化，然后不同步长都要进行排序，一次排序是两重循环 over 简单选择排序基本思想选择排序，意在突出选择 二字，所以我们要做的就是有一个选择的过程，至于简单选择，简而言之就是非常非常简单的选择排序，那不就是每次都找个最小值往前扔嘛… 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：(这么官方肯定是复制的啦哈哈哈哈哈) 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；(这种屁话读起来简直就是浪费生命) n-1趟结束，数组有序化了。 注：就是说 ——– 每次遍历数组都选一个最小的扔到最前面（跟要扔的位置的数进行交换），然后从剩下的还没排序的继续遍历，继续扔，扔了n-1次就结束了叭。 动图演示 代码实现1234567891011121314151617181920212223242526272829/** * 简单选择排序 * * @param SortArray 原始数组 * @return 排序数组 */public static int[] SelectSort(int[] SortArray) &#123; int[] arr = Arrays.copyOf(SortArray, SortArray.length); //注意是n-1轮，一轮一个最小值，最后那个不用轮了 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //最开始默认第一个是最小的，然后进入内层循环，分别进行比较，一定要记录下min的下标，这是最后比较完交换的关键 //每一次循环的目的就是找到一个最小值，然后与当前外部循环的值进行一个交换 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; //min = Math.min(min,arr[j]); if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; //判断是否需要交换 if (i != min) &#123; int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr;&#125; 算法效率必须要吐槽的是，这个直接选择排序是垃圾中的战斗机，因为它无视任何数组，干啥都是废物的O(n²)时间复杂度！！！！！！！ 时间复杂度：O(n²) ； 空间复杂度：O(1) ； 稳定性：当然是不稳定的了，涉及到瞎鸡儿交换（不临近）的，就肯定不稳定的啦。 tips没啥注意点，就是非常的垃圾，不要用… 堆排序基本思想这个牛逼勒，我个人最欣赏这个，因为java中的PriorityQueue用了堆排序…在做k个有序链表合并等问题时，用PriorityQueue简直就是神器啊… 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 算法描述 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 动图演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 /** * 堆排序 * * @param sortArray * @param len 注意这里是arr.length，跟之前不一样，堆排序是从1开始的 */ public static void heapSort(int[] sortArray, int len) &#123; //建立大根堆 BuildMaxHeap(sortArray, len); //每次都将根取出，然后将最底下的放到根，然后进行堆调整 for (int i = len; i &gt; 0; i--) &#123; swap(sortArray, i, 0);// AdjustDown(sortArray,0,i-1); AdjustDown2(sortArray, 0, i - 1); &#125; System.out.println(Arrays.toString(sortArray)); &#125; /** * 先写一个递归的，比较好理解 * * @param sortArray * @param i * @param len */ private static void AdjustDown(int[] sortArray, int i, int len) &#123; //注意这里的len是length-1，然后根的序号是1，所以left是2i+1 int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt;= len &amp;&amp; sortArray[left] &gt; sortArray[largest]) largest = left; if (right &lt;= len &amp;&amp; sortArray[right] &gt; sortArray[largest]) largest = right; if (largest != i) &#123; swap(sortArray, largest, i); AdjustDown(sortArray, largest, len); &#125; &#125; /** * 写一个非递归的吧，注意哈，这里的len是length-1，跟上面的一样 * * @param sortArray * @param i * @param len */ private static void AdjustDown2(int[] sortArray, int i, int len) &#123; int t = i; for (int m = 2 * i + 1; m &lt;= len; m = t * 2 + 1) &#123; if (sortArray[m] &gt; sortArray[t]) t = m; if (m + 1 &lt;= len &amp;&amp; sortArray[m + 1] &gt; sortArray[t]) t = m + 1; if (t == i) break; else &#123; swap(sortArray, t, (m - 1) / 2); i = (m - 1) / 2; &#125; &#125; &#125; private static void BuildMaxHeap(int[] sortArray, int len) &#123; double lens = len; //注意是从lens/2开始 for (int i = (int) Math.round((lens / 2)) - 1; i &gt;= 0; i--) &#123;// System.out.println(i);// AdjustDown(sortArray,i,len); AdjustDown2(sortArray, i, len); &#125; &#125; 算法效率 时间复杂度：平均时间、最坏和最好情况下都一样，都是O(nlogn) 。 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n); 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn); 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn)。 空间复杂度：O(1)。 稳定性：由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列。同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。 tips 堆排序，主要就是把根拿出来，然后剩下的调整成最大堆，所以第一个拿出来的最大的就应该放到最好一个位置，一共循环 n-1 次即可； 注意代码中的 len 是 length-1。 还有一个容易出错的地方在建立大根堆的时候，i 应该是从最后一个节点的父亲节点开始调整。 写的非递归还是不太好…虽然好像能通过，非递归中代码中的m是指节点的左孩子，如果有交换，切勿忘记更新新的父亲节点(i = (m-1)/2)，然后进行下一步和孩子节点的比较。 归并排序基本思想归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用 分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列，然后子序列首端各维护一个指针，互相比较； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * 自己写一个 底层是数组 */ public static void mergeSort(int[] sortArray, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; //注意和快排区分一下，这里的mid是要在递归里面的 mergeSort(sortArray, low, mid); mergeSort(sortArray, mid + 1, high); //思路就是先一分为二再合二为一 merge(sortArray, low, mid, high); System.out.println(Arrays.toString(sortArray)); &#125; &#125; private static void merge(int[] sortArray, int low, int mid, int high) &#123; //牺牲了空间，引入了一个新的空间来存储排好序的数组 int[] temp = new int[high - low + 1]; int i = low; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (sortArray[i] &lt; sortArray[j]) &#123; temp[k++] = sortArray[i++]; &#125; else &#123; temp[k++] = sortArray[j++]; &#125; &#125; //非常严重的错误，if中的j++后会影响下一个if，所以会超出索引值。数组越界// if(i &gt; mid)&#123;// temp[k++] = sortArray[j++];// &#125;// if(j &gt; high)&#123;// temp[k++] = sortArray[i++];// &#125; if (i &lt;= mid) &#123; temp[k++] = sortArray[i++]; &#125; if (j &lt;= high) &#123; temp[k++] = sortArray[j++]; &#125; for (int t = 0; t &lt; temp.length; t++) &#123; //这里也是易错点，注意sortArray的下标是从low开始的 sortArray[low + t] = temp[t]; &#125; &#125; 算法效率 时间复杂度：归并排序可算是排序算法中的”佼佼者”。假设数组长度为n，那么拆分数组共需logn, 又每步都是一个普通的合并子数组的过程，时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。注意，平均时间复杂度、最好时间复杂度、最坏时间复杂度都是O(nlogn)。 空间复杂度：需要一个额外的数组来存储排序好的数组，所以是O(N)。 稳定性：稳定。 tips 首先注意递归部分，跟快排有所区别，快排是排序一轮结束后才能返回中间节点，而归并是直接算出中间节点，并且归并的mid是要参与递归的，而快排中的基准值不需要参加递归。 合并过程。首先是要new一个新的数组来存储排序好的数组，两个指针轮流比较，如果底层是链表，两个头结点互相比较，最后合并之后返回一个头结点即可。 注意最后将合并排序好的数组放回到原数组时，下标是从 low 开始的。 计数排序计数排序、基数排序、桶排序属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 基本思想计数排序需要占用大量空间，它仅适用于数据比较集中的情况。比如 [0~100]，[10000~19999] 这样的数据。 计数排序的基本思想是： 对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。所以可以把 arr[i] 放到它输出数组中的位置上。 假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。 其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中 arr[i] 的元素出现的次数，将 arr[i] - min 作为辅助数组helper的索引值； 对所有的计数累加，helper 索引值对应的值即为该 arr[i] 出现的次数； 反向填充目标数组：将 helper 中的元素根据索引依次放回原数组，索引对应的数值即为该数出现的次数，每放一个元素就将 helper[arr[i]-min] 减去1。 动图演示 代码实现12345678910111213141516171819202122232425/** * 计数排序 * 要有两个数组，分别是原数组，中间数组用来排序的 * * @param sortArray */public static void courtSort(int[] sortArray) &#123; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; sortArray.length; i++) &#123; max = Math.max(max, sortArray[i]); min = Math.min(min, sortArray[i]); &#125; int[] helparr = new int[max - min + 1]; for (int i = 0; i &lt; sortArray.length; i++) &#123; helparr[sortArray[i] - min]++; &#125; int index = 0; for (int i = 0; i &lt; helparr.length; i++) &#123; while (helparr[i]-- &gt; 0) &#123; sortArray[index++] = i + min; &#125; &#125; System.out.println(Arrays.toString(sortArray));&#125; 算法效率 时间复杂度：当输入元素是 n 个 0到 k 之间的整数时，平均时间、最坏和最好情况下都一样，都是O(n+k) 。其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 空间复杂度：O(n+k) 。 稳定性：稳定。 tips 注意：为了节省空间，helper 必须是 arr[i]-min作为索引值。 在将排序好的数组放回原数组时，别忘了把中间数组索引对应的值减去1，当为0时说明该索引代表的值不存在。 桶排序基本思想 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort) 的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 桶排序可用于最大最小值相差较大的数据情况，比如[9012,19702,39867,68957,83556,102456]。但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。 桶排序的基本思想是：把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。 算法描述 找出待排序数组中的最大值 max、最小值 min； 我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为 (max-min)/BucketSize+1； 遍历数组 arr，计算每个元素 arr[i] 放的桶； 每个桶各自排序； 遍历桶数组，把排序好的元素放进输出数组。 图片演示 代码实现1234567891011121314151617181920212223242526272829303132/** * 桶排序 * * @param sortArray */public static void BucketSort(int[] sortArray) &#123; //1.设置固定数量的空桶 int max = Integer.MIN_VALUE; int BucketSize = 5; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; sortArray.length; i++) &#123; max = Math.max(max, sortArray[i]); min = Math.min(min, sortArray[i]); &#125; int BucketCount = (max - min) / BucketSize + 1; //2.把数据放到对应桶中 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(BucketCount); for (int i = 0; i &lt; BucketCount; i++) &#123; buckets.add(new ArrayList&lt;Integer&gt;()); &#125; for (int i = 0; i &lt; sortArray.length; i++) &#123; int num = (sortArray[i] - min) / BucketSize; buckets.get(num).add(sortArray[i]); &#125; //3.排序 for (int i = 0; i &lt; buckets.size(); i++) &#123; //直接用的是集合自带的排序，可以选择插入或者递归使用桶排序 Collections.sort(buckets.get(i)); &#125; System.out.println(buckets.toString()); &#125; 算法效率 时间复杂度：桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶中数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶的范围划分的越小，桶越多，各个桶之间的数据越少，排序所用的时间也会越少。所以最差的时间复杂度为 O(n²)，平均时间复杂度为 O(n+k)，最好的时间复杂度为 O(n)。 空间复杂度：O(n+k) 。 稳定性：稳定。 tips 桶最好是用ArrayList，里面的数据最好也是ArrayList装载，因为这样方便动态的添加数据到桶中。 桶内排序可以随便选择一种排序算法，这里采用的是java集成好的集合排序的方法。 基数排序基本思想基数排序（Radix Sort）是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr 为原始数组，从最低位开始取每个位组成 radix 数组； 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）； 动图演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839/** 基数排序 * 可以采用桶的思想，也可以采用队列的思想 * * @param array */ public static void radixSort(int[] array) &#123; if (array == null || array.length &lt; 2) return; // 1.先算出最大数的位数； int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; max = Math.max(max, array[i]); &#125; int maxDigit = 0; while (max != 0) &#123; max /= 10; maxDigit++; &#125; int mod = 10, div = 1; //桶可以用二维数组实现，也可以用ArrayList实现，推荐列表，因为是动态的 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; bucketList.add(new ArrayList&lt;Integer&gt;()); &#125; for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123; for (int j = 0; j &lt; array.length; j++) &#123; int num = (array[j] % mod) / div; bucketList.get(num).add(array[j]); &#125; int index = 0; for (int j = 0; j &lt; bucketList.size(); j++) &#123; for (int k = 0; k &lt; bucketList.get(j).size(); k++) &#123; array[index++] = bucketList.get(j).get(k); &#125; bucketList.get(j).clear(); &#125; &#125; System.out.println(Arrays.toString(array)); &#125; 算法效率 时间复杂度：基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n)的时间复杂度。假如待排数据可以分为 d个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。最好、最差、平均时间复杂度都是O(n*k)级别的。 空间复杂度：O(n+k)，其中k为桶的数量。一般来说 n&gt;&gt;k，因此额外空间需要大概 n 个左右。 稳定性：稳定。 tips 注意每个桶内数据排序好然后返回给原数组后，记得clear； 点睛之笔是 将基数排序转换为计数排序，分别对其个位、十位…进行计数排序。 参考文献 十大经典排序算法 十大经典排序算法之JAVA实现 计数排序和桶排序之JAVA实现 十大经典排序算法动画与解析，看我就够了！（配代码完全版） 面试必备：八种排序算法原理及Java实现]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[darkmode for mac]]></title>
    <url>%2F2019%2F10%2F24%2Fdarkmode%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[Mac端darkmode设置Mac端外观具体操作方式 打开 系统偏好设置 点击 通用 修改 外观 修改完之后，部分软件会自动适配系统的环境色，例如chrome，网易云等等。 修改chrome网页颜色在谷歌插件商店中查找一款Dark Reader的插件，可以完美配合暗黑模式的使用 自动切换白天黑夜的模式下载一款叫做DarkNight的软件，可以根据当地的日落日出时间自动切换屏保，配合暗黑模式的使用。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现单链表]]></title>
    <url>%2F2019%2F10%2F16%2Fjava%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[Java实现单向链表基本功能先说一下，参考借鉴的博客有： Java实现单向链表基本功能 Java单链表反转 详细过程 从链表中删除重复数据（三种方法) 补充写的没人家好，这部分主要是对第一个博客的补充，其单向链表中的链表反转和从链表中删除重复数据解释的不够清晰，后面两个博客是扩展这两个知识点的，在看这个知识点的同时，发现用到了部分HashTable的知识，过段时间需要把这个知识点也完善一下。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transient关键字]]></title>
    <url>%2F2019%2F10%2F12%2Ftransient%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[transient关键字作用(转载)作用及使用方法​ 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 ​ 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 ​ 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: Alexiapassword: null 密码字段为null，说明反序列化时根本没有从文件中获取到信息。 transient使用小结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; // 在反序列化之前改变username的值 User.username = "jmwang"; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; public static String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: jmwangpassword: null 这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。 3. transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;/** * @descripiton Externalizable接口的使用 * * @author Alexia * @date 2013-10-15 * */public class ExternalizableTest implements Externalizable &#123; private transient String content = "是的，我将会被序列化，不管我是否被transient关键字修饰"; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(content); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; content = (String) in.readObject(); &#125; public static void main(String[] args) throws Exception &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream( new File("test"))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File( "test"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125; content变量会被序列化吗？ 好吧，我把答案都输出来了，是的，运行结果就是：是的，我将会被序列化，不管我是否被transient关键字修饰 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ ​ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。 转载于：Java transient关键字使用小记]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo提交文章出现问题]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95git%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题记录hexo发布文章报错记录：Unhandled rejection TypeError: Cannot set property ‘lastIndex’ of undefined发布文章时出现问题，同时报的错还有：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决措施发现是git出现问题！！！ 控制端输入： 1brew install git 1xcode-select --install 在xcode-select指令安装好之后，再命令检查一下git指令的帮助信息： 1git -h 可以正确输出相应的帮助信息，意味着git已经被修复好了。 原因更新了Catalina导致的，新系统辣鸡哈哈哈哈哈哈]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜大普奔]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%96%9C%E5%A4%A7%E6%99%AE%E5%A5%94.html</url>
    <content type="text"><![CDATA[开心哇！！！终于写到10w字了！！！继续加油！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>happy </tag>
        <tag>happy day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List源码分析]]></title>
    <url>%2F2019%2F10%2F07%2FList%20%26%20Queue%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[ArrayList 源码分析（转载）不知道各位朋友，还记得开工前制定的学习目标么？ 有没有一直为了那个目标废寝忘食呢？继 搞懂 Java 内部类 后开始探索总结 Java 集合框架源码的知识，希望能给自己夯实基础，也希望能为自己实现目标更近一步。 ArrayList 源码分析思路ArrayList 是我们 App 开发中常用的 Java 集合类，从学习 Java 开始我们基本上就对它天天相见了，但是通过探索ArrayList 源码，我们将会把它从普通朋友变成知根知底的老朋友,本文将从以下几部分开始分析 ArrayList： ArrayList 概述 ArrayList 的构造函数，也就是我们创建一个 ArrayList 的方法 ArrayList 的添加元素的方法， 以及 ArrayList 的扩容机制 ArrayList 的删除元素的常用方法 ArrayList 的 改查常用方法 ArrayList 的 toArray 方法 ArrayList 的遍历方法，以及常见的错误操作即产生错误操作的原因 ArrayList 概述ArrayList的基本特点 ArrayList 底层是一个动态扩容的数组结构 允许存放（不止一个） null 元素 允许存放重复数据，存储顺序按照元素的添加顺序 ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使用 collections.synchronizedList(List l) 函数返回一个线程安全的ArrayList类. ArrayList 的继承关系12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从 ArrayList 的继承关系来看， ArrayList 继承自 AbstractList ，实现了List\, RandomAccess, Cloneable, java.io.Serializable 接口。 其中 AbstractList和 List 是规定了 ArrayList 作为一个集合框架必须具备的一些属性和方法，ArrayList 本身覆写了基类和接口的大部分方法，这就包含我们要分析的增删改查操作。 ArrayList 实现 RandomAccess 接口标识着其支持随机快速访问，查看源码可以知道 RandomAccess 其实只是一个标识，标识某个类拥有随机快速访问的能力，针对 ArrayList 而言通过 get(index) 去访问元素可以达到 O(1) 的时间复杂度。有些集合类不拥有这种随机快速访问的能力，比如 LinkedList 就没有实现这个接口。 ArrayList 实现 Cloneable 接口标识着他可以被克隆/复制，其内部实现了 clone 方法供使用者调用来对 ArrayList 进行克隆，但其实现只通过 Arrays.copyOf 完成了对 ArrayList 进行「浅拷贝」，也就是你改变 ArrayList clone后的集合中的元素，源集合中的元素也会改变，对于深浅拷贝我已经单独整理一篇文章来讲述这里不再过多的说。 对于 java.io.Serializable 标识着集合可被被序列化。 我们发现了一些有趣的事情，除了 List\ 以外，ArrayList 实现的接口都是标识接口，标识着这个类具有怎样的特点，看起来更像是一个属性。 ArrayList 的构造方法在说构造方法之前我们要先看下与构造参数有关的几个全局变量： 12345678910111213141516171819202122/*** ArrayList 默认的数组容量*/ private static final int DEFAULT_CAPACITY = 10;/*** 这是一个共享的空的数组实例，当使用 ArrayList(0) 或者 ArrayList(Collection&lt;? extends E&gt; c) * 并且 c.size() = 0 的时候讲 elementData 数组讲指向这个实例对象。*/ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/*** 另一个共享空数组实例，再第一次 add 元素的时候将使用它来判断数组大小是否设置为 DEFAULT_CAPACITY*/ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/*** 真正装载集合元素的底层数组 * 至于 transient 关键字这里简单说一句，被它修饰的成员变量无法被 Serializable 序列化 * 有兴趣的可以去网上查相关资料*/ transient Object[] elementData; // non-private to simplify nested class access 对于上述几个成员变量，我们只是在注释中简单的说明，对于他们具体有什么作用，在下边分析构造方法和扩容机制的时候将会更详细的讲解。 ArrayList 一共三种构造方式，我们先从无参的构造方法来开始： 无参构造方法123456/*** 构造一个初始容量为10的空列表。*/ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 这是我们经常使用的一个构造方法，其内部实现只是将 elementData 指向了我们刚才讲得 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个空数组，这个空数组的容量是 0， 但是源码注释却说这是构造一个初始容量为10的空列表。这是为什么？其实在集合调用 add 方法添加元素的时候将会调用 ensureCapacityInternal 方法，在这个方法内部判断了： 123if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125; 可见，如果采用无参数构造方法的时候第一次添加元素肯定走进 if 判断中 minCapacity 将被赋值为 10，所以构造一个初始容量为10的空列表 也就是这个意思。 指定初始容量的构造方法12345678910111213141516/*** 构造一个具有指定初始容量的空列表。* @param 初始容量 * @throws 如果参数小于 0 将会抛出 IllegalArgumentException 参数不合法异常 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 如果我们预先知道一个集合元素的容纳的个数的时候推荐使用这个构造方法，比如我们有个FragmentPagerAdapter 一共需要装 15 个 Fragment ，那么我们就可以在构造集合的时候生成一个初始容量为 15 的一个集合。有人会认为 ArrayList 自身具有动态扩容的机制，无需这么麻烦，下面我们讲解扩容机制的时候我们就会发现，每次扩容是需要有一定的内存开销的，而这个开销在预先知道容量的时候是可以避免的。 源代码中指定初始容量的构造方法实现，判断了如果 我们指定容量大于 0 ，将会直接 new 一个数组，赋值给 elementData 引用作为集合真正的存储数组，而指定容量等于 0 的时候讲使用成员变量 EMPTY_ELEMENTDATA 作为暂时的存储数组，这是 EMPTY_ELEMENTDATA 这个空数组的一个用处（不必太过于纠EMPTY_ELEMENTDATA 的作用，其实它的在源码中出现的频率并不高）。 使用另个一个集合 Collection 的构造方法12345678910111213141516/*** 构造一个包含指定集合元素的列表，元素的顺序由集合的迭代器返回。* @param 源集合，其元素将被放置到这个集合中。 * @如果参数为 null，将会抛出 NullPointerException 空指针异常*/public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray 可能(错误地)不返回 Object[]类型的数组 参见 jdk 的 bug 列表(6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 如果集合大小为空将赋值为 EMPTY_ELEMENTDATA 等同于 new ArrayList(0); this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 看完这个代码我最疑惑的地方是 Collection.toArray() 和 Arrays.copyOf() 这两个方法的使用，看来想明白这个构造参数具体做了什么必须理解这两个方法了。 Object[] Collection.toArray() 方法我们都知道 Collection 是集合框架的超类，其实 Collection.toArray 是交给具体的集合子类去实现的，这就说明不同的集合可能有不同的实现。他用来将一个集合转化为一个 Object[] 数组，事实上的真的是这样的么？参见 jdk 的 bug 列表(6260652)又是什么意思呢 ？我们来看下下边的这个例子： 12345678910111213List&lt;String&gt; subClasses = Arrays.asList("abc","def");// class java.util.Arrays$ArrayList System.out.println(list.getClass()); Object[] objects = subClasses.toArray();// class java.lang.String; Object[] objArray = list.toArray(); //这里返回的是 String[]System.out.println(objects.getClass().getSimpleName()); objArray[0] = new Object(); // cause ArrayStoreException 咦？为啥这里并不是一个 Object 数组呢？其实我们注意到，list.getClass 得到的并不是我们使用的 ArrayList 而是 Arrays 的内部类 Arrays$ArrayList。 123456789ArrayList(E[] array) &#123; //这里只是检查了数组是否为空，不为空直接将原数组赋值给这个 ArrayList 的存储数组。 a = Objects.requireNonNull(array);&#125;@Overridepublic Object[] toArray()&#123; return a.clone();&#125; 而我们调用的 toArray 方法就是这个内部对于 Collection.toArray 的实现， a.clone() ,这里 clone 并不会改变一个数组的类型，所以当原始数组中放的 String 类型的时候就会出现上边的这种情况了。 其实我们可以认为这是 jdk 的一个 bug，早在 05年的时候被人提出来了，但是一直没修复，但是在新的 「jdk 1.9」 种这个 bug 被修复了。 有兴趣的可以追踪 bug 6260652 看下。 Arrays.copyOf 方法这个方法是在集合源码中常见的一个方法，他有很多重载方式,我们来看下最根本的方法： 1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 上边的注释也看出来了，Arrays.copyOf 方法复制数组的时候先判断了指定的数组类型是否为 Object[] 类型，否则使用反射去构造一个指定类型的数组。最后使用 System.arraycopy 这个 native 方法，去实现最终的数组赋值，newLength 如果比 original.length 大的时候会将多余的空间赋值为 null 由下边的例子可见: 12345String[] arrString = &#123;"abc","def"&#125;;Object[] copyOf = Arrays.copyOf(arrString, 5, Object[].class);//[abc, def, null, null, null]System.out.println(Arrays.toString(copyOf)); 当然 ArrayList(Collection&lt;? extends E&gt; c) 复制的时候传递的是 c.size() 所以不会出现 null。 ex: 对于 System.arraycopy 该方法，本文不再展开讨论，有一篇对于其分析很好的文章大家可以去参考System：System.arraycopy方法详解 ok，绕了这么大的圈子终于明白了，ArrayList(Collection&lt;? extends E&gt; c)干了啥了，其实就是将一个集合中的元素塞到 ArrayList 底层的数组中。至此我们也将 ArrayList 的构造研究完了。 ArrayList的添加元素 &amp; 扩容机制敲黑板了！这块是面试的常客了，所以必须仔细研究下了。我们先看下如何给一个 ArrayList 添加一个元素: 在集合末尾添加一个元素的方法123456789101112131415//成员变量 size 标识集合当前元素个数初始为 0int size；/*** 将指定元素添加到集合（底层数组）末尾* @param 将要添加的元素* @return 返回 true 表示添加成功*/public boolean add(E e) &#123; //检查当前底层数组容量，如果容量不够则进行扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //将数组添加一个元素，size 加 1 elementData[size++] = e; return true;&#125; 调用 add 方法的时候总会调用 ensureCapacityInternal 来判断是否需要进行数组扩容， ensureCapacityInternal 参数为当前集合长度 size + 1，这很好理解，是否需要扩充长度，需要看当前底层数组是否够放 size + 1个元素的。 扩容机制1234567891011121314151617//扩容检查private void ensureCapacityInternal(int minCapacity) &#123; //如果是无参构造方法构造的的集合，第一次添加元素的时候会满足这个条件 minCapacity 将会被赋值为 10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; // 将 size + 1 或 10 传入 ensureExplicitCapacity 进行扩容判断 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //操作数加 1 用于保证并发访问 modCount++; // 如果 当前数组的长度比添加元素后的长度要小则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 上边的源码主要做了扩容前的判断操作，注意参数为当前集合元素个数+1，第一次添加元素的时候 size + 1 = 1 ,而 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 长度为 0 ，1 - 0 &gt; 0, 所以需要进行 grow 操作也就是扩容。 1234567891011121314151617181920212223242526272829303132333435/*** 集合的最大长度 Integer.MAX_VALUE - 8 是为了减少出错的几率 Integer 最大值已经很大了*/private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/*** 增加容量，以确保它至少能容纳最小容量参数指定的元素个数。* @param 满足条件的最小容量*/private void grow(int minCapacity) &#123; //获取当前 elementData 的大小，也就是 List 中当前的容量 int oldCapacity = elementData.length; //oldCapacity &gt;&gt; 1 等价于 oldCapacity / 2 所以新容量为当前容量的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果扩大1.5倍后仍旧比 minCapacity 小那么直接等于 minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新数组大小比 MAX_ARRAY_SIZE 就需要进一步比较 minCapacity 和 MAX_ARRAY_SIZE 的大小 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity通常接近 size 大小 //使用 Arrays.copyOf 构建一个长度为 newCapacity 新数组 并将 elementData 指向新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/*** 比较 minCapacity 与 Integer.MAX_VALUE - 8 的大小如果大则放弃-8的设定，设置为 Integer.MAX_VALUE */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 由此看来 ArrayList 的扩容机制的知识点一共又两个 每次扩容的大小为原来大小的 1.5 倍 （当然这里没有包含 1.5倍后大于 MAX_ARRAY_SIZE 的情况）扩容的过程其实是一个将原来元素拷贝到一个扩容后数组大小的长度新数组中。所以 ArrayList 的扩容其实是相对来说比较消耗性能的。 在指定角标位置添加元素的方法123456789101112131415161718/*** 将指定的元素插入该列表中的指定位置。将当前位置的元素(如果有)和任何后续元素移到右边(将一个元素添加到它们的索引中)。* @param 要插入的索引位置* @param 要添加的元素* @throws 如果 index 大于集合长度 小于 0 则抛出角标越界 IndexOutOfBoundsException 异常*/public void add(int index, E element) &#123; // 检查角标是否越界 rangeCheckForAdd(index); // 扩容检查 ensureCapacityInternal(size + 1); //调用 native 方法新型数组拷贝 System.arraycopy(elementData, index, elementData, index + 1,size - index); // 添加新元素 elementData[index] = element; size++;&#125; 我们知道一个数组是不能在角标位置直接插入元素的，ArrayList 通过数组拷贝的方法将指定角标位置以及其后续元素整体向后移动一个位置，空出 index 角标的位置，来赋值新的元素。 将一个数组 src 起始 srcPos 角标之后 length 长度间的元素，赋值到 dest 数组中 destPos 到 destPos + length -1长度角标位置上。只是在 add 方法中 src 和 dest 为同一个数组而已。 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 批量添加元素由于批量添加和添加一个元素逻辑大概相同则这里不详细说了，代码注释可以了解整个添加流程。 在数组末尾添加 12345678910111213public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 调用 c.toArray 将集合转化数组 Object[] a = c.toArray(); // 要添加的元素的个数 int numNew = a.length; //扩容检查以及扩容 ensureCapacityInternal(size + numNew); // Increments modCount //将参数集合中的元素添加到原来数组 [size，size + numNew -1] 的角标位置上。 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; //与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false return numNew != 0;&#125; 在数组指定角标位置添加1234567891011121314151617181920public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //同样检查要插入的位置是否会导致角标越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); //这里做了判断，如果要numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0最后位置 则表示要在数组末尾添加 如果 &lt; 0 rangeCheckForAdd 就跑出了角标越界 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 两个方法不同的地方在于如果移动角标即之后的元素，addAll(int index, Collection&lt;? extends E&gt; c)里做了判断，如果要 numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0 最后位置 则表示要在数组末尾添加 如果 numMoved &lt; 0 ，rangeCheckForAdd 就抛出了角标越界异常了。 与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false。 ArrayList 删除元素根据角标移除元素1234567891011121314151617181920212223242526/*** 将任何后续元素移到左边(从它们的索引中减去一个)。*/public E remove(int index) &#123; //检查 index 是否 &gt;= size rangeCheck(index); modCount++; //index 位置的元素 E oldValue = elementData(index); // 需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //采用拷贝赋值的方法将 index 之后所有的元素 向前移动一个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将 element 末尾的元素位置设为 null elementData[--size] = null; // clear to let GC do its work // 返回 index 位置的元素 return oldValue;&#125;// 比较要移除的角标位置和当前 elementData 中元素的个数private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 根据角标移除元素的方法源码如上所示，值得注意的地方是： rangeCheck 和 rangeCheckForAdd 方法不同 ，rangeCheck 只检查了 index是否大于等于 size，因为我们知道 size 为 elementData 已存储数据的个数，我们只能移除 elementData 数组中 [0 , size -1] 的元素，否则应该抛出角标越界。 但是为什么没有和 rangeCheckForAdd 一样检查小于0的角标呢，是不是remove(-1) 不会抛异常呢？ 其实不是的，因为 rangeCheck(index); 后我们去调用 elementData(index) 的时候也会抛出 IndexOutOfBoundsException 的异常，这是数组本身抛出的，不是 ArrayList 抛出的。那为什么要检查&gt;= size 呢？ 数组本身不也会检查么？ 哈哈.. 细心的同学肯定知道 elementData.length 并不一定等于 size，比如： 123456ArrayList&lt;String&gt; testRemove = new ArrayList&lt;&gt;(10); testRemove.add("1"); testRemove.add("2"); // java.lang.IndexOutOfBoundsException: Index: 2, Size: 2 String remove = testRemove.remove(2); System.out.println("remove = " + remove + ""); new ArrayList&lt;&gt;(10) 表示 elementData 初始容量为10，所以 elementData.length = 10 而我们只给集合添加了两个元素所以 size = 2 这也就是为啥要 rangeCheck 的原因了。 移除指定元素1234567891011121314151617181920212223242526272829303132333435/*** 删除指定元素，如果它存在则反会 true，如果不存在返回 false。* 更准确地说是删除集合中第一出现 o 元素位置的元素 ，* 也就是说只会删除一个，并且如果有重复的话，只会删除第一个次出现的位置。*/public boolean remove(Object o) &#123; // 如果元素为空则只需判断 == 也就是内存地址 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //得到第一个等于 null 的元素角标并移除该元素 返回 ture fastRemove(index); return true; &#125; &#125; else &#123; // 如果元素不为空则需要用 equals 判断。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; //得到第一个等于 o 的元素角标并移除该元素 返回 ture fastRemove(index); return true; &#125; &#125; return false;&#125;//移除元素的逻辑和 remve(Index)一样 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 由上边代码可以看出来，移除元素和移除指定角标元素一样最终都是通过 System.arraycopy 将 index 之后的元素前移一位，并释放原来位于 size 位置的元素。 还可以看出，如果数组中有指定多个与 o 相同的元素只会移除角标最小的那个，并且 null 和 非null 的时候判断方法不一样。至于 equals 和 == 的区别，还有 hashCode 方法，我会之后在总结一篇单独的文章。等不急的可以先去网上找找喽。 批量移除/保留 removeAll/retainAllArrayList 提供了 removeAll/retainAll 操作，这两个操作分别是 批量删除与参数集合中共同享有的元素 和 批量删除与参数集合中不共同享有的元素，保留共同享有的元素，两个方法只有一个参数不同!!! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 批量删除与参数集合中共同享有的元素*/public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 如果为空则抛出 NullPointerException 异常 Objects 的方法 Objects.requireNonNull(c); return batchRemove(c, false);&#125; /** 只保留与 c 中元素相同的元素相同的元素*/public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125; /** 批量删除的指定方法 */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // r w 两个角标 r 为 elementData 中元素的索引 // w 为删除元素后集合的长度 int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) // 如果 c 当前集合中不包含当前元素，那么则保留 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // 如果c.contains（o）可能会抛出异常，如果抛出异常后 r!=size 则将 r 之后的元素不在比较直接放入数组 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); // w 加上剩余元素的长度 w += size - r; &#125; // 如果集合移除过元素，则需要将 w 之后的元素设置为 null 释放内存 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; //返回是否成功移除过元素，哪怕一个 return modified;&#125; 可以看到移除指定集合中包含的元素的方法代码量是目前分析代码中最长的了，但是逻辑也很清晰： 从 0 开始遍历 elementData 如果 r 位置的元素不存在于指定集合 c 中，那么我们就将他复制给数组 w 位置， 整个遍历过程中 w &lt;= r。 由于 c.contains(o)可能会抛出异常ClassCastException/NullPointerException，如果因为异常而终止（这两个异常是可选操作，集合源码中并没有显示生命该方法一定会抛异常），那么我们将会产生一次错误操作，所以 finally 中执行了判断操作，如果 r!= size 那么肯定是发生了异常，那么则将 r 之后的元素不在比较直接放入数组。最终得到的结果并不一定正确是删除了所有与 c 中的元素。 批量删除和保存中，涉及高效的保存/删除两个集合公有元素的算法，是值得我们学习的地方,写的真好哈哈哈哈哈！！！ ArrayList 的改查对于一个ArrayList 的改查方法就很简单了，set 和 get 方法。下面我们看下源码吧： 修改指定角标位置的元素1234567891011121314public E set(int index, E element) &#123; //角标越界检查 rangeCheck(index); //下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法 E oldValue = elementData(index); //将 index 位置设置为新的元素 elementData[index] = element; // 返回之前在 index 位置的元素 return oldValue;&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 查询指定角标的元素123456public E get(int index) &#123; //越界检查 rangeCheck(index); //下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法 return elementData(index); &#125; 查询指定元素的角标或者集合是否包含某个元素12345678910111213141516171819202122232425262728293031323334353637//集合中是否包含元素 indexOf 返回 -1 表示不包含 return false 否则返回 truepublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/*** 返回集合中第一个与 o 元素相等的元素角标，返回 -1 表示集合中不存在这个元素* 这里还做了空元素直接判断 == 的操作*/public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 从 elementData 末尾开始遍历遍历数组，所以返回的是集合中最后一个与 o 相等的元素的角标*/public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; ArrayList 集合的 toArry 方法其实 Object[] toArray(); 方法，以及其重载函数 \ T[] toArray(T[] a); 是接口 Collection 的方法，ArrayList 实现了这两个方法，很少见ArrayList 源码分析的文章分析这两个方法，顾名思义这两个方法的是用来，将一个集合转为数组的方法，那么两者的不同之处是，后者可以指定数组的类型，前者返回为一个 Object[] 超类数组。那么我们具体下源码实现： 1234567891011121314public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 可以看到 Object[] toArray() 只是调用了一次 Arrays.copyOf() 将集合中元素拷贝到一个新的 Object[] 数组并返回。这个 Arrays.copyOf() 方法前边已经讲了。所以 toArray() 方法并没有什么疑问，有疑问的地方在于toArray(T[] a) 。 我们可以传入一个指定类型的标志数组作为参数，toArray(T[] a) 方法最终会返回这个类型的包含集合元素的新数组。但是源码判断了 ： 如果 a.length &lt; size 即当前集合元素的个数与参数 a 数组元素的大小的时候将和 toArray() 一样返回一个新的数组。 如果 a.length == size 将不会产生新的数组直接将集合中的元素调用 System.arraycopy() 方法将元素复制到参数数组中，返回 a。 a.length &gt; size 也不会产生新的数组,但是值得注意的是 a[size] = null; 这一句改变了原数组中 index = size 位置的元素，被重新设置为 null 了。 下面我们来看下第三种情况的例子： 12345678910111213141516171819202122232425SubClass[] sourceMore = new SubClass[4]; for (int i = 0; i &lt; sourceMore.length; i++) &#123; sourceMore[i] = new SubClass(i);&#125; //当 List.toArray(T[] a) 中 a.length == list.size 的时候使用 Array.copyOf 会将 list 中的内容赋值给 sourceMore 并将其返回//sourceMore[0,size-1] = list&#123;0, size-1&#125; 而 sourceMore[size] = nullSubClass[] sourceMore = new SubClass[4];for (int i = 0; i &lt; sourceMore.length; i++) &#123; sourceMore[i] = new SubClass(i);&#125;//list to Array 之前 sourceMore [SubClass&#123;test=0&#125;, SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;] sourceEqual.length:: 4System.out.println("list to Array 之前 sourceMore " + Arrays.toString(sourceMore) + " sourceEqual.length:: " + sourceMore.length);SubClass[] desSourceMore = tLists.toArray(sourceMore);//list to Array 之后 desSourceMore [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, null, SubClass&#123;test=3&#125;]desSourceMore.length:: 4System.out.println("list to Array 之后 desSourceMore " + Arrays.toString(desSourceMore) + "desSourceMore.length:: " + desSourceMore.length);//list to Array 之后 source [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, null, SubClass&#123;test=3&#125;]sourceEqual.length:: 4System.out.println("list to Array 之后 source " + Arrays.toString(sourceMore) + "sourceEqual.length:: " + sourceMore.length);//source == desSource trueSystem.out.println("source == desSource " + (sourceMore == desSourceMore)); ArrayList 的遍历ArrayList 的遍历方式 jdk 1.8 之前有三种 ：for 循环遍历， foreach 遍历，迭代器遍历,jdk 1.8 之后又引入了forEach 操作，我们先来看看迭代器的源码实现： 迭代器迭代器 Iterator 模式是用于遍历各种集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 ArrayList 作为集合类也不例外，迭代器本身只提供三个接口方法： 12345public interface Iterator &#123; boolean hasNext();//是否还有下一个元素 Object next();// 返回当前元素 可以理解为他相当于 fori 中 i 索引 void remove();// 移除一个当前的元素 也就是 next 元素。 &#125; ArrayList 中调用 iterator() 将会返回一个内部类对象 Itr 其实现了 Iterator 接口。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 下面让我们看下其实现的源码： 正如我们的 for 循环遍历一样，数组角标总是从 0 开始的，所以 cursor 初始值为 0 ， hasNext 表示是否遍历到数组末尾，即 i &lt; size 。对于 modCount 变量之所以一直没有介绍是因为他集合并发访问有关系，用于标记当前集合被修改（增删）的次数，如果并发访问了集合那么将会导致这个 modCount 的变化，在遍历过程中不正确的操作集合将会抛出 ConcurrentModificationException ，这是 Java 「fast-fail 的机制」，对于如果正确的在遍历过程中操作集合稍后会有说明。 12345678private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 对照 hasNext 方法 cursor 应理解为下个调用 next 返回的元素 初始为 0 int lastRet = -1; // 上一个返回的角标 int expectedModCount = modCount;//初始化的时候将其赋值为当前集合中的操作数， // 是否还有下一个元素 cursor == size 表示当前集合已经遍历完了 所以只有当 cursor 不等于 size 的时候 才会有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; next 方法是我们获取集合中元素的方法，next 返回当前遍历位置的元素，如果在调用 next 之前集合被修改，并且迭代器中的期望操作数并没有改变，将会引发ConcurrentModificationException。next 方法多次调用 checkForComodification 来检验这个条件是否成立。 1234567891011121314151617@SuppressWarnings("unchecked") public E next() &#123; // 验证期望的操作数与当前集合中的操作数是否相同 如果不同将会抛出异常 checkForComodification(); // 如果迭代器的索引已经大于集合中元素的个数则抛出异常，这里不抛出角标越界 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 由于多线程的问题这里再次判断是否越界，如果有异步线程修改了List（增删）这里就可能产生异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // cursor 移动 cursor = i + 1; //最终返回 集合中对应位置的元素，并将 lastRet 赋值为已经访问的元素的下标 return (E) elementData[lastRet = i]; &#125; 只有 Iterator 的 remove 方法会在调用集合的 remove 之后让 期望 操作数改变使expectedModCount与 modCount 再相等，所以是安全的。 12345678910111213141516171819202122// 实质调用了集合的 remove 方法移除元素public void remove() &#123; // 比如操作者没有调用 next 方法就调用了 remove 操作，lastRet 等于 -1的时候抛异常 if (lastRet &lt; 0) throw new IllegalStateException(); //检查操作数 checkForComodification(); try &#123; //移除上次调用 next 访问的元素 ArrayList.this.remove(lastRet); // 集合中少了一个元素，所以 cursor 向前移动一个位置（调用 next 时候 cursor = lastRet + 1） cursor = lastRet; //删除元素后赋值-1，确保先前 remove 时候的判断 lastRet = -1; //修改操作数期望值， modCount 在调用集合的 remove 的时候被修改过了。 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; // 集合的 remove 会有可能抛出 rangeCheck 异常，catch 掉统一抛出 ConcurrentModificationException throw new ConcurrentModificationException(); &#125; &#125; 检查期望的操作数与当前集合的操作数是否相同。Java8 发布了很多函数式编程的特性包括 lamada 和Stream 操作。迭代器也因此添加了 forEachRemaining 方法，这个方法可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。 1234567891011 @Override @SuppressWarnings("unchecked")public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; //... Java8 的新特性，可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。 &#125; // 检查期望的操作数与当前集合的操作数是否相同 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; ListIterator 迭代器ArrayList 可以通过以下两种方式获取 ListIterator 迭代器，区别在于初始角标的位置。不带参数的迭代器默认的cursor = 0 123456789public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index);&#125; public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; ListItr对象继承自前边分析的 Itr，也就是说他拥有 Itr 的所有方法，并在此基础上进行扩展，其扩展了访问当前角标前一个元素的方法。以及在遍历过程中添加元素和修改元素的方法。 ListItr 的构造方法如下： 12345private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index;&#125; ListItr 的 previous 方法： 123456789101112131415161718192021222324252627282930public boolean hasPrevious() &#123; // cursor = 0 表示游标在数组第一个元素的左边，此时 `hasPrevious` 返回false return cursor != 0;&#125;public int nextIndex() &#123; return cursor;//调用返回当前角标位置&#125;public int previousIndex() &#123; return cursor - 1;//调用返回上一个角标&#125;//返回当前角标的上一个元素，并前移移动角标@SuppressWarnings("unchecked")public E previous() &#123; // fast-fail 检查 checkForComodification(); int i = cursor - 1; // 如果前移角标 &lt;0 代表遍历到数组遍历完成，一般在调用 previous 要调用 hasPrevious 判断 if (i &lt; 0) throw new NoSuchElementException(); //获取元素 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //获取成功后修改角标位置和 lastRet 位置 cursor = i; return (E) elementData[lastRet = i];&#125; ListItr 的 add 方法 1234567891011121314151617public void add(E e) &#123; // fast-fail 检查 checkForComodification(); try &#123; // 获取当前角标位置，一般的是调用 previous 后，角标改变后后去 cursor int i = cursor; //添加元素在角标位置 ArrayList.this.add(i, e); //集合修改完成后要改变当前角标位置 cursor = i + 1; //重新置位 -1 如果使用迭代器修改了角标位置元素后不允许立刻使用 set 方法修改修改后角标未知的额元素 参考 set 的源代码 lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 可能对比两个迭代器后，会对 curor 指向的位置有所疑惑，现在我们来看下一段示例代码对应的图： 1234567891011121314151617181920private void testListItr()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); ListIterator&lt;Integer&gt; listIterator = list.listIterator(list.size()); while (listIterator.hasPrevious())&#123; if (listIterator.previous() == 2)&#123; listIterator.add(0); // listIterator.set(10); //Exception in thread "main" java.lang.IllegalStateException &#125; &#125; System.out.println("list " + list.toString());&#125; 由此可以看 cursor 于 数组角标不同，它可以处的位置总比角标多一个，因为在我们使用 Iterator 操作集合的时候，总是要先操作 cursor 移动， listIterator.previous 也好 iterator.next() 也好，都是一样的道理，如果不按照规定去进行操作，带给使用者的只有异常。 java8 新增加的遍历方法 forEachjava8增加很多好用的 API，工作和学习中也在慢慢接触这些 API，forEach 操作可能是我继 lambda 后，第一个使用的 API 了（囧），jdk doc 对这个方法的解释是： 对此集合的每个条目执行给定操作，直到处理完所有条目或操作抛出异常为止。 除非实现类另有规定，否则按照条目集迭代的顺序执行操作（如果指定了迭代顺序）。操作抛出的异常需要调用者自己处理。 其实其内部实现也很简单，只是一个判断了操作数的 for 循环，所以在效率上不会有提升，但是在安全性上的确有提升，也少些很多代码不是么？ 1234567891011121314151617@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; //检查调用者传进来的操作函数是否为空 Objects.requireNonNull(action); //与迭代不同期望操作被赋值为 final 也就是 forEach 过程中不允许并发修改集合否则会抛出异常 final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; //每次取元素之前判断操作数，确保操作正常 for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 对于高级 for 循环以及最普通的 fori 方法这里不再赘述。下面我们看下面试会问到一个问题，也是我们在单线程操作集合的时候需要注意的一个问题，如果正确的在遍历过程中修改集合。 错误操作 1 在 for循环修改集合后继续遍历第一个例子： 1234567891011121314List&lt;SubClass&gt; list2 = new ArrayList&lt;&gt;();list2.add(new SubClass(1));list2.add(new SubClass(2));list2.add(new SubClass(3));list2.add(new SubClass(3));for (int i = 0; i &lt; list2.size(); i++) &#123; if (list2.get(i).test == 3) &#123; list2.remove(i); &#125;&#125;System.out.println(list2);//[SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;] 这个例子我们会发现，程序并没有抛出异常，但是从运行经过上来看并不是我们想要的，因为还有 SubClass.test = 3的数据在，这是因为 remove 操作改变了list.size(),而 fori 中每次执行都会重新调用一次lists2.size()，当我们删除了倒数第二个元素后，list2.size() = 3,i = 3 &lt; 3 不成立则没有在进行 remove 操作，知道了为什么以后我们试着这样改变了循环方式： 123456789int size = list2.size();for (int i = 0; i &lt; size; i++) &#123; if (list2.get(i).test == 3) &#123; list2.remove(i);//remove 以后 list 内部将 size 重新改变了 for 循环下次调用的时候可能就不进去了 &#125;&#125;System.out.println(list2);//Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 果真程序抛出了角标越界的异常，因为这样每次 fori 的时候我们不去拿更新后的 list 元素的 size 大小，所以当我们删除一个元素后，size = 3 当我们 for 循环去list2.get(3)的时候就会被 rangeCheck方法抛出异常。 错误操作导致 ConcurrentModificationException 异常我们分析迭代器的时候，知道 ConcurrentModificationException是指因为迭代器调用 checkForComodification 方法比较 modCount 和 expectedModCount 方法大小的时候抛出异常。我们在分析 ArrayList 的时候在每次对集合进行修改， 即有 add 和 remove 操作的时候每次都会对 modCount ++。 modCount 这个变量主要用来记录 ArrayList 被修改的次数，那么为什么要记录这个次数呢？是为了防止多线程对同一集合进行修改产生错误，记录了这个变量，在对 ArrayList 进行迭代的过程中我们能很快的发现这个变量是否被修改过，如果被修改了 ConcurrentModificationException 将会产生。下面我们来看下例子，这个例子并不是在多线程下的，而是因为我们在同一线程中对 list 进行了错误操作导致的： 12345678910111213Iterator&lt;SubClass&gt; iterator = lists.iterator();while (iterator.hasNext()) &#123; SubClass next = iterator.next(); int index = next.test; if (index == 3) &#123; list2.remove(index);//操作1： 注意是 list2.remove 操作 //iterator.remove()；/操作2 注意是 iterator.remove 操作 &#125;&#125;//操作1： Exception in thread "main" java.util.ConcurrentModificationException//操作2： [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;]System.out.println(list2); 我们对操作1，2分别运行程序，可以看到，操作1很快就抛出了 java.util.ConcurrentModificationException 异常，操作2 则顺利运行出正常结果，如果对 modCount 注意了的话，我们很容易理解，list.remove(index) 操作会修改List 的 modCount，而 iterator.next() 内部每次会检验 expectedModCount != modCount，所以当我们使用 list.remove 下一次再调用 iterator.next() 就会报错了，而iterator.remove为什么是安全的呢？因为其操作内部会在调用 list.remove 后重新将新的 modCount 赋值给 expectedModCount。所以我们直接调用 list.remove 操作是错误的。对于多线程的影响这里不在展开这里推荐有兴趣的朋友看下这个文章 Java ConcurrentModificationException异常原因和解决方法; 经过了一轮分析我们我们知道了错误产生原因了，但是大家是否能真的分辨出什么操作是错误的呢？我们来看下边这个面试题，这是我在网上无意中看到的一道大众点评的面试题： 123456789101112ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add("sh" + i);&#125;for (int i = 0; list.iterator().hasNext(); i++) &#123; //是在这里会报错，而不是下一行 // 因为size最后还是5，而每次循环都会new一个迭代器出来，其cursor从0开始，即只要size != 0，循环就不会跳出 // 最后size == 5，list.remove(5)越界：IndexOutOfBoundsException list.remove(i); System.out.println("秘密" + list.get(i));&#125; 一道面试题相信大家肯定知道这样操作是会产生错误的，但是最终会抛出角标越界还是ConcurrentModificationException呢？ 其实这里会抛出角标越界异常，为什么呢，因为 for 循环的条件 list.iterator().hasNext()，我们知道 list.iterator() 将会new 一个新的 iterator 对象，而在 new 的过程中我们将 每次 list.remove 后的 modCount 赋值给了新的 iterator 的 expectedModCount，所以不会抛出 ConcurrentModificationException 异常，而 hasNext 内部只判断了 size 是否等于 cursor != size 当我们删除了一半元素以后，size 变成了 5 而新的 list.iterator() 的 cursor 等于 0 ，0!=5 for 循环继续，那么当执行到 list.remove（5）的时候就会抛出角标越界了。 总结 ArrayList 底层是一个动态扩容的数组结构,每次扩容需要增加1.5倍的容量 ArrayList 扩容底层是通过 Arrays.CopyOf 和 System.arraycopy 来实现的。每次都会产生新的数组，和数组中内容的拷贝，所以会耗费性能，所以在多增删的操作的情况可优先考虑 LinkList 而不是 ArrayList。 ArrayList 的 toArray 方法重载方法的使用。 允许存放（不止一个） null 元素， 允许存放重复数据，存储顺序按照元素的添加顺序 ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类. 不正确访问集合元素的时候 ConcurrentModificationException和 java.lang.IndexOutOfBoundsException 异常产生的时机和原理。 本文又长篇大论的分析了一波 ArrayList 的源码，对我个人而言这很有意义，在查看源码的过程中，注意到了平时很少有机会接触的知识点。当然这只是集合源码分析的开端，以后还会更细，其他常用集合源码的分析。如果大家感觉我写的还可以， 请留言 + 点赞 + 关注。 转载：搞懂 Java ArrayList 源码 LinkedList先吐槽一下，感觉LinkedList源码真的很简单啊哈哈哈哈哈，总共也才1000来行代码…而且连个扩容都没有，基本上就是对双向链表的一顿操作，所以它是为了凑代码量所以顺带利用双向链表的性质实现一下双向队列嘛…算了，还是耐着性质稍微分析一下吧…（就是尼玛方法有点多，名字我都看晕啦…） 话说回来，这些里面的函数就是 对双向链表做某些操作的标准答案吖！里面写的代码都挺优美的！可以欣赏一哈~ 算了……我懒得分析了，直接丢个链接吧…… 搞懂 JAVA LinkedList 源码 注意点 继承自 AbstrackSequentialList 并实现了 List 接口以及 Deque 双向队列接口，因此 LinkedList 不但拥有 List 相关的操作方法，也有队列的相关操作方法。 LinkedList 集合底层实现的数据结构为双向链表 LinkedList 集合中元素允许为 null LinkedList 允许存入重复的数据 LinkedList 中元素存放顺序为存入顺序。 LinkedList 是非线程安全的，如果想保证线程安全的前提下操作 LinkedList，可以使用 List list = Collections.synchronizedList(new LinkedList(...)); 来生成一个线程安全的 LinkedList 实现List，利用了其是两个单链表组成的，实现Deque，利用其是双向链表的性质，注意哈，Deque既可以当队列也可以当栈，所以队列和栈的方法LinkedList全有。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; //从头部插入（抛异常） void addFirst(E e); //从尾部插入（抛异常） void addLast(E e); //从头部插入（特殊值） boolean offerFirst(E e); //从尾部插入（特殊值） boolean offerLast(E e); //从头部移除（抛异常） E removeFirst(); //从尾部移除（抛异常） E removeLast(); //从头部移除（特殊值） E pollFirst(); //从尾部移除（特殊值） E pollLast(); //从头部查询（抛异常） E getFirst(); //从尾部查询（抛异常） E getLast(); //从头部查询（特殊值） E peekFirst(); //从尾部查询（特殊值） E peekLast(); //（从头到尾遍历列表时，移除列表中第一次出现的指定元素） boolean removeFirstOccurrence(Object o); //（从头到尾遍历列表时，移除列表中最后一次出现的指定元素） boolean removeLastOccurrence(Object o); //都没啥难度，不解释了 boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); void push(E e); E pop(); boolean remove(Object o); boolean contains(Object o); public int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator();&#125; Vector简而言之，Vector 与 ArrayList 之间的关系，就是 HashMap 和 HashTable 之间的关系，Vector 的方法基本上都是 ArrayList 的方法 加个 synchronized 关键字组成的，这边讲下它与 ArrayList 的不同，就可以结束了！ 不同点有： Vector 线程安全，是同步的；ArrayList 非线程安全，非同步的 扩容策略不同，ArrayList 扩容是变成原来的 1.5 倍，而 Vector 和 ArrayDeque 扩容一样，都是变为原来的两倍 Vector 可以使用 Enumeration 和 Iterator 进行元素遍历，ArrayList 只提供了 Iterator 的方式 由于使用的线程同步，Vector 的效率比 ArrayList 低，但是 jdk8 之后，由于对 synchronized 的关键字的优化，引入了 偏向锁 等轻量级锁之后， Vector 和 ArrayList 的性能差异已经不大了 Queue没啥好分析的，实现这个接口的，接触的比较多的也就是 PriorityQueue、ArrayDeque。 直接放链接： Java集合（七） Queue详解 Java集合ArrayDeque类解读 死磕 java集合之ArrayDeque源码分析 注意点就其实现而言，ArrayDeque采用了循环数组的方式来完成双端队列的功能。 无限的扩展，自动扩展队列大小的。（当然在不会内存溢出的情况下） 非线程安全的，不支持并发访问和修改。 支持fast-fail。 作为栈使用的话比比栈要快。 当队列使用比 LinkedList 要快。 null元素被禁止使用，这个跟 ArrayList 和 LinkedList 也不一样 初始值跟 ArrayList 不一样，这里的初始值是 16，扩容也是直接扩容两倍，跟 ArrayList 的 1.5 倍不一样，扩容的时候利用了容量是2次幂这个性质，跟 HashMap 一样，直接与 length 相与即可。]]></content>
      <categories>
        <category>程序猿</category>
        <category>集合类源码分析</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA对数组的四种拷贝方式]]></title>
    <url>%2F2019%2F10%2F07%2FJAVA%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[数组拷贝的四种方式 for clone System.arraycopy arrays.copyof 赋值、浅拷贝、深拷贝在谈及四种数组拷贝方式之前，先来缕缕赋值、浅拷贝、深拷贝三者的关系和区别。 数据类型谈及深拷贝和浅拷贝，首先要弄清数据类型有哪些,数据分为基本数据类型(元数据)和引用数据类型(对象引用)。 基本数据类型的特点：直接存储在栈(stack)中的数据 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝和浅拷贝 深拷贝和浅拷贝是只针对引用类型的数据而言的，对于基本数据类型来说，深拷贝和浅拷贝都是直接进行值传递的，与赋值的方式是一样的，三者没有任何区别，区别就在于对于引用数据类型来说，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存,所以如果修改对象的话会互相影响。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 总而言之，在数组内都是基本数据类型时，是不会有深拷贝和浅拷贝这样的概念出现的，只有出现了引用类型的数据，才能谈深拷贝和浅拷贝。Tips: String不是基本数据类型，但是在深复制的时候并没有进行单独的复制，也就是说违反了深复制，仅仅复制了引用，而String没有实现cloneable接口，也就是说只能复制引用。 那么在修改克隆之后的对象之后，会不会将原来的值也改变了? 答案肯定是不会改变，因为String是在内存中不可以被改变的对象，就比如说在for大量循环中不推荐使用+的方式来拼凑字符串一样，每次使用都会新分配一块内存，不在原来上修改，原来的没有指向它的引用，会被回收。所以克隆相当于1个String内存空间有两个引用，当修改其中的一个值的时候，会新分配一块内存用来保存新的值，这个引用指向新的内存空间，原来的String因为还存在指向他的引用，所以不会被回收，这样，虽然是复制的引用，但是修改值的时候，并没有改变被复制对象的值。 数组拷贝方式之一——for()就是for循环咯！！！ 12345/** 1 for 循环拷贝*/int[] arr1 = new int[len];for (int i = 0; i &lt; len; i++) &#123; arr1[i] = arr0[i];&#125; 也是浅拷贝咯！ 数组拷贝方式之二——clone()（主要参考）细说 Java 的深拷贝和浅拷贝 在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。 首先需要说明的是，clone()是浅拷贝的方式！！！其次，我们应该如何实现深拷贝呢，有两种方法： 用多层浅拷贝达到深拷贝的目的，要知道，浅拷贝和深拷贝的区别就是在处理对象引用时，浅拷贝不会创造新的对象，而深拷贝会，但是如果一个对象的属性变成了基本类型数据，那么浅拷贝同样会创造新的对象，所以说，多层浅拷贝就能达到深拷贝的目的，例如：在对fatherClass和childClass进行两级浅拷贝之后，fatherB就有浅拷贝变成了深拷贝，因为此时基本数据类型和Child对象都是指向不同的地址的，也就是二者都是不同的对象，所以就是达到了深拷贝的目的了。 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。总结下来就是做了5件事： 确保对象图中的所有类都是可序列化的 创建输入输出流 使用这个输入输出流来创建对象输入和对象输出流 将你想要拷贝的对象传递给对象输出流 从对象输入流中读取新的对象并且转换回你所发送的对象的类 最后，推一个序列化实现深拷贝的例子：序列化的方式使得其变为深拷贝 数组拷贝方式之三——System.arraycopy()native方法，依旧是一个浅拷贝——–&gt; 详细传送门 数组拷贝方式之四——arrays.copyof()1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 你看看，底层也在用System.arraycopy()这个native方法，所以就不再赘述了，这个在ArrayList源码分析中也有涉及哦！！！！]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Array</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.2----10.7收获]]></title>
    <url>%2F2019%2F10%2F02%2F10-2-10-7.html</url>
    <content type="text"><![CDATA[10.2 学习完ajax异步调用； 完成添加然后数据库里有数据并且能正常跳转； b站上再看看springboot+mybatis的结合； 总结博客，分别总结分页排序还要mongodb在springboot中的相关操作； 收获 springboot启动很慢的原因：未修改host目录的文件，导致每次启动都很慢。步骤 在terminal终端输入: 1$ hostname 复制下来，然后修改host文件中的localhost： 1$ sudo vim /etc/hosts 然后将自己hostname替换掉localhost 123127.0.0.1&lt;两个tab&gt;localhost 替换为$hostname255.255.255.255&lt;两个tab&gt;broadcasthost::1&lt;两个tab&gt;localhost 替换为$hostname 在js传值给controller时，一直不能将json数据传过去，原因是没有给data的值加上JSON.stringify()处理，具体错误：springboot 接收参数，解析json出现错误：was expecting ‘null’, ‘true’, ‘false’ or NaN解决方案：见—-&gt;js与controller之间传值常见问题 JQuery.ajaxajax和springboot传值 jquery中字符串转日期，日期转字符串 MyBatis主键回填策略 表中部分属性自动生成，不需要额外传入参数 先是尝试了在bean中加@value，加载配置文件中的随机数，但是发现执行一次，随机数是唯一的，这样就不能做到插入一条数据，随机数就变化； 后面发现可以在mybatis直接配置结果集，好像也不行…因为如果你用结果集将id转换为taskId,那原本bean中的id属性就会取不到值… jQuery获取html中的值获取html中的值 10.3收获使用最大的id！！！mysql插入数据后返回自增ID的方法（AUTO_INCREMENT） 10.4收获 复杂json转成多层map 12345678910111213141516171819public Map&lt;String, Object&gt; parseJSON2Map(@RequestBody String jsonStr)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); JSONObject json = JSONObject.parseObject(jsonStr); for(Object k : json.keySet())&#123; Object v = json.get(k); if(v instanceof JSONArray)&#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Iterator it = ((JSONArray)v).iterator(); while(it.hasNext())&#123; Object json2 = it.next(); list.add(parseJSON2Map(json2.toString())); &#125; map.put(k.toString(), list); &#125; else &#123; map.put(k.toString(), v); &#125; &#125; return map; &#125; mac强制刷新缓存：command + shift + R普通刷新：command + R Springboot使用多线程 最近遇到一个需求，就是当服务器接到请求并不需要任务执行完成才返回结果，可以立即返回结果，让任务异步的去执行。开始考虑是直接启一个新的线程去执行任务或者把任务提交到一个线程池去执行，这两种方法都是可以的。但是 Spring 这么强大，肯定有什么更简单的方法，就 google 了一下，还真有呢。就是使用 @EnableAsync 和 @Async 这两个注解就 ok 了。传送门：SpringBoot非官方教程 | 第二十三篇： 异步方法 首先声明一下自己用了比较长的时间才弄出来的原因是，自己把异步方法写到了Controller层，导致在controller的另一个方法调用时无法开启异步功能，所以对此我有三点见解： 在@SpringBootApplication启动类 添加注解@EnableAsync 异步方法使用注解@Async ,返回值为void或者Future 切记一点，异步方法和调用方法一定要 写在不同的类中,如果写在一个类中，是没有效果的，至于为什么—-&gt;因为Spring像@Transaction @Async等这些都是使用了动态代理，Spring容器在初始化的时候就会将含有AOP注解的类对象替换为代理对象，再由Proxy对象去调用被增强方法，重点来了：方法里想用增强方法(第三点)则需要得到当前的Proxy对象，但如果是同一个类的话，是不会经过spring容器的，此时是真正的对象本身去调用方法，并不是代理对象，这样的话被增强方法就失效了，详情请看 -&gt;Spring的 AopContext.currentProxy()方法 解决方案 我采用的方案是，将异步方法写入service层，然后再controller层中调用，这样就经过了spring容器，调用方法时就是采用的代理对象。 第二种方法，我没有成功！！！！真的是气的不行，因为我看网上博客别人都成功了……就是用AopContext.currentProxy()这个方法,步骤为： 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类中添加注释 1@EnableAspectJAutoProxy(exposeProxy=true,proxyTargetClass=true) 然后在调用方法处写： 1((TaskController)AopContext.currentProxy()).testAsy("www.baidu.com"); 按理说应该可以了的，结果吧，我一跑程序就报错，说我的哦代理怎么没暴露啊，我真是卧槽了，那他妈不是已经配置了暴露了嘛！！！我服了！！！算了，懒得搭理了…甩个跟这个原理一样的链接，学习一下：JDK动态代理给Spring事务埋下的坑！再甩一个链接，三种方法配置这个exposeProxy(然而我一个都没成功…)—-&gt;springboot中如何配置aop动态代理模式 (原创)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-9-26]]></title>
    <url>%2F2019%2F09%2F26%2F2019-9-26.html</url>
    <content type="text"><![CDATA[今日任务 springboot + mongodb,完成mongo在springboot中的搭建，写一个小demo 最主要的是把repository这一层写完，业务逻辑可以放到明天来写 完成过程mongodb的安装macOS下mongodb的安装与启动 Springboot下的相关注解 @DataData注解使用 @Document标注在实体类上，类似于hibernate的entity注解，标明由mongo来维护该表，collection代表表的名称。SpringBoot中MongoDB中的相关注解 @Entity等一系列Spring Data JPA注解 @DynamicUpdate、@DynamicInsert 是hibernate里面的注解，这两个注解加上之后就不会为字段值不变的字段生成sql语句，这样sql的长度就减少了提高了传输效率和执行效率，在插入和修改数据的时候,语句中只包括要插入或者修改的字段。 @Entity 标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表~！ GeneratedValue、GenericGenerator是用于主键生成策略的，具体见JPA注解主键生成策略-UUID @Column（name = “自定义字段名”，length = “自定义长度”，nullable = “是否可以空”，unique = “是否唯一”，columnDefinition = “自定义该字段的类型和长度”）。表示对这个变量所对应的字段名进行一些个性化的设置，例如字段的名字，字段的长度，是否为空和是否唯一等等设置。 剩余注释：Spring Data JPA中常用的注解详解 @Controller（Spring Boot之 Controller 接收参数和返回数据总结(包括上传、下载文件)）Controller层的注解大概有以下一些：（主要参考：Controller层主要注解） @Controller:标注 Controller 类，处理 http 请求 @RestController:标注 Controller 类，spring 4 新加注解，相当于@Controller + @ResponseBody ，主要是为了使 http 请求返回数据格式为 json 格式，正常情况下都是使用这个注解 @RequestMapping:配置 url 映射，可以作用于类上，也可以在方法上 123456789@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.GET) public String say() &#123; return "我是张少林"; &#125;&#125; @RequestMapping 定义在类上，指定该类下的所有接口 url 映射在 /users 下，定义在方法上，指定 请求方法，可以指定GET，POST，DELETE，PUT四种标准的 Restfulapi请求方法。那么此时的接口 url 为：http://127.0.0.1:8080/users/myInfo 请求方法：GET，类上也可以不用配置 url 映射的。 @PathVariable获取 url 中的数据，我们在 url 中拼接一个字符串 {username}，类似于地址占位符，由用户请求时添加，请求获取。注意注解中的参数必须与占位符参数一致 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo/&#123;username&#125;", method = RequestMethod.GET) public String say(@PathVariable("username") String username) &#123; return username; &#125;&#125; @RequestParam获取请求参数值，方法随意可以设置，但是通常需求都是使用 POST 请求处理表单提交。 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username") String username, @RequestParam(value = "password") String password) &#123; return username + password; &#125;&#125; 假如用户输入的的uri是:http://127.0.0.1:8080/users/myInfo?username=yangweijie&amp;password=123456，那么最后返回的是yangweijie123456，如果参数不带值且添加属性required=true，则会报错，此时就建议添加一个defaultValue属性： 12345678910@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username",required = false,defaultValue = "张少林") String username, @RequestParam(value = "password",required = false,defaultValue = "123456") String password) &#123; return username + password; &#125;&#125; @GetMapping、@PostMapping、@DeleteMapping、@PutMapping等是RequestMapping的组合注解，根据method的不同。 @RequestHeader可以把Request请求header部分的值绑定到方法的参数上。 @CookieValue可以把Request header中关于cookie的值绑定到方法的参数上。 RequestBody该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; ModelAttribute(参考：Spring MVC @ModelAttribute详解)@ModelAttribute有三种用法： 可以标注在方法上； 可以标注在方法中的参数上； 还可以和@RequestMapping一起标注在方法上；目的都是在RequestMapping之前进行model属性的注入，对RestController好像没用，因为是返回json数据，并不能将model里面的数据直接返回给页面。如果没用@RestController，则@ModelAttribute方法通常被用来填充一些公共需要的属性或数据，比如一个下拉列表所预设的几种状态，或者宠物的几种类型，或者去取得一个HTML表单渲染所需要的命令对象，比如Account等。@ModelAttribute标注方法有两种风格： 12345678910111213141516// Add one attribute// The return value of the method is added to the model under the name "account"// You can customize the name via @ModelAttribute("myAccount")@ModelAttributepublic Account addAccount(@RequestParam String number) &#123; return accountManager.findAccount(number);&#125;// Add multiple attributes@ModelAttributepublic void populateModel(@RequestParam String number, Model model) &#123; model.addAttribute(accountManager.findAccount(number)); // add more ... &#125; 在第一种写法中，方法通过返回值的方式默认地将添加一个属性，在第二种写法中，方法接收一个Model对象，然后可以向其中添加任意数量的属性，可以在根据需要，在两种风格中选择合适的一种。model里的数据会被放入到request中,页面通过request域可以获取到。 @SessionAttributes和@SessionAttribute@SessionAttributes注解的使用就是将属性放入session域内，然后可以在session域内进行相关的操作。 SpringMVC中@ModelAttribute和@SessionAttributes注解的使用 @id（好像如果表中数据字段是id，会比较特殊一点，springboot会自动检索传过来的参数是否有id，如果没有会自动添加id） Repository相关注解 Springboot的分页和排序操作由于采用的是Mongo数据库，所以先后使用了MongoTemplate()和MongoRepository(),MongoTemplate在写法上比MongoRepository 更复杂一些，但是带来更多的灵活性。对于复杂的查询操作，我们一般使用MongoTemplate，对于一些简单的查询我们会使用MongoRepository 。可以这么理解，MongoRepository 只是作为一种对于简单查询的简便操作，而MongoTemplate才是我们在做一些复杂查询时的首选。 MongoRepository自己还借用了下@Query和@Modifying注解，方便自己摆脱关键字的查询，如果需要进行更新或者删除数据，则需要在@Query之上加上@Modifing。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度前端技术学院66天学习(争取一个月内完成！)]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A266%E5%A4%A9%E5%AD%A6%E4%B9%A0-%E4%BA%89%E5%8F%96%E4%B8%80%E4%B8%AA%E6%9C%88%E5%86%85%E5%AE%8C%E6%88%90%EF%BC%81.html</url>
    <content type="text"><![CDATA[day 1:日期，今天的学习总用时，今天学习的目标是什么，是否达成 今天是2019.9.20，距离春招还有将近6个月的时间，预计1个半月将ife学完并且将js看完，后期开始刷leetcode和vue框架的学习 今天的学习时长总用时为30min 今天的学习目标是搭建好前端环境，做好长期准备学习的过程 目标已达成，将以博客的形式每天更新自己所学内容 哪些东西今天了解得比较透彻，说说自己的理解今天最大的收获是看到了许多非常极具创意的web，也激励自己能够更好的学习前端知识，希望半年后的自己能有一个大大的成长吧！！！ 哪些东西今天了解到了一些，还有哪些点需要后续继续深入阅读今天的内容好像没有什么难的，项目也比较忙，最近在看js，大概看完了前面4章了，后续尽量加快一些进度 哪些东西今天学了之后还有很多疑问没有被解答，把问题记录下来，以待后续解决今天暂无 立Flag，写下大家参加今年前端学院的目标找到一份好实习，找到一份好工作，成为更好的自己 day 2：问题： 这里面的可枚举属性名不知道啥意思； 个人暂时理解：就是是否可遍历的意思 对这个Object.prototype不熟悉！！！ day 3：问题： 图中为什么用Object.defineProperty()就可以完成对writable:false的属性的修改，但是直接用obj.属性的形式就不行？图中所谓的原型链又是什么意思？ 图中的JSON.stringify方法没有接触]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>ife</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习]]></title>
    <url>%2F2019%2F09%2F21%2FJS%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[学习过程：promise—&gt;箭头函数—&gt;作用域—&gt;闭包 js基础入门篇基本语法变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。其中，函数名同样被视为变量名，所以一样会被提升到代码头部。 标识符 不能以数字开头，可以以 _ 和 $ 开头 JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 标签js允许语句前面可以带有标签，方便跳出块区域和多重循环，常与for循环、continue、break连用。 数据类型##null，布尔值 boolean如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN “”或’’（空字符串） 注意，{}和[]都是true。 数值 js中所有数都是小数，64位，其中符号位1位，表示指数的11位，剩余的52位表示精度，但是由于表示精度的最高位1.xxxx中的1被省略，所以可以表示53位精度； parseInt即将字符串转换为整数型，不管是不是字符串，都会先转换为字符串,再转为整数型，其中，parseInt可以传入两个参数，第二个参数可以是转换进制值； 字符串 想输出多行字符串，有一种利用多行注释的变通方法 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" Base64转码 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // "SGVsbG8gV29ybGQh"atob('SGVsbG8gV29ybGQh') // "Hello World!" * 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好" 对象 对象的引用两个变量同时指向同一个对象，其中任何一个变量添加属性，另一个变量都可以读写该属性，但是如果取消某个变量对于原对象的引用，并不会影响到另一个变量；注意:仅限于对象，如果两个变量同时指向同一个原始类型的值，那么变量此时都是值的拷贝而已； 如果行首是一个大括号，js引擎一律将其解释为代码块，如果想要表示为对象，则必须在大括号前加上一个圆括号，这种差异在eval语句（作用是对字符串求值）中体现的尤为明显； 12eval('&#123;foo: 123&#125;') // 123eval('(&#123;foo: 123&#125;)') // &#123;foo: 123&#125; 属性读取：一种使用点运算符，另外一种采用方括号运算符，注意若使用方括号运算符，键名必须放在引号里面，否则会被当做变量处理： 123456789var foo = 'bar';var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 查看一个对象本身所有属性，可以使用Object.keys方法 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// ['key1', 'key2'] 属性的遍历：for…in 循环: 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 with语句：作用是操作同一个对象的多个属性时，提供方便，但是不建议使用，因为在with语句里面没有改变作用域，导致绑定对象不明确，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 函数函数声明 function命令 123function print(s)&#123; console.log(s);&#125; 函数表达式(如果function后带函数名，函数名也只在函数体内部有效) 1var print = function()&#123;console.log(s)&#125;; Function构造函数 12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数ToString可以解析注释实现多行字符串： 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split('\n'); return arr.slice(1, arr.length - 1).join('\n');&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// " 这是一个// 多行注释" 函数作用域在ES6中，有三种作用域：全局作用域、块作用域、函数作用域。函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。所以说，如果函数A调用函数B,函数B不会引用函数A的内容。 参数传值 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递； 函数参数如果是复合类型的值（数组、对象、其他函数），传递方式是传址传递； 函数内部修改的如果是参数对象的某个属性，那么会影响到原始值，如果是替换掉整个参数，则不会影响到原始值： 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] arguments arguments对象包含了函数运行时的所有参数，但是它并不是一个数组，而是一个对象，所以它不能用数组中的slice和forEach方法； 在正常模式下，arguments对象可以在运行时修改，但是在严格模式下，修改arguments对象的值并不会改变真实参数的值； 如果要让arguments对象使用数组方法，真正的解决办法就是让arguments对象变为数组，常用的转换方法有两种，分别是slice方法和逐一填入新数组： 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 闭包闭包，简而言之就是函数中的函数，闭包最大的特点，就是它可以“记住”诞生的环境，用处有三个： 1. 可以读取函数内部的变量； 2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在; 3. 封装对象的私有属性和私有方法。 123456789101112131415161718192021222324252627282930313233function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7``` ```jsfunction Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 “立即调用的函数表达式”（Immediately-Invoked Function Expression）123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 eval 本质是在当前域中注入代码，可以接受一个字符串作为参数，并且将该字符串当做语句执行，如果识别不是字符串，则会原样返回。 同时，eval没有自己的作用域，会改变当前域原有变量的值，当然在严格模式下，eval内部自己声明的变量有自己的作用域，不会影响到外部作用域的值。 由于引擎无法分辨eval的别名调用，所以在eval使用别名时，一律都是全局作用域。 数组数组遍历 数组遍历可以考虑使用for循环、while循环、forEach循环，会返回键值（键名为整数），for…in…循环会同时遍历非整数键（返回的是键名）； 数组遍历空位时，需要格外注意，空位和undefined是不一样的，空位表示数组中没有这个元素，所以在for…in…和forEach循环中不会被遍历到，但是undefined代表数组有这个元素，是会遍历到的； 运算符算术运算符加法运算符 对象的相加如果运算子是对象，必须先转成原始类型的值，引擎会自动调用obj.valueof().toString(),所以我们可以重新valueOf()和toString()方法即可，其中有个特例，当运算子是一个Date对象的实例，那么会优先执行toString方法。 指数运算符** 为指数运算符，是右结合的，当然，三元条件运算符也是右结合的，当然还有赋值运算符（=）也是右结合的。 比较运算符 严格相等运算符JavaScript 提供两种相等运算符：== 和 === 。简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。tip: undefined和null与自身严格相等布尔运算符略二进制位运算符略 其他运算符，运算顺序void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined，主要用途是浏览器的书签工具，以及在超链接中插入代码防止网页跳转。 语法专题错误处理机制原生错误类型 SyntaxError ReferenceError RangeError TypeError URIError EvalError 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象 1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了 1new UserError('这是自定义的错误！'); 标准库Object四个用法： Object本身就是一个函数，可以将任意值转换为对象； 不仅可以当做工具函数使用，还可以当做构造函数使用，即前面可以加new命令； 1注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = &#123;&#125;是等价的。或者说，后者只是前者的一种简便写法。 Object的静态方法，例如Object.print,指部署在Object对象自身的方法； Object的实例方法，即定义在Object.prototype对象上的方法。 Object.prototype.valueof() Object.prototype.toString() Object.prototype.toLocaleString() Object.prototype.hasOwnProperty() Object.prototype.isPrototypeof() Object.prototype.propertyIsEnumerable() 属性描述对象js提供了一个内部数据结构，用来描述对象的属性，比如是否可写可读可遍历，这个内部数据结构就称之为“属性描述对象”。 tip:Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。而这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 123456789101112Object.keys([]) // []Object.getOwnPropertyNames([]) // [ 'length' ]Object.keys(Object.prototype) // []Object.getOwnPropertyNames(Object.prototype)// ['hasOwnProperty',// 'valueOf',// 'constructor',// 'toLocaleString',// 'isPrototypeOf',// 'propertyIsEnumerable',// 'toString'] 上面代码中，数组自身的length属性是不可遍历的，Object.keys不会返回该属性。第二个例子的Object.prototype也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。 Object.defineProperty(),Object.defineProperties()Object.defineProperty()方法接收三个参数，依次如下： Object：属性所在的对象 propertyName:字符串，表示属性名 attributesObject:属性描述对象 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 Object.defineProperties()接收两个参数，如下： 123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" Object.prototype.propertyIsEnumerable()返回一个布尔值，用来判断自身属性是否可以遍历。Object.keys是返回所有可以遍历的属性，不包括继承的属性，而Object.getOwnPropertyNames则是返回包括继承的属性在内的所有可以遍历的属性。 es6入门len和const命令lenlen没有变量提升必须先声明后才能使用，注意len变量只在块区域内有用，是块级作用域，而var不同，var具有全局作用域、函数作用域； 暂时性死区123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。非常隐蔽的“死区”： 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。但在ES6中，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined node js入门]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Microsoft Remote Desktop for mac 和 Spark邮箱]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BD%BF%E7%94%A8Microsoft-Remote-Desktop-for-mac-%E5%92%8C-Spark%E9%82%AE%E7%AE%B1.html</url>
    <content type="text"><![CDATA[前言由于近期需要远程控制windows服务器，所以需要选择一个远程操控的软件，由于mac端并没有嵌入相关的功能，只能选择Microsoft Remote Desktop，并且遗憾的是，在中国区的app store并没有允许其上线，所以要做的第一步就是申请一个美区账号。 步骤 chrome打开apple id注册 按步骤注册，国家填写美国，注册完成之后需要登录一下 登录的时候会要求填写地址，以下是可用的信息街道: 4114 Sepulveda Blvd，城市: Culver City，州: CA邮编: 90230电话: (626) 339-6***商家名称: Clippinger Chevrolet Oldsmobile注意电话号码后三位随便填写几个数字 登录App Store，然后下载即可使用 Spark写这个主要是想吐槽一下，看到网上b乎各种说spark可以接收推送，即使没有打开软件，我想说简直是放屁啊，导致我查了几个小时都没能成功，根本做不到好吗！！！不信？看官网怎么说的 ——–&gt;Spark帮助中心所以只能一直开着了…垃圾的一批！！！！！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近事宜]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%9C%80%E8%BF%91%E4%BA%8B%E5%AE%9C.html</url>
    <content type="text"><![CDATA[最近生病了…加上开学事情很多…停更了一个星期 接下来会慢慢跟上的加油🆙]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask + PyJWT 实现基于Json Web Token的用户认证授权]]></title>
    <url>%2F2019%2F08%2F23%2FFlask-PyJWT-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EJson-Web-Token%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83.html</url>
    <content type="text"><![CDATA[前言这注定又将是一篇长文，接触到的第一个关于python的框架flask，本文将从最开始的安装flask，到与mysql结合，最后到用pyjwt和flask-jwt和restful写一个带有token的接口。 技术栈简介Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI(PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标)工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术 SQLAlchemyFlask是一个微型框架，自身没有提供数据库管理，表单验证，cookie处理等功能，很多功能需要通过扩展才能实现，数据库管理就需要SQLAlchemy。SqlAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简而言之：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 The first demo123456789from flask import Flaskapp = Flask(__name__)@app.route("/")def index(): return "hello world"if __name__ == '__main__': app.run() 第一行 from…import…就是导入flask中的Flask模块，不同于直接import，from…import简单来说就是帮我从车里拿瓶水，而import则是把车拿过来，所以二者在使用的时候还是有些区别的，在导入某个.py文件时，使用from…import…可以直接在该文件夹下使用import后的函数名，而如果是import，如果要调用函数必须用类.模块。 第二行 这行代码里有一个参数name，这个参数用到告诉flask你的application的名字，官方有一句话： 12If you are using a single module,__name__ is always the correct value.If you however are using a package, it’s usually recommended to hardcode the name ofyour package there. 意思就是说，如果是单一的应用，用name就可以了，如果是一个应用程序包，就hardcode一个名字给这个参数。比如： 1app = Flask(“myApp”) 由于目前我们的应用都相对简单，所以统一使用name作为参数。 第三行 使用route()修饰器注明通过什么样的url可以访问我们的函数，同时在函数中返回要显示在浏览器中的信息。 最后 调用run()方法，运行flask web应用程序 12if __name__ == '__main__': app.run() 其中if __name__==&#39;__main__&#39;的意思是，如果此文件是直接运行的才会执行app.run()这个方法，如果是通过import在其它py文件中调用的话是不会执行的。 比如我们修改code.py中的hello_world方法，如下： 1234567@app.route('/index')def hello_world(): if __name__=='main': return 'Hello World!' else: return "hello my name is "+__name__ 即当name为main时还是执行原来的逻辑，返回hello world，如果不是则输出此时的名字。 然后我们新建一个sub.py文件然后导入code.py，并且执行hello_world方法: 1234567import codedef CallCodeFun(): result = code.hello_world() print(result)CallCodeFun()print(__name__) 此时的name是Code而不是main，而此时，在sub.py中加一句print(name)可以发现sub.py中的name变成了main 由此我们可以得出 name 如果是 main 那么代表他是一个入口文件，直接执行的。 tip:建文件时文件名最好不要叫code，因为python有模块名就叫code。 flask-sqlalchemy 数据库配置，上demo 12345678910111213141516171819202122from flask_sqlalchemy import SQLAlchemyfrom flask import Flaskimport configparser# 告诉flask app的名字app = Flask(__name__)//通过configparser获取读取配置文件的解释器my_config = configparser.ConfigParser()my_config.read('db.conf')# dialect+driver://username:password@host:port/database?charset=utf8# 配置 sqlalchemy 数据库驱动://数据库用户名:密码@主机地址:端口/数据库?编码# py3无法继续使用sqldb，所以采用pymysqlapp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://' + my_config.get('DB', 'DB_USER') + ':' + \ my_config.get('DB', 'DB_PASSWORD') + '@' + my_config.get('DB', 'DB_HOST') + '/' + \ my_config.get('DB', 'DB_DB') # 设为True 表示每次请求结束后都会自动提交数据库的变动，但像add delete insert等仍需要commit,建议不要设为trueapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Truemydb = SQLAlchemy()mydb.init_app(app)if __name__ == "__main__": app.run(debug=True) 为了使代码结构更清晰，这里使用另一种配置方式，即使用单独配置文件的文件来做全局Flask配置 管控所有的配置文件conf.py: 1234567DB_USER = 'root'DB_PASSWORD = 'jwyjwy9951206-=-'DB_HOST = 'localhost'DB_DB = 'flask_migrate_demo'DEBUG = True SQLALCHEMY_TRACK_MODIFICATIONS = FalseSQLALCHEMY_DATABASE_URI = 'mysql+pymysql://' + DB_USER + ':' + DB_PASSWORD + '@' + DB_HOST + '/' + DB_DB SQLAlchemy允许我们根据数据库的表结构来创建数据模型，反之亦可。 所以我们一般无须手动的登录到数据库中使用 SQL 语句来创建表, 我们只需把数据模型定义好了之后, 表结构也就有了 新建model.py，并定义一个用户表数据模型 12345678from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class User(db.Model):user_id = db.Column(db.Integer, primary_key=True)user_name = db.Column(db.String(60), nullable=False)user_password = db.Column(db.String(30), nullable=False)user_nickname = db.Column(db.String(50))user_email = db.Column(db.String(30), nullable=False) 新建db.py，利用Flask-Script和Flask-Migrate，搭建db和app之间的桥梁 1234567891011from flask import Flaskfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommandfrom model import dbapp = Flask(__name__)app.config.from_object('conf')migrate = Migrate(app, db)manager = Manager(app)manager.add_command('db', MigrateCommand)if __name__ == '__main__':manager.run() Flask-Script和Flask-Migrate使用 最后，在pycharm的控制台打下三行迁移代码，这样就能在数据库中看见跟model字段一样的表了 123python db.py db initpython db.py db migratepython db.py db upgrade 示例接口实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# 用到flask中的Flask框架，jsonify返回json数据，request将前端字段传入后端from flask import Flask, jsonify, request# 将model中的User，db对象传入from model import db, User# 告诉flask这个app要用它app = Flask(__name__)# 读取配置文件，主要是连接mysqlapp.config.from_object('conf')# 初始化db.init_app(app)# 开始路由@app.route('/')def index(): return '&lt;h1&gt;Hello Flask!&lt;/h1&gt;'# 增@app.route('/user', methods=['POST'])def addUser(): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') user = User(user_name=user_name, user_password=user_password, user_nickname=user_nickname, user_email=user_email) try: db.session.add(user) db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id if (user.user_id is None): result = &#123;'msg': '添加失败'&#125; return jsonify(data=result) data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查@app.route('/user/&lt;int:userId&gt;', methods=['GET'])def getUser(userId): user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到数据'&#125; else: result = &#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125; return jsonify(data=result)# 改@app.route('/user/&lt;int:userId&gt;', methods=['PATCH'])def updateUser(userId): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') try: user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到要修改的记录'&#125; return jsonify(data=result) else: user.user_name = user_name user.user_password = user_password user.user_nickname = user_nickname user.user_email = user_email db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_password': data.user_password, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查全部@app.route('/user', methods=['GET'])def getUsers(): data = User.query.all() data_all = [] for user in data: data_all.append(&#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125;) return jsonify(users=data_all)# 删@app.route('/user/&lt;int:userId&gt;', methods=['DELETE'])def deleteUser(userId): # 删除数据 User.query.filter_by(user_id=userId).delete() db.session.commit() return getUsers()if __name__ == '__main__': app.run(debug=app.config['DEBUG']) ​ SQLAlchemy 几种查询方式总结 使用Flask-RESTful快速创建RESTful API接口先容我把项目做完…待续…….无聊看看文档：flask-restful中文官方文档 使用Flask + PyJWT 实现基于Json Web Token的用户认证授权待更…无聊看看文档：Flask + PyJWT 实现基于Json Web Token的用户认证授权 问题1.主要问题就是flask和mysql的连接问题，出现的最棘手的问题首先是mysqldb是py2的，py3没有，用pymysql代替，在SQLALCHEMY_DATABASE_URI注意修改driver驱动。2.最终修改方案是自己用一个demo建好了数据库和表(记得保存好demo)，demo如下，然后再运行就可以了。 12345678910111213141516from sqlalchemy import create_engine,Table,Column,Integer,String,MetaData,ForeignKeyengine=create_engine("mysql+pymysql://root:a5230411@localhost:3306/test",echo=True)metadata=MetaData(engine)user=Table('user',metadata, Column('id',Integer,primary_key=True), Column('name',String(20)), Column('fullname',String(40)), )address_table = Table('address', metadata, Column('id', Integer, primary_key=True), Column('user_id', None, ForeignKey('user.id')), Column('email', String(128), nullable=False) )metadata.create_all() 3.解决 sqlalchemy 报错:(1193, “Unknown system variable ‘tx_isolation’”): 传送门 参考网址 Flask + PyJWT 实现基于Json Web Token的用户认证授权 使用 Flask 设计 RESTful 的认证 使用Flask-RESTful快速创建RESTful API接口 Flask + flask-jwt 实现基于Json Web Token的用户认证授权 Flask程序目录结构——构建可扩展的Flask应用程序 Python的flask：models.py来创建mysql数据库 python使用sqlalchemy连接mysql数据库 深入浅出Flask(学习教程) 深入浅出理解Python装饰器 flask-restful中文官方文档]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>PyJWT</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术]]></title>
    <url>%2F2019%2F08%2F20%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html</url>
    <content type="text"><![CDATA[第一章Java的11个关键术语 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java applet在网页中运行的Java程序称为applet 第二章部分术语 JDK(java development kit):java开发工具包 JRE(Java Runtime Environment):运行java程序用户所使用的软件 SDK(Software Development Kit):软件开发包 安装过程MAC中JAVA环境变量配置以及Intellij IDEA如何配置JDKIDEA的校园邮箱激活方式IntelliJ IDEA 常用快捷键 之 Mac 版Intellij IDEA快捷生成常用代码 琐碎知识点 0x1.0p-3:0x表示16进制，使用p表示指数，所以就是1.0*2的-3次方 三个特殊的浮点数值：正无穷大(Double.POSITIVE_INFINITY)、负无穷大(Double.NEGATIVE_INFINITY)、NaN(Double.NaN) 浮点数值不适用于无法接受舍入误差的计算中，要想完全没有误差，需要使用BigDecimal类 部分特殊字符的转义序列：\b 退格 \t 制表 \n 换行 \r 回车 \“双引号 \反斜杠 强烈建议不要在程序中使用char类型，因为unicode早已经超过了65536个 第三章部分术语 类常量：static final,类常量的定义在main方法的外部 整数被0除将会产生异常，浮点数被0除将会得到无穷大或NaN结果 public static strictfp void main(String[] args)，在该main函数中所有指令都将使用严格的浮点计算 condition ? expression1 : expression2 eg: x&lt;y ? x : y 位运算符：&amp;、|、^、~拓展：奇数个数，两个两个成对最有一个单独，如何找出这个单独的数字是几，复杂度在O(n)以内：用异或的思想即可，全部异或 移位运算符: &lt;&lt;(算数移位)&gt;&gt; &gt;&gt;&gt;(逻辑右移),其中&gt;&gt;&gt;会用0填充高位，移位运算符的右操作数要满足模32的运算(如果左边操作数是long则要满足模64)，1&lt;&lt;35 == 1&lt;&lt;3 == 8 枚举类型：enum Size{SMALL,MEDIUM,LARGE } 字符串 子串: 12String greeting = "Hello";String s = greeting.substring(0,3); 拼接:直接用+连接、如果需要多个字符串放在一起，并且用一个定界符分割，可以采用静态join方法： 12String all = String.join("/","S","M","L","XL")// string: "S/M/L/XL" java中不允许修改字符，但是可以修改字符串变量*字符串比较用equals方法，例如：”Hello”.equals(greeting),”Hello”.equalsIgnoreCase(“hello”)「无视大小写的比较」 java.lang.string部分apiString类常用方法之charAt()、codePointAt()示例offsetByCodePoints()与codePointAt() 注意lastIndexOf(int cp,int fromindex)，是返回从index位置开始找到的第一个符合的字符串的位置 12345678910111213141516public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125; &#125; input Scanner在util包中，当使用的类不在java.lang中时，都需要导包 1234567Scanner sc = new Scanner(System.in); String nextLine = sc.nextLine(); System.out.println("please input your name:" + nextLine); int nextInt = sc.nextInt(); System.out.println("please input your age:" + nextInt);String next = sc.next();System.out.println("please input your name:" + next);]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活好难啊]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%94%9F%E6%B4%BB%E5%A5%BD%E9%9A%BE%E5%95%8A.html</url>
    <content type="text"><![CDATA[今天被打击了…卧槽这个大数据怎么这么枯燥…再次怀疑不适合学计算机…把我看睡着了可还行（吐血…算了还是接着干吧）]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>负情绪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka]]></title>
    <url>%2F2019%2F08%2F18%2Fkafka.html</url>
    <content type="text"><![CDATA[初识kafkakafka概念Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据,是用于构建实时数据管道和流应用程序。 四个术语 TopicKafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic)。 Producer发布消息的对象称之为主题生产者(Kafka topic producer)。生产者发布消息时要选定Topic上的分区。 Consumer订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)。一般消费者模型可以分为两类：队列和发布-订阅式。队列的处理方式就是一条消息只有一个消费者知道并处理，发布-订阅的处理方式则是消息被所有人都知道，所有人都可以来处理该消息，kafka为这两种模型提供了单一抽象模型：消费者组（cosumer group）。每个消费者都有一个组名，当所有人的组名都不一样的时候，这个时候就是发布-订阅模式，因为消息要按照消费者组为单位发出的，这意味着此时每个消费者都会收到消息并可以进行处理；当所有人的消费者组名字都一样时，意味着只会有一个消费者收到消息并可以进行处理，此时就是队列模式了。 Broker已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。 三个关键能力 发布和订阅消息流，在这方面，它类似于一个消息队列或企业消息系统 以容错的方式存储消息（流) 在消息流发生时处理他们 四个核心API 应用程序使用 Producer API 发布消息到1个或多个topic（主题）。 应用程序使用 Consumer API 来订阅一个或多个topic，并处理产生的消息 应用程序使用 Streams API 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。 Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。 kafka安装过程 kafka的安装 1brew install kafka 安装会依赖zookeeper 注意：安装目录：/usr/local/Cellar/kafka/0.10.2.0 安装的配置文件位置/usr/local/etc/kafka/server.properties/usr/local/etc/kafka/zookeeper.properties 启动zookeeper 1zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp; 启动kafka 1kafka-server-start /usr/local/etc/kafka/server.properties &amp; 创建topic让我们使用单个分区和只有一个副本创建一个名为“test”的主题 1kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 查看创建的topic我们现在可以看到该主题，如果我们运行list topic命令： 1kafka-topics --list --zookeeper localhost:2181 发送消息Kafka提供了一个命令行客户端，它将从文件或标准输入接收输入，并将其作为消息发送到Kafka集群。默认情况下，每行都将作为单独的消息发送。运行生产者，然后在控制台中键入一些消息发送到服务器。 1kafka-console-producer --broker-list localhost:9092 --topic test 消费消息Kafka还有一个命令行消费者，将消息转储到标准输出。 1kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning TipQ:安装kafka出现错误： 1234kafka: Java 1.8 is required to install this formula.Install AdoptOpenJDK 8 with Homebrew Cask: brew cask install homebrew/cask-versions/adoptopenjdk8Error: An unsatisfied requirement failed this build. A: 1brew cask install homebrew/cask-versions/adoptopenjdk8 bilibili学习kafkahttps://www.bilibili.com/video/av36607048?p=2 zookeeper 默认是前台启动(关闭了控制台停止)，可以在最前面加上 nohup，这样就可以后台启动了。 三个目录 bin目录1cd usr/local/Cellar/kafka/2.2.1/bin * config文件 1/usr/local/etc/kafka/server.properties * 日志 1234############################# Log Basics ############################## A comma separated list of directories under which to store log fileslog.dirs=/usr/local/var/lib/kafka-logs 删除topic1kafka-topics --delete --zookeeper localhost:2181 --topic test]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实践winrm，实现远程连接调度Windows服务器]]></title>
    <url>%2F2019%2F08%2F17%2Fpython%E5%AE%9E%E8%B7%B5winrm%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%83%E5%BA%A6Windows%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[前言最近有个需求：用自己主机控制多个windows节点，实时获取他们的cpu和运存占用情况，通过查询，决定采用python中的winrm。Tip:winrm服务是windows 一种方便远程管理的服务；开启winrm service,便于在日常工作中，远程管理服务器，或通过脚本，同时管理多台服务器，来提高工作效率。 常规做法配置远程主机,使其支持被远程控制 查看winrm service listener（分为http和https）:1winrm e winrm/config/listener 如果没有返回，则没有开启winrm服务。 开启winrm服务： 1winrm quickconfig 为winrm service 配置auth: 1winrm set winrm/config/service/auth @&#123;Basic="true"&#125; 为winrm service 配置加密方式为允许非加密： 1winrm set winrm/config/service @&#123;AllowUnencrypted="true"&#125; 查看winrm服务的配置： 1winrm get winrm/config 客户端主机 装winrm 1pip install pywinrm 测试 1234import winrmwintest = winrm.Session('http://47.98.149.160:5985/wsman',auth=('Administrator','Jwy12345a'))ret = wintest.run_cmd('ipconfig')print(ret) 遇到的问题及解决措施 在测试环节，导入winrm包后，控制台显示：winrm has no attribute session 解决办法：pip导错了包，应该是pywinrm这个包，将pip原来的包删除，重新导入一遍。 pycharm问题：module ‘pip’ has no attribute ‘main’ 解决办法：pip升级导致无法导包 测试的时候，报出以下错误： 1requests.exceptions.ConnectTimeout: HTTPConnectionPool(host='47.98.149.160', port=5985): Max retries exceeded with url: /wsman (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x104921650&gt;, 'Connection to 47.98.149.160 timed out. (connect timeout=30)')) 解决办法：由于云服务器有公网ip地址，所以本机可以ping通服务器，但是由于本机不存在公网地址，是局域网地址，所以服务器不能ping通主机，导致二者不能正常通信，只能换一种方法，也就是在云服务器端运行程序，程序提供了当前cpu运行情况和运存情况，本机可以随时访问并得到信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import timeimport psutil # cd C:\Python36-32\Scripts pip install psutil# 获取本机磁盘使用率和剩余空间G信息import pymysqlconn = pymysql.connect(user="root", passwd="No.93329332", host="134.175.5.88", port=3306, db="node_status")cur = conn.cursor()flag = 0while(True): # 循环磁盘分区 content = "" for disk in psutil.disk_partitions(): # 读写方式 光盘 or 有效磁盘类型 if 'cdrom' in disk.opts or disk.fstype == '': continue disk_name_arr = disk.device.split(':') disk_name = disk_name_arr[0] disk_info = psutil.disk_usage(disk.device) # 磁盘剩余空间，单位G free_disk_size = disk_info.free // 1024 // 1024 // 1024 # 当前磁盘使用率和剩余空间G信息 if (disk_name == 'C'): disk_c_name = disk_name disk_c_info = disk_info free_c_disk_size = free_disk_size info = "%s盘使用率：%s%%， 剩余空间：%iG" % (disk_c_name, str(disk_c_info.percent), free_c_disk_size) # print(info) # print(disk_name) if (disk_name == 'C'): # 拼接多个磁盘的信息 content = content + info print(content) # return content # cpu信息 cpu_percent = psutil.cpu_percent(interval=1) cpu_info = "CPU使用率：%i%%" % cpu_percent print(cpu_info) # return cpu_info # 内存信息 virtual_memory = psutil.virtual_memory() used_memory = virtual_memory.used / 1024 / 1024 / 1024 free_memory = virtual_memory.free / 1024 / 1024 / 1024 memory_percent = virtual_memory.percent memory_info = "内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG" % (used_memory, memory_percent, free_memory) print(memory_info) # return memory_info now = time.asctime() if(flag == 0): sql = "INSERT INTO status(ip, \ disk_percent, disk_freesize, CPU_percent, memory_used,memory_free,memory_percent,mytime) \ VALUES ('%s', '%s', '%s', '%s', '%s','%s','%s','%s')" % \ ('106.13.70.159', str(disk_c_info.percent) + "%", str(free_c_disk_size) + "G", str(cpu_percent) + "%",str(used_memory)[:3] + "G",str(free_memory)[:3] + "G",str(memory_percent) + "%",now) flag = 1 else: used_memory_float = str(used_memory)[:3] + 'G' free_memory_folat = str(free_memory)[:3] + 'G' disk_c_info_percent_str = str(disk_c_info.percent) + '%' free_c_disk_size_str = str(free_c_disk_size) + 'G' cpu_percent_str = str(cpu_percent) + '%' memory_percent_str = str(memory_percent) + '%' sql = "update status set disk_percent = '%s', disk_freesize = '%s', \ CPU_percent = '%s', memory_used = '%s' , memory_free = '%s' ,\ memory_percent = '%s' , mytime = '%s' where ip = '106.13.70.159'" % \ (disk_c_info_percent_str,free_c_disk_size_str,cpu_percent_str,used_memory_float,free_memory_folat,memory_percent_str,now) flag = 2 try: # 执行sql语句 cur.execute(sql) # 执行sql语句 conn.commit() if(flag==1): print("insert ok") else: print("update ok") except Exception as e: # 发生错误时回滚 conn.rollback() print("failed") print(e) time.sleep(60)# 关闭数据库连接conn.close() sql中update也可以 1sql = "update table set ss = '%s'where id = '1'"% disk]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>winrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo的NexT主题---从入门到入土]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%9F%BA%E4%BA%8EHexo%E7%9A%84NexT%E4%B8%BB%E9%A2%98-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.html</url>
    <content type="text"><![CDATA[前言本篇文章主要是针对nexT主题的优化说明，使用hexo其他主题的童靴请绕道~~整理一下大概优化：1.标题部分优化，颜色样式；2.设置博客文章连接为year/month/day/title.html格式3.Menu增加关于、标签、分类、互动、搜索菜单4.禁用关于、标签、分类菜单评论功能5.添加RSS6.设置背景图片7.Canvas_nest动态背景8.图片快速加载设置9.微信支付宝打赏功能10.点击出现桃心效果11.主页文章添加阴影效果12.设置代码高亮13.顶栏背景色14.底栏背景色15.修改文章内链接文本样式16.修改文章底部标签样式17.在文章末尾添加“文章结束”标记18.设置头像19.网站底部加上访问量20.网站底部字数统计21.网站底部添加网站运行时间22.网站底部添加动态桃心23.底部隐藏由Hexo强力驱动、主题–NexT.Mist24.设置网站的图标Favicon25.实现文章文字统计功能和阅读时长26.加来必力云跟帖功能27.去掉底部重复字数统计28.修改字体大小29.侧边栏社交小图标设置30.添加侧栏推荐阅读31.修改侧边栏背景图片32.添加侧边栏音乐33.修改侧边栏文字颜色34.在文章底部增加版权信息35.Hexo博客添加站内搜索36.修改选中字符的颜色37.添加aplay音乐播放38.添加博客左下角门神(看门🐶)39.增加了3D库three_waves，默认关闭40.增加了canvas页面丝带(话说这玩意真的很吃cpu，一开我的mac就铁板烧了)41.增加了首页pace加载进度42.增加图片懒加载lazyload43.增加了fancybox44.增加了fastclick解决延迟问题45.增加了gulp压缩网页css js样式46.截断首页文章内容47.代码复制功能 hexo目录结构主目录结构 _config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。 package.jsonhexo框架的参数和所依赖插件。 scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。 source这个目录很重要，新建的文章都是在保存在这个目录下的._posts，需要新建的博文都放在_posts目录下。_posts目录下是一个个 markdown 文件。你应该可以看到一个 hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。里面还有一个重要文件夹：images，是用来存放博文的图片的，这里建议使用七牛云图床来存储图片，因为可以更快的加载图片。同时强烈建议大家用一款hexo—client来进行可视化博客的书写，一站式服务，支持七牛云图床，接好传送门：hexoclient。 themes网站主题目录，我用的就是nexT主题。 node_moduleshexo依赖的组件都在其中。 主题目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 高度定制优化篇标题部分优化，颜色样式首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就去themes/nexT/source/css/_schemes/Mist/_header.styl下，添加以下代码：12345//可以加图片，也可以自己调色彩.header &#123; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; &#125; 设置背景图片默认禁用，可以在themes/nexT/source/css/_custom/custon.styl文件中启用12345678//设置背景图片body &#123; background:url(http://pw5u1sbg2.bkt.clouddn.com/145676.jpg); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; Canvas_nest动态背景背景的几何线条是采用的nest效果, 一个基于html5 canvas绘制的网页背景效果, 非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖jQuery，使用原生的javascript 非常小，只有1.66kb，如果开启gzip，可以更小 非常容易实现，配置简单，即使你不是web开发者，也能简单搞定说明 color：线条颜色，默认： ‘0,0,0’ ；三个数字分别为(R,G,B)，这里推荐一个颜色采集器：ColorSlurp，在AppStore中就可以搜到 opacity：线条透明度（0~1），默认: 0.5 count：线条的总数量， 默认：150 zIndex：背景的z-index属性，css属性用于控制所在层的位置，默认：-1不足内存占用过高做法直接找到主题配置文件，将canvas改为true即可。RSS在你的hexo站点目录下：1$ npm install hexo-generator-feed --save 打开站点目录下的_config.yml:12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 来必力评论系统等第三方插件登录 来必力 ，获取LiveRe UID，编辑主题配置文件，编辑livere_uid字段，将id填入即可，更多第三方集成插件可见：nexT官网，包括评论系统、数据统计与分析、内容分享服务、搜索服务等等。 打赏功能nexT集成了支付宝微信打赏功能，直接在主题配置文件搜索wechat或者alipay即可,然后跟上自己的微信和支付宝的收钱码图片地址即可。 点击出现桃心效果1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 新建 clicklove.js 文件并且将以上代码复制进去，然后保存。 将 clicklove.js文件放到路径 /themes/next/source/js/src 里面 然后打开 \themes\next\layout\_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 主页文章添加阴影效果打开 themes/next/source/css/_custom/custom.styl，向里面加代码:12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 代码高亮直接在主题配置文件搜索 highlight_theme：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 顶部底部背景色改变首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就themes/nexT/source/css/_schemes/Mist/_header.styl下，将颜色进行修改即可。底部颜色则在themes/nexT/source/css/_schemes/Mist/index.styl中进行修改：123456789101112131415161718// Footer// --------------------------------------------------.footer &#123; margin-top: 80px; padding: 10px 0; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; color: $grey-dim;&#125;.footer-inner &#123; margin: 0 auto; text-align: left; +mobile() &#123; width: auto; text-align: center; &#125;&#125; 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改网页底部 在图标库中找到你自己喜欢的图标, 修改桃心,打开 themes/next_config.yml ,搜索关键字 authoricon,替换图标名： 12# icon between year and author @Footerauthoricon: id-card 隐藏网页底部 Hexo 强力驱动 打开主题配置文件,搜索关键字 copyright ，如下: 12# Footer `powered-by` and `theme-info` copyrightcopyright: false 添加文章结束标记在themes/next/layout/_macro/post.swig中, 在wechat-subscriber.swig之前添加如下代码:123&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 统计功能，统计功能,显示文章字数统计,阅读时长,总字数在站点的根目录下：1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount：1234567891011# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: true separated_meta: true 设置头像打开 themes/next/_config.yml ，搜索关键字 avatar：123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: http://pw5u1sbg2.bkt.clouddn.com/avatar.png #/images/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 底部添加访问量和字数统计运用第三方插件，见nexT官网，推荐百度统计和不蒜子统计。 底部添加运行时间找到\themes\next\layout\_partials\下面的footer.swig文件，在末尾添加所示代码：12345678910111213141516171819&lt;div class="run_time" style=" text-align:center;"&gt; &lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("08/06/2019 19:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250); &lt;/script&gt;&lt;/div&gt; 底部添加红心打开 themes/next/_config.yml ，搜索关键字 footer：123456789101112131415footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # visitors count counter: true # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 添加侧边栏音乐框去往网易云音乐搜索喜欢的音乐，点击生成外链播放器， 复制代码直接放到博文末尾即可，height设为0可隐藏播放器，但仍然可以播放音乐，auto设成0可手动播放，默认是1自动播放，可把代码放到themes/next/layout/_custom/sidebar.swig文件里，播放器会显示在站点预览中,示例代码如下：12&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2588481240&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt; 添加aplayer音乐播放由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为guestbook： 1hexo new page guestbook 这时候在 /Hexo/source 文件夹下会生成一个guestbook文件夹，打开里面的index.md，示例如下： 123456789101112---title: 留言互动date: 2019-08-15 12:18:09type: "guestbook"---&lt;div align="center"&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558956326532&amp;di=82cc9907fc903cfb978a35206986d3f6&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160809%2F31283a3e2d7f411492d3fb27297180ec_th.jpg" /&gt;&lt;/div&gt;[//]: #(aplay音频播放https://github.com/MoePlayer/hexo-tag-aplayer)&#123;% meting "2331951308" "netease" "playlist" "autoplay" "mutex:false" "order:random" "listmaxheight:250px" "preload:none" "theme:#f7f7f7"%&#125; meting中配置参数含义如下： 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启固定模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 theme #ad7a86 播放器风格色彩设置 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto 打开主题_config.yml文件，在menu下新建一个名为guestbook的类，完成后如下所示： 1234567menu: home: / || home tags: /tags/ || tags categories: /categories/ || bookmark archives: /archives/ || archive about: /about/ || user 互动: /guestbook/ || comments 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 12menu: guestbook: 互动 至此，歌单页面创建完成，现在只需要在站点配置文件中开启meting模式，在_config.yml中搜索meting： 12aplayer: meting: true Tip同一个歌单不能做到实时刷新，需要24小时后aplayer才会自动更新缓存 添加博客左下角门神安装依赖:12npm install --save hexo-helper-live2dnpm install --save live2d-widget-model-wanko 站点配置添加:12345678910111213141516171819202122# hexo-helper-live2d配置, 参考https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: scale: 1 use: live2d-widget-model-wanko display: superSample: 2 # 超采样等级 width: 100 height: 100 position: left # 位置 mobile: show: false react: opacityDefault: 0.9 # 默认透明度 opacityOnHover: 0.5 # 鼠标移上透明度 增加首页pace加载进度打开主题配置文件：12345678# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-bounce 增加图片懒加载lazyload打开主题配置文件：123# Vanilla JavaScript plugin for lazyloading images.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: true 增加fancybox和fastclick解决延迟问题打开主题配置文件：123456789# Fancybox. There is support for old version 2 and new version 3.# Choose only one variant, do not need to install both.# To install 2.x: https://github.com/theme-next/theme-next-fancybox# To install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: true# Polyfill to remove click delays on browsers with touch UIs.# Dependencies: https://github.com/theme-next/theme-next-fastclickfastclick: true 截断首页文章内容打开主题配置文件，搜索auto_excerpt：12345# Automatically Excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 代码复制功能 复制该网页的代码，传送门：clipboard.min.js，然后在themes\next\source\js\src下新建clipboard.min.js文件，将以上内容复制进去即可； 在themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 123456789101112131415161718 /*页面载入完成后，创建复制按钮*/ !function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; //fa fa-globe可以去字体库替换自己想要的图标copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode(); &#125;(window, document); 在themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":1,"width":250,"height":300,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});）之前添加）： 123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 尝试了但未实现的功能1.用mob_share的app_key未能实现share的功能，经过其官方人员电话沟通，已经不再支持pc端博客服务2.aplay音乐播放歌单，不能做到实时更新歌单，究其原因是其api设置了24小时缓存，同一个歌单24小时内不会发生改变 非常有益的网址 NexT主题进阶 基于Hexo的个人博客搭建(进阶版) Hexo+Next主题优化]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为列数。该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 My code1234567891011121314151617# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here row = len(array) col = len(array[0]) c = col - 1 r = 0 while(r &lt;= row-1 and c &gt;=0): if(target == array[r][c]): return True elif(target &gt; array[r][c]): r+=1 else: c-=1 return False 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路将字符串复制给一个新的列表，碰到空格则替换，没有则copy原字符串，最后对列表进行join，返回字符串。 易错点 My code12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here t = len(s) j = 0 m = list(s) for i in range(0,t): if(s[i] == ' '): m[j] = '%20' j+=1 else: m[j] = s[i] j+=1 pass return ''.join(m)# s = 'I want to sleep'# solution = Solution()# ss = solution.replaceSpace(s)# print(ss) 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路知识点补充python中链表的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(): '创建节点' def __init__(self,data): self.data = data self.next = None class LinkList(): '创建列表' def __init__(self, node): '初始化列表' self.head = node self.head.next = None self.tail = self.head def add_node(self, node): '添加节点' self.tail.next = node self.tail = self.tail.next def view(self): '查看列表' node = self.head link_str = '' while node is not None: if node.next is not None: link_str += str(node.data) + '--&gt;' else: link_str += str(node.data) node = node.next print ('The Linklist is:' + link_str) def length(self): '列表长度' node = self.head count = 1 while node.next is not None: count += 1 node = node.next print ('The length of linklist are %d' % count) return count def delete_node(self, index): '删除节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index-1: break node = node.next num += 1 tmp_node = node.next node.next = node.next.next return tmp_node.data def find_node(self, index): '查看具体节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index: break node = node.next num += 1 return node.data My code123456789101112131415# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here res=[] while listNode: res.append(listNode.val) listNode=listNode.next return res[::-1] #逆序打印 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路 递归 整体思路就是：利用递归的思想，跟归并和快排有异曲同工之妙。抓住第一个节点是根节点，然后在中序遍历中定位该节点，左边即为根节点的左子树，右边即为根节点的右子树。然后对左子树和右子树分别进行递归即可，直到左子树和右子树都没了。 非递归 整体思路：我还没认真看呢！！！！！！！！ 用两个堆栈来分别存储二叉树和先序中序序列索引值，跟递归思路一样，先找到根节点，然后分别判断在中序遍历中是否还有左右子树，如果有则计数值count+=1,当找到一个节点之后就将计数值count-=1，直到中序遍历中再也没有左右子树。 My code递归1234567891011121314151617181920212223242526272829303132333435/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre, int [] in) &#123; if(pre == null || in == null || pre.length == 0 || in.length == 0)&#123; return null; &#125; return constructBinaryTree(pre,in,0,pre.length-1,0,in.length-1); // 首先看先序遍历的第一个数，这是根节点，然后根据中序遍历然后分为左右两个节点块 // 再看左边的第一个数，这个肯定是根节点，然后定位到中序遍历该数的位置，再将其分为左右两个节点块，以此类推。 &#125; private TreeNode constructBinaryTree(int[] pre, int[] in, int preStart, int preEnd, int inStart, int inEnd) &#123; if(preStart &gt; preEnd || inStart &gt; inEnd)&#123; return null; &#125; TreeNode node = new TreeNode(pre[preStart]); int mid = inStart; while (pre[preStart] != in[mid]) mid++; int preNumber = mid - inStart; node.left = constructBinaryTree(pre,in,preStart + 1,preStart + preNumber,inStart,mid - 1); node.right = constructBinaryTree(pre,in,preStart + preNumber + 1,preEnd,mid + 1,inEnd); return node; &#125;&#125; 非递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.*;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; //p用来保存两个序列的索引值 Stack&lt;Integer&gt; p = new Stack&lt;Integer&gt;(); Stack&lt;TreeNode&gt; l = new Stack&lt;TreeNode&gt;(); TreeNode cur = null; p.push(0); p.push(pre.length - 1); p.push(0); p.push(in.length - 1); int count = 1; int pStart = 0; int pEnd = pre.length - 1; int iStart = 0; int iEnd = in.length - 1; TreeNode root = new TreeNode(-1); l.push(root); while( count != 0)&#123; iEnd = p.pop(); iStart = p.pop(); pEnd = p.pop(); pStart = p.pop(); cur = l.pop(); count -= 1; int index = find(pre[pStart], in, iStart, iEnd); cur.val = pre[pStart]; int lenL = index - iStart; if(lenL == 0)&#123; &#125;else&#123; p.push(pStart + 1); p.push(pStart + lenL); p.push(iStart); p.push(index - 1); count += 1; cur.left = new TreeNode(-1); l.push(cur.left); &#125; int lenR = iEnd - index; if(lenR == 0)&#123; &#125;else&#123; p.push(pStart + lenL + 1); p.push(pEnd); p.push(index + 1); p.push(iEnd); count += 1; cur.right = new TreeNode(-1); l.push(cur.right); &#125; &#125; return root; &#125; int find(int target, int[] all, int start , int end)&#123; for(int i = start; i &lt;= end; ++i)&#123; if(all[i] == target) return i; &#125; return -1; &#125;&#125; 知识点补充Tips: 二叉树的前序，中序，后序遍历方法总结 前序递归和非递归算法前序递归递归的方法很容易实现，也很容易理解：我们先访问根节点，然后递归访问左子树，再递归访问右子树，即实现了根-&gt;左-&gt;右的访问顺序，因为使用的是递归方法，所以每一个子树都实现了这样的顺序。 1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); preorderHelper(root, result); return result; &#125; private void preorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; result.add(root.val); // 访问根节点 preorderHelper(root.left, result); // 递归遍历左子树 preorderHelper(root.right, result); //递归遍历右子树 &#125;&#125; 前序非递归在迭代法中，我们使用栈来实现。由于出栈顺序和入栈顺序相反，所以每次添加节点的时候先添加右节点，再添加左节点。这样在下一轮访问子树的时候，就会先访问左子树，再访问右子树： 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null) return result; Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); toVisit.push(root); TreeNode cur; while (!toVisit.isEmpty()) &#123; cur = toVisit.pop(); result.add(cur.val); // 访问根节点 if (cur.right != null) toVisit.push(cur.right); // 右节点入栈 if (cur.left != null) toVisit.push(cur.left); // 左节点入栈 &#125; return result; &#125;&#125; 中序递归和非递归算法中序递归无论对于哪种方式，递归的方法总是很容易实现的，也是很符合直觉的。对于中序遍历，就是先访问左子树，再访问根节点，再访问右子树，即 左-&gt;根-&gt;右： 1234567891011121314class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); inorderHelper(root, result); return result; &#125; private void inorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if(root == null) return; inorderHelper(root.left, result); // 递归遍历左子树 result.add(root.val); // 访问根节点 inorderHelper(root.right, result); // 递归遍历右子树 &#125;&#125; 中序非递归中序遍历的迭代法要稍微复杂一点，因为最先遇到的根节点不是最先访问的，我们需要先访问左子树，再回退到根节点，再访问根节点的右子树，这里的一个难点是从左子树回退到根节点的操作，虽然可以用栈来实现回退，但是要注意在出栈时保存根节点的引用，因为我们还需要通过根节点来访问右子树： 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !toVisit.isEmpty()) &#123; while (cur != null) &#123; toVisit.push(cur); // 添加根节点 cur = cur.left; // 循环添加左节点 &#125; cur = toVisit.pop(); // 当前栈顶已经是最底层的左节点了，取出栈顶元素，访问该节点 result.add(cur.val); cur = cur.right; // 添加右节点 &#125; return result; &#125;&#125; 在看这部分代码中，脑海中要有一个概念：当前树的根节点的左节点，是它的左子树的根节点。因此从不同的层次上看，左节点也是根节点。另外，LeetCode上也提供了关于中序遍历的动态图的演示，感兴趣的读者可以去看一看。 后序递归和非递归算法后序递归无论对于哪种方式，递归的方法总是很容易实现的，也是很符合直觉的。对于后序遍历，就是先访问左子树，再访问右子树，再访问根节点，即 左-&gt;右-&gt;根： 1234567891011121314class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); postorderHelper(root, result); return result; &#125; private void postorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; postorderHelper(root.left, result); // 遍历左子树 postorderHelper(root.right, result); // 遍历右子树 result.add(root.val); // 访问根节点 &#125;&#125; 后序非递归前面说过，与中序遍历不同的是，后序遍历在访问完左子树向上回退到根节点的时候不是立马访问根节点的，而是得先去访问右子树，访问完右子树后在回退到根节点，因此，在迭代过程中要复杂一点： 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode pre = null; while (cur != null || !toVisit.isEmpty()) &#123; while (cur != null) &#123; toVisit.push(cur); // 添加根节点 cur = cur.left; // 递归添加左节点 &#125; cur = toVisit.peek(); // 已经访问到最左的节点了 //在不存在右节点或者右节点已经访问过的情况下，访问根节点 if (cur.right == null || cur.right == pre) &#123; toVisit.pop(); result.add(cur.val); pre = cur; cur = null; &#125; else &#123; cur = cur.right; // 右节点还没有访问过就先访问右节点 &#125; &#125; return result; &#125;&#125; 这里尤其注意后续遍历和中序遍历中对于从最左侧节点向上回退时的处理： 在后序遍历中，我们首先使用的是： 1cur = toVisit.peek(); 注意，这里使用的是peek而不是pop，这是因为我们需要首先去访问右节点，下面的： 1if (cur.right == null || cur.right == pre) 就是用来判断是否存在右节点，或者右节点是否已经访问过了，如果右节点已经访问过了，则接下来的操作就和中序遍历的情况差不多了，所不同的是，这里多了两步： 12pre = cur;cur = null; 这两步的目的都是为了在下一轮遍历中不再访问自己，cur = null很好理解，因为我们必须在一轮结束后改变cur的值，以添加下一个节点，所以它和cur = cur.right一样，目的都是指向下一个待遍历的节点，只是在这里，右节点已经访问过了，则以当前节点为根节点的整个子树都已经访问过了，接下来应该回退到当前节点的父节点，而当前节点的父节点已经在栈里了，所以我们并没有新的节点要添加，直接将cur设为null即可。 pre = cur 的目的有点类似于将当前节点标记为已访问，它是和if条件中的cur.right == pre配合使用的。注意这里的两个cur指的不是同一个节点。我们假设当前节点为C，当前节点的父节点为A，而C是A的右孩子，则当前cur是C，但在一轮中，cur将变成A，则： 123 A / \B C (pre) pre = cur 就是 pre = C if (cur.right == null || cur.right == pre) 就是 if (A.right == null || A.right == pre) 这里，由于A是有右节点的，它的右节点就是C，所以A.right == null不成立。但是C节点我们在上一轮已经访问过了，所以这里为了防止进入else语句重复添加节点，我们多加了一个A.right == pre条件，它表示A的右节点已经访问过了，我们得以进入if语句内，直接访问A节点。 用两个栈实现队列旋转数组的最小数字tips：只要是关于有序数组，基本就在考察二分法 斐波那契数列变态跳台阶]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在macOS上使用GitHub Pages+Hexo搭建个人博客]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[搭建环境操作系统：macos 10.14.5工具：github Desktop, Node.js, Git框架：Hexo, Github Pages 具体步骤安装git直接在终端输入git --version判断自己系统是否已有git，如果没有，点击该链接git下载，安装完后进入终端输入git --version检查是否安装成功。 安装node.js话不多说，上链接：node.js下载，然后傻瓜式安装就行。安装完之后请记得去控制台看看是否安装成功node --version,然后更新一下npm,输入:npm install -g npm 注册账号并创建博客仓库a.首先进入github官网：github,进行相应的注册登录，然后创建仓库，就在左上角那个猫猫旁边。b.戳进去之后,Respository name必须是:您的github账户名.github.io,然后勾选下面的创建readme，创建完成。c.进入仓库，点击Setting，启用GitHub Pages,此时你输入您的github账户名.github.io,就能看到不是404了，说明此时博客已经建立了，接下来就是利用Hexo框架让你的博客美起来啦！！！！ 安装配置Hexoa.首先建立一个文件夹(随便你建在哪)b.在该文件夹内打开终端，输入：1$ npm install hexo-cli -g 接下来你就能看到文件夹内的东西多了起来哈哈哈，如下图所示的文件结构：c.Hexo已经有了，github pages也有了，现在就剩把他们联系起来了，所以这步就是关键咯，打开上图第一个文件：_config.yml,然后在文本的结尾加上下面的一段代码：1234deploy: type: git repository: https://github.com/jeromememory/jeromememory.github.io.git branch: master 其中repository就是你最开始设置的仓库哟，记得替换自己的github用户名。 检测是否部署成功首先如果你想在本地预览你的博客，只需要打开终端,首先进入Hexo文件夹内，然后进行 hexo s即可：12$ cd /Users/jerome/Hexo $ hexo s 然后你就会看到在终端提示你在localhost:4000预览你的博客啦！！如果你想在网页上看到你的博客，只需要在终端输入：12$ hexo g$ hexo d 稍等一小会(github pages需要一小段时间才会更新)，你就能在你仓库对应的那个网址(您的github用户名.io.git)看到您的博客了，至此，您的博客应该就已经搭建完成了，当然您肯定会说这也太丑了吧，对，我也觉得，所以接下来请继续看下面的操作吧！！！ Hexo主题配置默认的主题很丑，所以这个时候我们就可以去github这个最大的开源网站找了，我推荐Hexo的next主题，我自己用的就是这个，极简至极，找到别人的主题之后，把他的代码clone下来，放到/Hexo/themes这个文件夹下：然后去开始的_config.yml中定位到theme，将后面的值改为你的主题名，别忘了，改完这些后，打开终端，输入：12$ hexo g$ hexo d 过一小会你就能看到自己的主题发生变化啦！剩下的具体配置，我就偷偷懒放个链接：NexT主题，其他主题的同学，你们也可以自己查一下对应的官网哟，都写的贼详细，好用！ 总结至此，个人博客就应该搭建好了，希望对大家有所收获！!(话说第一篇博客果然是狗屁不通啊大家凑合看吧)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
</search>
